\ yitgadal_b for string quartet, computationanew task-yitgadal_compute\ in this version, the harmonic series is Gb, and the fundamendatl\ is a low Gb, several octaves below the bass clef. the lowest\ cello note is the 6th harmonic of this, the highest cello note\ is a G natural, the 17th harmonic... all other notes are above that...\ e.g the lowest 2nd violin note is the same as the top cello note, the 17th\ harmonic\ these notes are all members of a harmonic series, a c 3 octaves below the low cello\ c... this means ratios are not needed: STUFF.FUNDAMENTAL-ARRAYS	stuff{  6 8 13 16 \ cello	10 14 22 40 \ viola	17 26 34 48 \ violin 2	16 22 40 56 \ violin 1	}stuff: string-fundamentals;: STUFF.STRING-ARRAYS { | fundamental-pitch current-instrument -- }	4 0 DO \ number of instruments 		i -> current-instrument		#_strings 0 DO \ go through the four fundamentals for each instrument			current-instrument 4 * i + at: string-fundamentals			-> fundamental-pitch			#_harmonics 0 DO				fundamental-pitch i 1 + *  \ create new harmonic			LOOP			 current-instrument at: string-arrays			add: []		LOOP	LOOP;		\ go thru each instrument, pick one random note from each...: PICK.A.RANDOM.CHORD   { | curr-ins  curr-string curr-harm-# harm --  }	#_instruments 0	DO			i at: string-arrays -> curr-ins			#_strings choose -> curr-string 			#_harmonics choose -> curr-harm-#			curr-string curr-harm-# curr-ins ed.at: []			-> harm			harm i to: test-chord			curr-string i to: chord-string			curr-harm-# i to: chord-harm	LOOP;: GS.CHORD { | gs-sum -- }	0 -> gs-sum	#_instruments 1- 0 DO		#_instruments i 1+ DO			i at: test-chord			j at: test-chord			gs.ratio 			gs-sum + -> gs-sum		LOOP	LOOP	gs-sum #_instruments  to: test-chord	gs-sum ;	: TEST.ONE.CHORD	pick.a.random.chord		gs.chord	drop	print: test-chord print: chord-string print: chord-harm;		: PICK.A.RATIO { | curr-ins1 curr-ins2 harm1 harm2 -- harm1 harm2 }	#_instruments choose at: string-arrays -> curr-ins1	#_strings choose #_harmonics choose curr-ins1 ed.at: []	-> harm1\	cr curr-ins1 name: [] tab harm1 . cr	BEGIN			#_instruments choose at: string-arrays -> curr-ins2			curr-ins2 curr-ins1 = not			?terminal or	UNTIL	#_strings choose #_harmonics choose curr-ins2 ed.at: []	-> harm2\	curr-ins2 name: [] tab harm2 .	harm1 harm2;: FIND.A.GS	pick.a.ratio	gs.ratio;: GS.RANGE { | test-min test-max curr-gs -- }	1000 -> test-min	0     -> test-max	BEGIN		find.a.gs -> curr-gs		curr-gs  test-min <		IF			curr-gs -> test-min		THEN		curr-gs  test-max > 		IF			curr-gs -> test-max		THEN		." . " 	?terminal 	UNTIL	cr cr	tab ." Min is " test-min . cr	tab ." Max is " test-max . cr;	: GS.CHORD.RANGE {   | test-min test-max curr-gs number-picks -- }	0 -> number-picks	1000 -> test-min	0     -> test-max	BEGIN		pick.a.random.chord gs.chord -> curr-gs		\ statistics on which gs's exist		curr-gs  1- at: gs-hit-array 1+		 curr-gs 1- to: gs-hit-array		curr-gs  test-min <		IF			curr-gs -> test-min		THEN		curr-gs  test-max > 		IF			curr-gs -> test-max		THEN		\  ." . " 		number-picks 1+ -> number-picks		number-picks 1000 mod 0 = 		IF			number-picks .		THEN		number-picks 64000 > 	?terminal 	or	UNTIL	cr cr	tab ." Min is " test-min . cr	tab ." Max is " test-max . cr;\ aside from the different tuning, this is the only difference between the two versions...\ this one goes from consonance to dissonance...could have just left out the reverse the lists thing below...	: COMPUTE.TARGET.GS 	curr-chord-# @ gs_chord_range piece_length */	gs_chord_min +;		: STORE.SUCCESSFUL.CHORD	#_instruments 0 DO		i at: chord-string		curr-chord-# @ i ed.to: chord-string-list		i at: chord-harm		curr-chord-# @ i ed.to: chord-harm-list			i at: test-chord		curr-chord-# @ i ed.to: piece-chords	LOOP		;\ leave a flag if chord is right range of gs: IS.CHORD.SUCCESSFUL? { | curr-gs test-gs -- flag }		gs.chord -> curr-gs		curr-gs 		compute.target.gs 		- abs gs_chord_delta 2/ < 		IF			."     GOOD      "			store.successful.chord			curr-gs curr-chord-# @ #_instruments ed.to: piece-chords			true		ELSE			false		THEN;: REVERSE.THE.LISTS	0 piece_length 1- -1 reverse: piece-chords ." . "	0 piece_length 1- -1 reverse: chord-string-list ." . "	0 piece_length 1- -1 reverse: chord-harm-list ." . "	;\ fill the list...: PICK.PIECE.CHORDS { | attempt-counter start-time -- }	cr cr tab ." Computing Yitgadal chord sequence " cr cr	time@ -> start-time	0 average-attempts !	0 ->  attempt-counter	piece_length 0	DO		i curr-chord-# !		i .		BEGIN			average-attempts @ 1+ average-attempts !			attempt-counter 1+ -> attempt-counter			attempt-counter 100 mod			0=			IF				." . "			THEN			pick.a.random.chord				is.chord.successful?			?terminal or		UNTIL				LOOP	cr ." All chords picked " cr cr\ for yitgadal b, goes from consonant to dissonant... don't reverse the lists...\	cr ." reversing the lists " reverse.the.lists cr	time@ start-time - rtc.rate@ /	60 /	computation-time !;: PRINT.STATS	cr cr ." Yitgadal for string quartet " cr cr 	." stats " cr cr	cr cr ." date: 5/22/99 " cr cr		cr cr tab ." Hit range is " gs_chord_delta . cr cr 	computation-time @	cr cr cr tab ." Piece computation took " . ." minutes " cr	average-attempts @ piece_length / 	tab ." Average # of attempts was " . cr;v: temp-offset: PRINT.INSTRUMENT { curr-instrument | counter -- }	cr	0 -> counter	\ loop through sections...	5 0 DO		tab ." SECTION # " i 1+ . cr 		\ loop through section lengths		i at: section-array 0 DO			i 10 mod 0= IF cr THEN \ space after 10			counter curr-instrument 			ed.at: chord-string-list			tab 			\ this is a bit confusing, since the 0th string			\ is numbered musically as "IV"			CASE				0 of ." IV" endof				1 of ." III" endof				2 of ." II" endof				3 of ." I" endof			ENDCASE			backspace			counter curr-instrument 			ed.at: chord-harm-list			dup 0> 			IF 				1+			THEN			. space space			counter 1+ -> counter			\ counter . 		LOOP		cr cr	LOOP;: PRINT.INSTRUMENTS	#_instruments 0	DO		cr cr ." INSTRUMENT # " i . cr cr		i print.instrument		cr cr	LOOP;: DO.YITGADAL	pick.piece.chords;: PRINT.YITGADAL	cr ." Instrument 0 is cello, Instrument 3 is violin 1 " cr	cr ." (Note that lowest strings are numbered as 0 in the data, and "	cr ." converted to roman numerals in the print out) "	print.stats	print: piece-chords	print: chord-harm-list	print: chord-string-list	print.instruments;\ then print.stats, print.instruments