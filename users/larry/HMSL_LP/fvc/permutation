\ permutations of n elementsanew task-permutation: FACTORIAL  ( N -- N! )    1 swap 1+ 1 DO i * LOOP;ob.objlist permutation-listmethod put.#-of-elements:method get.#-of-elements:method get.list-length:method permute:method randomize.start::CLASS OB.PERMUTATION <super ob.shape	iv.short list-length	iv.short #-of-elements	:M PUT.#-OF-ELEMENTS:	iv=> #-of-elements;m:M GET.#-OF-ELEMENTS:	#-of-elements;m:M GET.LIST-LENGTH:	max.elements: self;M	:M NEW: { n -- }	n put.#-of-elements: self	n factorial #-of-elements new: super;m\ this takes a user defined permutation, and starts it at a random place\ this should be used by defining a new dummy permutation, which  will just be a copy\ of one of the created permutations in the list, but starting and ending at a different place:M RANDOMIZE.START: { | start-point -- }		many: permutation-list		get.#-of-elements: self <		IF			." ERROR: Permutation not yet created for that number of elements " cr		ELSE			max.elements: self 			1+ choose		 	-> start-point			max.elements: self start-point			DO				i 				get.#-of-elements: self 1- at: permutation-list				get: []				add: self			LOOP			start-point 0 DO				i 				get.#-of-elements: self 1- at: permutation-list				get: []				add: self			LOOP		THEN;m;classob.permutation test-perm\ The permuation algorithm used here is taken from Knuth vol. 1, page 45, 46\ It's an inductive algorithm: you go through the previous list, add a value\ to the end of each permutation, that moves up by 1 every time, ending up\ "between" successive values in the list, then add 1 to each value in\ the permutation that is greater than the new value, then "normalize"\ Instead of using 1/2, 3/2, etc. as Knuth does, I'm multiplying the whole\ permutation by 2 (only even numbers) then adding a successively bigger\ by 2 odd number as the last, doing the change,and then dividing all by two\ to get values from ...: BUILD.PERMUTATION-LIST { #-p -- }	#-p new: permutation-list	#-p 1+ 1 DO		instantiate ob.permutation		dup \ -- p p		i swap \ -- p i p		new: [] \ makes room in permutation		add: permutation-list	LOOP;: MAKE.PERMUTATIONS.1&2	\ make list, n=1, n=2	1 0 at: permutation-list add: []	1 2 1 at: permutation-list add: []	2 1 1 at: permutation-list add: [];: MULTIPLY.*.2 { #-p list#  -- , multiply the values by two, and leave them on the stack }			#-p at: permutation-list			dimension: [] 0 			DO					list# i					\ get the current element of the shorter list #-p times					#-p at: permutation-list					ed.at: [] 					2*			LOOP;\ according to Knuth algorithm, after the 1/2 values (in this case, odd)\ are inserted as the last element of each permutation, go through each\ permutation and if any element is bigger, add 1 to it (in this case 2),\ since they're all gonna be divided down...: GREATER.THAN.LAST.ELEMENT { #-p | curr-list --  }	cr	#-p at: permutation-list -> curr-list	curr-list many: []  0 	DO		curr-list dimension: [] 1- 0 		DO 			j i curr-list ed.at: [] 			j curr-list dimension: []  1- curr-list ed.at: []  			 			>			IF				j i  curr-list ed.at: []				2 + 				j i curr-list ed.to: []			THEN		LOOP	LOOP;\ This takes the form of the list given by greater.than.last.element\ and puts it into a form 0 - n-1, where n is the number of the permutation: MASSAGE.LIST { #-p | curr-list -- }	#-p at: permutation-list -> curr-list	curr-list many: [] 0	DO		curr-list dimension: [] 0		DO			j i curr-list ed.at: []			even-up 2/ 			j i curr-list ed.to: []		LOOP	LOOP;\ this algorithm takes the previous permutation, and puts in the new\ number in every available place: first, second, third, and so on...: MAKE.NEXT.PERMUTATION { #-p | l-length list# el# -- }	#-p 2- at: permutation-list \ this actually gets the previous list	get.list-length: [] 	-> l-length \ e.g if #-p is 4, this is should be 6	l-length 0 DO		i -> list# \ this is number in the previous list		#-p 0 DO			i -> el# \ el# is a number between 1 and current permutation value			#-p 2- list# 			multiply.*.2 \ #-p -1 values 			el# 2* 1+ \ now plop the "knuth" half value on the stack			#-p  1- at: permutation-list \ add this to new permutations list			add: []		LOOP	LOOP	#-p 1- greater.than.last.element	#-p 1- massage.list\	#-p 1- at: permutation-list print: [];					: MAKE.PERMUTATIONS { #-p -- }	#-p 3 < not 	IF		#-p build.permutation-list		make.permutations.1&2		#-p 1+ 3 		DO		i  make.next.permutation	LOOP\	#-p 1- at: permutation-list print: []	ELSE		." Cannot generate permutations for 1 and 2, that is done automatically... "	THEN;: PERMUTATIONS.TERM	freeall: permutation-list	free: permutation-list;: TEST.RANDOMIZE	4 new: test-perm	randomize.start: test-perm;if.forgotten permutations.term		