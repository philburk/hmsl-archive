\ PLAYERS for FVC#8anew task-fvc#8_playersOB.OBJLIST F8-PLAYER-LIST\ this array is used to store the total sums of the durations of each player/voiceOB.ELMNTS F8-DURATION-SUMS: F8.DURATION.CALC { el-value -- new-duration }	f8-pulse @	el-value ( number between 1-5 )	1 - ( 0-4 )	0 	DO		float golden_mean f* f>i	LOOP;: F8.VOICE.DURATION.SCALE { duration v-# -- new-duration }	duration 	v-# ( 0-5 )	0 	DO		float golden_mean f/ f>i	LOOP;\ The duration for a given element is the golden mean * the next lower duration value\ * the golden mean * the next lower voice-# vaue\ * the pulse of the piece (the overall tempo is set as a constant)\ In other words, there are 5 golden mean related values for each voice, and each\ voice's values are one golden mean away from the previous voice. there are four duration\ values in common between successive voices: F8-DURATION-FUNCTION { element# shape | v-# -- }	self get.instrument: []	get.voice#: []	-> v-#	element# duration-start + many: f8-element-list mod	0 shape ed.at: []	f8.duration.calc ( -- duration, adjusted for value in permuation list )	v-#	f8.voice.duration.scale;: INIT.F8-PLAYERS { f8-player -- }	1 f8-player new: []		'c f8-duration-function f8-player put.dur.function: []	f8-element-list f8-player add: []	f8-player play.on&off: []	f8-player use.relative.time: [];: TICKS->TIME ( ticks -- minutes seconds )	rtc.rate@ / 	60 /mod ;\ this gives duration of one element in the list, for each voice: F8.SUM.ELEMENT.DURATION { v-# | #-ticks -- sum of one element }	0	#_elements 1+ 1 ( takes number between 1-5) 	DO		i f8.duration.calc		v-# f8.voice.duration.scale		+	LOOP	-> #-ticks	 ." One permutation in VOICE " v-# . ." takes "  	#-ticks dup . ." ticks " cr;\ this gives total duration in ticks of each voice: F8.SUM.VOICE.DURATION { v-# -- }	v-# f8.sum.element.duration	#_elements factorial * \ length of list * sum of each list element;: F8.COMPUTE.START.DELAYS { | start-delay -- }	0 0 at: f8-player-list put.start.delay: []	#_voices 1	DO			0 at: f8-duration-sums		i at: f8-duration-sums		- -> start-delay		start-delay i at: f8-player-list put.start.delay: []	LOOP;: F8.COMPUTE.PIECE.LENGTH	0 at: f8-duration-sums 	ticks->time	cr ." Piece is " . ." minutes and " . ." seconds long " cr;: INIT.F8-PLAYER-LIST { | f8-player -- }	#_voices new: f8-player-list	#_voices 1 new: f8-duration-sums	#_voices 0 DO			instantiate ob.player			-> f8-player			f8-player add: f8-player-list			i f8-player put.data: [] \ this just tells you where it is in the list			i at: f8.instrument-list f8-player put.instrument: []	LOOP	'c init.f8-players do: f8-player-list	#_voices 0 	DO		i f8.sum.voice.duration 		add: f8-duration-sums	LOOP	print: f8-duration-sums	f8.compute.start.delays	cr	." Start delays for the players (voices) are: " cr	tab ." Ticks " tab tab ." M/S " cr	#_voices 0 	DO		i at: f8-player-list		get.start.delay: [] dup		tab . 		tab tab ticks->time . ." / " .		cr	LOOP	cr	f8.compute.piece.length	;: TERM.F8-PLAYER-LIST	freeall: f8-player-list	free: f8-player-list	free: f8-duration-sums;		