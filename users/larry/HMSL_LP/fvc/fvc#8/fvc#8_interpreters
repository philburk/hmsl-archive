\ FVC#8 Interpretersanew task-fvc#8_interpretersob.objlist f8.instrument-listv: prev-channel ( this is the last channel a note was on, for off interpeter )v: prev-pitch ( this is the last pitch played by that instrument )method get.voice#:method put.voice#::CLASS OB.F8.INSTRUMENT <super ob.midi.instrument	iv.short voice-#	:M GET.VOICE#:	voice-#;m:M PUT.VOICE#:	iv=> voice-#;M;class\ the following is the "sub" pitch selection algorithm. once the range is selected,\ the randomly chosen value within that range is "rounded" to one of the two pitches\ allowed for that voice. These voices\ are just selected as a tritone apart\ for each voice. This is a really brute force algorithm, and fairly slow...\ a and b are moduli for the given voice: MOD.A.OR.B? { new-val a b | closer-mod new-val-mod -- new-val  }	new-val 6 mod -> new-val-mod	new-val-mod a =	new-val-mod b =	or	IF		new-val	ELSE		\ if it's not equal, which is it closer to		new-val-mod a - abs  ( -- a-diff )		new-val-mod b - abs  ( -- a-diff b-diff )		<		IF a ELSE b THEN		-> closer-mod		new-val new-val-mod closer-mod - -	THEN;	: F8.INTERPRET.PITCH { element# shape instrument | new-pitch-range new-lo-pitch -- }	pitch_range element# 	8 / -	-> new-pitch-range ( -- ) \ first calculate shrunk pitch range\ now get new low adjusted pitch	pitch_range new-pitch-range - \ difference	2/ lo_pitch + -> new-lo-pitch	element# 	pitch-start + many: f8-element-list mod	0 shape ed.at: [] ( --  1-5 )	1- ( put elements in proper range ) 	new-pitch-range 5 / ( --  0-4 1/5*range )  	* ( --  value*1/5range, or lo value ) 	new-lo-pitch + ( -- new lo value )	dup new-pitch-range 5 / +	swap wchoose ( -- non-adjusted pitch )\	dup .	instrument get.voice#: [] \ this will determine the low modulus	dup 6 + 	mod.a.or.b?\	dup .	dup prev-pitch !	( -- pitch )	\ cr dup ." Pitch" .;: F8.INTERPRET.BEND { element# shape instrument -- }	$ 2000 #_voices / ( 2000/6 )	instrument get.voice#: [] ( 2000/6 0-5 )	 * \ starting value, in other words, each voice starts out higher	$ 2000 #_voices /	instrument get.voice#: [] 1+	*	swap wchoose	midi.pitch.bend;: F8.INTERPRET.CHANNEL { element# shape instrument -- }	element# 	150 / ( which row: 0-3 )	4 * ( starting value for each row )	element# 	channel-start + many: f8-element-list mod	0 shape ed.at: [] ( --  1-5 )	1-	dup 4 = ( 4 is the wild card, could be anywhere in space	IF		16 choose 1+ 		dup prev-channel ! 		midi.channel!		2drop	ELSE		+ 16 swap -\ this next wass a kluge because of a lot of noise on the synclavier \ channel 1... in fact the "front" of the piece is only 3 channels.\ Removed, 9/1/92, now uses all 16 channels again\		dup 1 =\		IF\			drop 5 2 wchoose \		THEN	dup prev-channel !	midi.channel!	THEN\	midi-channel @ ." channel " . ;\ lo value goes from 58 t0 88 over the course of the piece\ velocity range is restricted to 30, so that pcm-70's and mixer can do most\ of the spatialization: F8.INTERPRET.VELOCITY { element# shape instrument | lo-value hi-value --  vel }\ first find new lowest velocity value: 10 + creeping inc + division by 5*element value	element# ( -- 0-end-of-list )	velocity-start + ( -- rand-value+el# )	many: f8-element-list mod ( -- 0+el# wrap-around-list )	0 shape ed.at: [] ( --  1-5 )	1- ( put elements in proper range ) 	velocity_range 5 / ( --  0-4 1/5*range )  	* ( -- 0, 6, 12, 18, 24   ) 	element# 20 / ( -- 0-24 0-6 )	+ ( -- 0-30 )	velocity_offset + ( -- 58-88 ) \ computes kind of creeping offset up	-> lo-value\ now find high value	lo-value velocity_range + 	0 128 clipto	-> hi-value	hi-value lo-value \	2dup . .	wchoose 	( -- vel )\	dup . cr ; 	: F8.INTERPRET.CONTROL { element# shape instrument | control-range el-value -- }	\ divide increasing control range by 5 and pick a control value	element# 5 / ( brings it down to 0-120 )	-> control-range ( starts at 0, goes to full length )	element# control-start + many: f8-element-list mod	0 shape ed.at: [] ( --  1-5 )	1- ( put elements in proper range ) 	-> el-value	control-range 5 / el-value * \ lower point of range	dup control-range 5 / + swap	wchoose 	\ dup ." control " .	f8_control# swap midi.control	;: F8.INTERPRET.ON { element# shape instrument --  }	element# shape instrument f8.interpret.channel	element# shape instrument f8.interpret.pitch	element# shape instrument f8.interpret.velocity	midi.noteon	element# shape instrument f8.interpret.bend\	element# shape instrument f8.interpret.control;: F8.INTERPRET.OFF { element# shape instrument --  }	prev-channel @ midi.channel!	prev-pitch @ 0 midi.noteoff;: INIT.F8.INSTRUMENT-LIST { | instrument -- }	#_voices new: f8.instrument-list	#_voices 0 	DO				instantiate ob.f8.instrument				-> instrument				instrument add: f8.instrument-list				i instrument put.voice#: []				'c f8.interpret.on instrument put.on.function: []				'c f8.interpret.off instrument put.off.function: []	LOOP;: INIT.F8-INSTRUMENTS	init.f8.instrument-list;: TERM.F8-INSTRUMENTS	freeall: f8.instrument-list	free: f8.instrument-list;