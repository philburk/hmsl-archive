\ Mutations for tuba piece\ 3/6/92\ author lpANEW TASK-TUBA_MUTATIONS1010 k: .kluge\ *********** PITCHES ***************: ISEVEN? ( n -- flag, depending on whether even or not )	dup even-up = ;\ tuba 1 uses uoh: for pitches...\ TUBA I: MUTATE.TUBA.1.PITCH { | mutant  -- }		cr ." Mutating TUBA 1 pitches " cr		#-of-mutations 1+		1 DO			i  at: tuba-mutant-list-1-1			-> mutant			.kluge  #-of-mutations / i * 			\ 1071 kluge to make it come out even			0 1000 clipto 			mutant put.: []			1 mutant put.curr-dim: []			mutant uoh: []\			i  at: tuba-mutant-list-1-2 			-> mutant			.kluge  #-of-mutations  / i * 			.kluge #-of-mutations 2* / +			\ 1071 kluge to make it come out even			0 1000 clipto 			mutant put.: []			1 mutant put.curr-dim: []			mutant uoh: []		LOOP;\ TUBA 2 (pitches): MUTATE.TUBA.2.PITCH { |  mutant  -- }		cr ." Mutating TUBA 2 Pitches " cr	#-of-mutations 1+		1 DO			i  at: tuba-mutant-list-2-1			-> mutant			.kluge  #-of-mutations / i * 			dup .			\ 1071 kluge to make it come out even			0 1000 clipto 			mutant put.: []			1 mutant put.curr-dim: []			mutant uoh: []			\ 1 mutant ph: [] cr			i  at: tuba-mutant-list-2-2 			-> mutant			.kluge  #-of-mutations  / i * 			.kluge #-of-mutations 2* / +			dup .			\ 1071 kluge to make it come out even			0 1000 clipto 			mutant put.: []			1 mutant put.curr-dim: []			mutant uoh: []			\ 1 mutant ph: [] cr		LOOP;: MUTATE.TUBA.PITCHES	mutate.tuba.1.pitch 	mutate.tuba.2.pitch ;\ ******************************************\ DURATIONS\ tuba 1 uses isim: for durations...: MUTATE.TUBA.1.RHYTHM { | list  mutant  -- }	cr ." Mutating TUBA 1 Durations " cr	#-of-mutations 1+		1 DO			i  at: tuba-mutant-list-1-1			-> mutant			.kluge  #-of-mutations / i * 			dup .			\ .kluge kluge to make it come out even			0 1000 clipto 			mutant put.: []			0 mutant put.curr-dim: []			mutant isim: []			\ 1 mutant ph: [] cr			i  at: tuba-mutant-list-1-2 			-> mutant			1010 #-of-mutations  / i * 			1010 #-of-mutations 2* / +			\ 1071 kluge to make it come out even			0 1000 clipto 			mutant put.: []			0 mutant put.curr-dim: []			mutant isim: []			\ 0 mutant ph: [] cr		LOOP;	: MUTATE.TUBA.2.RHYTHM { | list  mutant  -- }	cr ." Mutating TUBA 2 Durations " cr	#-of-mutations 1+		1 DO			i  at: tuba-mutant-list-2-1			-> mutant			.kluge  #-of-mutations / i * 			\ .kluge kluge to make it come out even			0 1000 clipto 			mutant put.: []			0 mutant put.curr-dim: []			mutant isim: []			\ 1 mutant ph: [] cr			i  at: tuba-mutant-list-2-2 			-> mutant			.kluge  #-of-mutations  / i * 			.kluge #-of-mutations 2* / +			\ .kluge kluge to make it come out even			0 1000 clipto 			mutant put.: []			0 mutant put.curr-dim: []			mutant isim: []			\ 0 mutant ph: [] cr		LOOP;: TUBA-MUTANTS.RHYTHM.INIT { mutant -- }	0 mutant put.curr-dim: []	mutant use.fund-value: []	0 0 mutant put.fund-value: []	0 mutant put.: []	mutant zero-override?.on: [];: MUTATE.TUBA-RHYTHMS	0 put.curr-dim: tuba-1-source-1	0 put.curr-dim: tuba-1-target-1	0 put.curr-dim: tuba-1-source-2	0 put.curr-dim: tuba-1-target-2	0 put.curr-dim: tuba-2-source-1	0 put.curr-dim: tuba-2-target-1	0 put.curr-dim: tuba-2-source-2	0 put.curr-dim: tuba-2-target-2	'c tuba-mutants.rhythm.init do: tuba-mutant-list-1-1	'c tuba-mutants.rhythm.init do: tuba-mutant-list-1-2	'c tuba-mutants.rhythm.init do: tuba-mutant-list-2-1	'c tuba-mutants.rhythm.init do: tuba-mutant-list-2-2	mutate.tuba.1.rhythm	mutate.tuba.2.rhythm;\ some simple post-processing for the mutants, to clean them up a bit for FINALE\ put 5/8's note rest as the first beat of each mutant in tuba-1: ADD.A.REST-1 { mutant -- }	2560 0 0 0 	0 mutant insert: [];: ADD.A.REST-2 add.measure.beginning ;	\ each measure = 6*beat-lengthbeat-length, or measure-length FINALE ticks\ #-of-measures is stored in data for mutant: SQUARE.LAST.MEASURE { list-1 list-2 | mutant temp-sum #-complete ticks-left -- }	." squaring last measures: " 	list-1 many: [] 0 DO 			i list-1  get: [] \ first of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []			-> temp-sum			i  list-2 get: [] \ second of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []		 	temp-sum + -> temp-sum \ sum of mutant pairs....			temp-sum measure-length /mod ( -- rem #-measures )			-> #-complete -> ticks-left		ticks-left 0=		\ if there's no remainder, the number of measures is simply stored		IF			#-complete  mutant put.data: []		ELSE		\ we're gonna add one measure by filling in with rests			#-complete 1+ mutant put.data: []			measure-length ticks-left - \ duration of rest to add....			0 0 0 mutant add: []		THEN	LOOP;: EQUALIZE.1&2 { | l-1.2 l-2.2 -- }	cr ." Making numbers of measures equal 1.2, 2.2 " cr	many: tuba-mutant-list-1-1	0 DO		i at: tuba-mutant-list-1-2		get.data: [] -> l-1.2 \ retrieve number of measures...		i at: tuba-mutant-list-2-2		get.data: [] -> l-2.2		l-1.2 l-2.2 		= not \ if they're not equal need to add some measures to the smaller		IF			l-2.2 l-1.2 > 			IF ( 1.2 is smaller .... )				l-1.2 l-2.2 - abs				( -- #-different )				measure-length * 0 64 0 				i  at: tuba-mutant-list-1-2				add: []			ELSE				l-1.2 l-2.2 - abs				measure-length  * 0 0 0  				i at: tuba-mutant-list-2-2				add: []			THEN		THEN	LOOP;: PROCESS.DURATIONS	." adding first beat rests " cr	'c add.a.rest-1 do: tuba-mutant-list-1-1	'c add.a.rest-2 do: tuba-mutant-list-2-1	." processing on-times " cr	'c reset.on-times do: tuba-mutant-list-1-1	'c reset.on-times do: tuba-mutant-list-2-1	'c reset.on-times do: tuba-mutant-list-1-2	'c reset.on-times do: tuba-mutant-list-2-2	." squaring off last measures " cr	tuba-mutant-list-1-1 tuba-mutant-list-1-2 square.last.measure	tuba-mutant-list-2-1 tuba-mutant-list-2-2 square.last.measure	equalize.1&2;		: CHECK.DURATIONS.EQUAL { | mutant temp-sum-1 temp-sum-2 -- }	cr	many: tuba-mutant-list-1-1	 0 DO		i ." index = " . cr		\ calculate sum of first list...			i  at: tuba-mutant-list-1-1 \ first of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []			-> temp-sum-1			tab ." m-1-1: " temp-sum-1 .			i  at: tuba-mutant-list-1-2 \ second of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []			." m-1-2: " dup .		 	temp-sum-1 + -> temp-sum-1 \ sum of mutant pairs....			." sum-1: " temp-sum-1 . cr		\ calculate sum of second list...			i tuba-mutant-list-2-1  get: [] \ first of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []			-> temp-sum-2			tab ." m-2-1: " temp-sum-2 .			i at: tuba-mutant-list-2-2 \ second of mutant pair			-> mutant			0 mutant calc.dim.stats: []			0 mutant get.dim.sum: []			." m-2-2: " dup .		 	temp-sum-2 + -> temp-sum-2 \ sum of mutant pairs....			." sum-2: " temp-sum-2 . cr			temp-sum-1 temp-sum-2 = 				IF ." Index = " i . ." sums are equal "  cr				ELSE	." Index = " i . ." sums are not equal " cr					tab temp-sum-1 . temp-sum-2 . cr					tab temp-sum-1 measure-length /mod . . 					temp-sum-2 measure-length /mod . . cr				THEN		2 +LOOP		;: CHECK.ALL-SHAPES.EQUAL	0 calc.dim.stats: all-shapes-1	0 get.dim.sum: all-shapes-1	dup ." All-shapes-1: " . cr	0 calc.dim.stats: all-shapes-2	0 get.dim.sum: all-shapes-2	dup ." All-shapes-2: " . cr	= IF ." They're equal " cr ELSE ." Not equal " cr THEN;\ simple ways to inspect a mutant: SEE.1-1 ( mutant-# -- )	1 see: tuba-mutant-list-1-1;: SEE.1-2 ( mutant-# -- )	1 see: tuba-mutant-list-1-2;: SEE.2-1	1 see: tuba-mutant-list-2-1;: SEE.2-2	1 see: tuba-mutant-list-2-2;: SEE.SOURCE-1-1	1 print.horizontal: tuba-1-source-1;: SEE.SOURCE-1-2	1 print.horizontal: tuba-1-source-2;: SEE.TARGET-1-1	1 print.horizontal: tuba-1-target-1;: SEE.TARGET-1-2	1 print.horizontal: tuba-1-target-2;: SEE.SOURCE-2-1	1 print.horizontal: tuba-2-source-1;: SEE.SOURCE-2-2	1 print.horizontal: tuba-2-source-2;: SEE.TARGET-2-1	1 print.horizontal: tuba-2-target-1;: SEE.TARGET-2-2	1 print.horizontal: tuba-2-target-2;: SEE.1.1.R ( mutant-# -- )	0 see: tuba-mutant-list-1-1;: SEE.1.2.R	0 see: tuba-mutant-list-1-2;: SEE.2.1.R ( mutant-# -- )	0 see: tuba-mutant-list-2-1;: SEE.2.2.R	0 see: tuba-mutant-list-2-2;: SEE.SOURCE.R.1.1	0 print.horizontal: tuba-1-source-1;: SEE.TARGET.R.1.1	0 print.horizontal: tuba-1-target-1;: SEE.SOURCE.R.1.2	0 print.horizontal: tuba-1-source-2;: SEE.TARGET.R.1.2	0 print.horizontal: tuba-1-target-2;: CHECK.1.1.LOW	12 1 index<: tuba-mutant-list-1-1;	: CHECK.1.2.LOW	12 1 index<: tuba-mutant-list-1-2;: CHECK.2.1.LOW	12 1 index<: tuba-mutant-list-2-1;	: CHECK.2.2.LOW	12 1 index<: tuba-mutant-list-2-2;: CHECK.1.1.HI	66 1 index>: tuba-mutant-list-1-1;	: CHECK.1.2.HI	66 1 index>: tuba-mutant-list-1-2;: CHECK.2.1.HI	66 1 index>: tuba-mutant-list-2-1;	: CHECK.2.2.HI	66 1 index>: tuba-mutant-list-2-2;: CHECK.LISTS	." checking 1.1 " cr check.1.1.hi 	." checking 1.2 " cr check.1.2.hi	." checking 2.1 " cr check.2.1.hi	." checking 2.2 " cr check.2.2.hi	." checking 1.1 lo " cr check.1.1.low	." checking 1.2 lo " cr check.1.2.low	." checking 2.1 lo " cr check.2.1.low	." checking 2.2 lo " cr check.2.2.low;: DO.TUBA-MUTATIONS	cr ." Pitches " cr cr	mutate.tuba.pitches	cr cr ." Rhythms " cr cr 	mutate.tuba-rhythms;\ this just allows me to hear them quicker, since FINALE's #-of-ticks per\ 1/4 note is so high, HMSL's clock can't quite go that fast!!!!!: SCALE.TUBA.PLAYER.DURATIONS { el# sh -- duration }	el# 0 sh ed.at: []	2/ ;: TUBA.PLAYERS.INIT	1 new: tuba-mutant-player-1	1 new: tuba-mutant-player-2\ this following is done to the shapes themselves...	36 put.offset: ins-midi-1	36 put.offset: ins-midi-2	ins-midi-1 put.instrument: tuba-mutant-player-1	ins-midi-2 put.instrument: tuba-mutant-player-2\		all-shapes-1 add: tuba-mutant-player-1	-1 put.on.dim: tuba-mutant-player-1		use.relative.time: tuba-mutant-player-1\	all-shapes-2 add: tuba-mutant-player-2	-1 put.on.dim: tuba-mutant-player-2	use.relative.time: tuba-mutant-player-2	'c scale.tuba.player.durations put.dur.function: tuba-mutant-player-1	'c scale.tuba.player.durations put.dur.function: tuba-mutant-player-2;: INIT.ALL.SHAPES { | mutant-1 mutant-2 -- }	50 50 * 4 new: all-shapes-1	50 50 * 4 new: all-shapes-2	many: tuba-mutant-list-1-1 	0 DO		." . "		i get: tuba-mutant-list-1-1		-> mutant-1		i get: tuba-mutant-list-1-2		-> mutant-2		mutant-1 many: [] 0 		DO			i mutant-1 get: []			add: all-shapes-1		LOOP		mutant-2 many: [] 0 		DO			i mutant-2 get: []			add: all-shapes-1		LOOP	LOOP	many: tuba-mutant-list-2-1 	0 DO		." . "		i get: tuba-mutant-list-2-1		-> mutant-1		i get: tuba-mutant-list-2-2		-> mutant-2		mutant-1 many: [] 0 		DO			i mutant-1 get: []			add: all-shapes-2		LOOP		mutant-2 many: [] 0 		DO			i mutant-2 get: []			add: all-shapes-2		LOOP	LOOP;			: TUBA->MIDI	" tuba:tuba_1_midi" $midifile0{ 	tuba-mutant-player-1 hmsl.play	}midifile0	" tuba:tuba_2_midi" $midifile0{ 	tuba-mutant-player-2 hmsl.play	}midifile0;: INIT.C-TUBA	2 new: c-tuba	act.parallel: c-tuba	tuba-mutant-player-1 add: c-tuba	tuba-mutant-player-2 add: c-tuba;: DO.TUBA	tuba.players.init ." Init'ing players " cr 	do.tuba-mutations 	cr cr ." Post processing of durations " cr 	process.durations 	." Filling all shapes now "	init.all.shapes 	init.c-tuba\	TUBA->midi;false .ifall-shapes-2 save.rel.shape tuba:as2:mfall-shapes-1 save.rel.shape tuba:as1.mf.then