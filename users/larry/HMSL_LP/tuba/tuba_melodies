\ tuba melodies\ 3/7/92anew task-tuba_melodies\ these are in general, good procedures to use in following pieces\ finale uses 512 ticks per eigth note, in a 6/8 measure that makes\ 3072 ticks per measure...17 -> #-of-mutations3072 -> measure-length512 -> beat-lengthob.shape all-shapes-1ob.shape all-shapes-2ob.collection c-tubaob.mutant-harmonic-et tuba-1-source-1ob.mutant-harmonic-et tuba-1-target-1ob.mutant-harmonic-et tuba-1-source-2ob.mutant-harmonic-et tuba-1-target-2\ob.mutant-harmonic-et tuba-2-source-1ob.mutant-harmonic-et tuba-2-target-1ob.mutant-harmonic-et tuba-2-source-2ob.mutant-harmonic-et tuba-2-target-2\ob.mutantlist tuba-mutant-list-1-1ob.mutantlist tuba-mutant-list-2-1ob.mutantlist tuba-mutant-list-1-2ob.mutantlist tuba-mutant-list-2-2\ob.player tuba-mutant-player-1ob.player tuba-mutant-player-2false .if: READ.MF  ( -- , read a midifile into a shape )	0 " hmf:simple.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape sh1 sh.compress.notes     \ convert to compressed;: PLAY.MF  ( -- , play the shape read from MIDIFile )	sh1 ins1 build: pl1	0 put.offset: ins1     \ 0 offset because stored as MIDI notes	use.absolute.time: pl1 \ absolute not relative time	3 put.on.dim: pl1      \ use ontimes of compressed notes	pl1 hmsl.play;.thenscore{1000 rtc.rate!: SETUP.TEMPO  ( -- , for proper note durations )	3 ticks/beat @ * tpw!;\ ************\ SETUP TUBA 1: TUBA-1-SOURCE-1.INIT ( -- )	40 4 new: tuba-1-source-1\ read in the midifile	1 " tuba:t.source.1.1.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-1-source-1 sh.compress.notes     \ convert to compressed absolute\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-1-source-1	nip nip	+	0 0 ed.at: tuba-1-source-1 + \ this should not be necessary....	0 differentiate: tuba-1-source-1\ accent first note of melody	90 0 2 ed.to: tuba-1-source-1	beat-length 0 0 ed.to: tuba-1-source-1 \ FINALE screws up the first duration, fix it...	1 TUBA-1-SOURCE-1 put.curr-dim: []	TUBA-1-SOURCE-1 use.fund-value: []	51 1 TUBA-1-SOURCE-1 put.fund-value: []	0 0 TUBA-1-SOURCE-1 put.fund-value: []	0 TUBA-1-SOURCE-1 put.: []	TUBA-1-SOURCE-1 zero-override?.on: [];: TUBA-1-SOURCE-2.INIT ( -- )	40 4 new: tuba-1-source-2\ read in the midifile	1 " tuba:t.source.1.2.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-1-source-2 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-1-source-2	nip nip	+	0 0 ed.at: tuba-1-source-2 + \ this should not be necessary....	0 differentiate: tuba-1-source-2\ now fix last beat, so that it is actually two measures long\ one full measure is 3072 finale ticks; on-time is already ok	measure-length 2* many: tuba-1-source-2 1- 0 ed.to: tuba-1-source-2\ accent first note of melody	90 0 2 ed.to: tuba-1-source-2	1 TUBA-1-SOURCE-2 put.curr-dim: []	TUBA-1-SOURCE-2 use.fund-value: []	51 1 TUBA-1-SOURCE-2 put.fund-value: []	0 0 TUBA-1-SOURCE-2 put.fund-value: []	0 TUBA-1-SOURCE-2 put.: []	TUBA-1-SOURCE-2 zero-override?.on: [];: TUBA-1-TARGET-1.INIT ( -- )	40 4 new: tuba-1-target-1\ read in the midifile	1 " tuba:t.target.1.1.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-1-target-1 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-1-target-1	nip nip	+	0 0 ed.at: tuba-1-target-1 + \ this should not be necessary....	0 differentiate: tuba-1-target-1\	90 0 2 ed.to: tuba-1-target-1	beat-length 0 0 ed.to: tuba-1-target-1\ need to fix the last duration of the incoming MIDIFile, FINALE only gets\ the on-time because nothing comes after it....	beat-length 3 * ( put in a dotted quarter )	many: tuba-1-target-1 1- ( el# )	0 ed.to: tuba-1-target-1	1 tuba-1-target-1 put.curr-dim: []	tuba-1-target-1 use.fund-value: []	51 1 tuba-1-target-1 put.fund-value: []	0 0 tuba-1-target-1 put.fund-value: []	0 tuba-1-target-1 put.: []	tuba-1-target-1 zero-override?.on: [];: TUBA-1-TARGET-2.INIT ( -- )	40 4 new: tuba-1-target-2\ read in the midifile	1 " tuba:t.target.1.2.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-1-target-2 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-1-target-2	nip nip	+	0 0 ed.at: tuba-1-target-2 + \ this should not be necessary....	0 differentiate: tuba-1-target-2	90 0 2 ed.to: tuba-1-target-2	\ need to fix the last duration of the incoming MIDIFile, FINALE only gets\ the on-time because nothing comes after it....	beat-length 3 * ( put in a dotted quarter )	many: tuba-1-target-2 1- ( el# )	0 ed.to: tuba-1-target-2\ 	1 tuba-1-target-2 put.curr-dim: []	tuba-1-target-2 use.fund-value: []	51 1 tuba-1-target-2 put.fund-value: []	0 0 tuba-1-target-2 put.fund-value: []	0 tuba-1-target-2 put.: []	tuba-1-target-2 zero-override?.on: [];\ ************\ SETUP TUBA 2: TUBA-2-SOURCE-1.INIT ( -- )	40 4 new: tuba-2-source-1\ read in the midifile	1 " tuba:t.source.2.1.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-2-source-1 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-2-source-1	nip nip	+	0 0 ed.at: tuba-2-source-1 + \ this should not be necessary....	0 differentiate: tuba-2-source-1\ accent first note of melody	90 0 2 ed.to: tuba-2-source-1	1 tuba-2-source-1 put.curr-dim: []	tuba-2-source-1 use.fund-value: []	51 1 tuba-2-source-1 put.fund-value: []	0 0 tuba-2-source-1 put.fund-value: []	0 tuba-2-source-1 put.: []	tuba-2-source-1 zero-override?.on: [];: TUBA-2-SOURCE-2.INIT ( -- )	40 4 new: tuba-2-source-2\ read in the midifile	1 " tuba:t.source.2.2.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-2-source-2 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-2-source-2	nip nip	+	0 0 ed.at: tuba-2-source-2 + \ this should not be necessary....	0 differentiate: tuba-2-source-2\ now fix last beat, so that it is actually two measures long\ one full measure is measure-length finale ticks; on-time is already ok	measure-length  many: tuba-2-source-2 1- 0 ed.to: tuba-1-source-2\ accent first note of melody	90 0 2 ed.to: tuba-2-source-2	1 tuba-2-source-2 put.curr-dim: []	tuba-2-source-2 use.fund-value: []	51 1 tuba-2-source-2 put.fund-value: []	0 0 tuba-2-source-2 put.fund-value: []	0 tuba-2-source-2 put.: []	tuba-2-source-2 zero-override?.on: [];: TUBA-2-TARGET-1.INIT ( -- )	40 4 new: tuba-2-target-1\ read in the midifile	1 " tuba:t.target.2.1.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-2-target-1 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-2-target-1	nip nip	+	0 0 ed.at: tuba-2-target-1 + \ this should not be necessary....	0 differentiate: tuba-2-target-1	90 0 2 ed.to: tuba-2-target-1\ need to fix the last duration of the incoming MIDIFile, FINALE only gets\ the on-time because nothing comes after it....	beat-length 3 * ( put in a dotted quarter )	many: tuba-2-target-1 1- ( el# )	0 ed.to: tuba-2-target-1\	1 tuba-2-target-1 put.curr-dim: []	tuba-2-target-1 use.fund-value: []	51 1 tuba-2-target-1 put.fund-value: []	0 0 tuba-2-target-1 put.fund-value: []	0 tuba-2-target-1 put.: []	tuba-2-target-1 zero-override?.on: [];: TUBA-2-TARGET-2.INIT ( -- )	40 4 new: tuba-2-target-2\ read in the midifile	1 " tuba:t.target.2.2.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape tuba-2-target-2 sh.compress.notes     \ convert to compressed\ now differentiate, so that we are working on durations and on-times.... not absolute times...	last: tuba-2-target-2	nip nip	+	0 0 ed.at: tuba-2-target-2 + \ this should not be necessary....	0 differentiate: tuba-2-target-2	90 0 2 ed.to: tuba-2-target-2\ need to fix the last duration of the incoming MIDIFile, FINALE only gets\ the on-time because nothing comes after it....	beat-length 3 * ( put in a dotted quarter )	many: tuba-2-target-2 1- ( el# )	0 ed.to: tuba-2-target-2\	1 tuba-2-target-2 put.curr-dim: []	tuba-2-target-2 use.fund-value: []	51 1 tuba-2-target-2 put.fund-value: []	0 0 tuba-2-target-2 put.fund-value: []	0 tuba-2-target-2 put.: []	tuba-2-target-2 zero-override?.on: [];: (INIT.TUBA.MUTANTS) { mutant -- }	1 mutant put.curr-dim: []	mutant use.fund-value: []	51 1 mutant put.fund-value: []	0 0 mutant put.fund-value: []	0 mutant put.: []	mutant zero-override?.on: [];	: TUBA-MUTANTS.1.1.INIT { mutant -- }	mutant clone: tuba-1-source-1	tuba-1-source-1 mutant put.source-shape: []	tuba-1-target-1 mutant put.target-shape: []	mutant (INIT.TUBA.MUTANTS);: TUBA-MUTANTS.1.2.INIT { mutant -- }	mutant clone: tuba-1-source-2	tuba-1-source-2 mutant put.source-shape: []	tuba-1-target-2 mutant put.target-shape: []	mutant (INIT.TUBA.MUTANTS);: TUBA-MUTANTS.2.1.INIT { mutant -- }	mutant clone: tuba-2-source-1	tuba-2-source-1  mutant put.source-shape: []	tuba-2-target-1 mutant put.target-shape: []	mutant (INIT.TUBA.MUTANTS);: TUBA-MUTANTS.2.2.INIT { mutant -- }	mutant clone: tuba-2-source-2	tuba-2-source-2  mutant put.source-shape: []	tuba-2-target-2 mutant put.target-shape: []		mutant (INIT.TUBA.MUTANTS);: TUBA-MUTANT-LISTS.FILL { | mutant -- }\ first fill the two lists...	." newing the mutant lists .... " cr	#-of-mutations  2 + new: tuba-mutant-list-1-1	#-of-mutations  2 + new: tuba-mutant-list-1-2	#-of-mutations  2 + new: tuba-mutant-list-2-1	#-of-mutations  2 + new: tuba-mutant-list-2-2		#-of-mutations 0 DO		instantiate ob.mutant-harmonic-et		-> mutant		45 4 mutant new: [] 		mutant add: tuba-mutant-list-1-1		instantiate ob.mutant-harmonic-et		-> mutant		45 4 mutant new: [] 		mutant add: tuba-mutant-list-1-2		instantiate ob.mutant-harmonic-et		-> mutant		45 4 mutant new: [] 		mutant add: tuba-mutant-list-2-1		instantiate ob.mutant-harmonic-et		-> mutant		45 4 mutant new: [] 		mutant add: tuba-mutant-list-2-2	LOOP;: TUBA.SHAPES.INIT	." Initing shapes and reading in MIDIFiles " cr	tuba-1-source-1.init 	tuba-1-source-2.init 	tuba-1-target-1.init 	tuba-1-target-2.init 	tuba-2-source-1.init 	tuba-2-source-2.init 	tuba-2-target-1.init 	tuba-2-target-2.init ;\ now initialize each mutant: TUBA-MUTANT-LISTS.INIT	tuba-mutant-lists.fill	'c tuba-mutants.1.1.init  do: tuba-mutant-list-1-1	'c tuba-mutants.1.2.init  do: tuba-mutant-list-1-2	'c tuba-mutants.2.1.init  do: tuba-mutant-list-2-1	'c tuba-mutants.2.2.init  do: tuba-mutant-list-2-2	tuba-1-source-1 0 insert: tuba-mutant-list-1-1	tuba-1-source-2 0 insert: tuba-mutant-list-1-2	tuba-2-source-1 0 insert: tuba-mutant-list-2-1	tuba-2-source-2 0 insert: tuba-mutant-list-2-2	tuba-1-target-1 add: tuba-mutant-list-1-1	tuba-1-target-2 add: tuba-mutant-list-1-2	tuba-2-target-1 add: tuba-mutant-list-2-1	tuba-2-target-2 add: tuba-mutant-list-2-2;: TUBA.INIT	1024 ticks/beat !	tuba.shapes.init 	." shapes inited " cr	tuba-mutant-lists.init  ." mutant lists inited ..." cr	rtc.rate@ ." RTC Rate is " . cr;	: TUBA.TERM	free: tuba-1-source-1	free: tuba-1-target-1	free: tuba-1-source-2	free: tuba-1-target-2\	free: tuba-2-source-1	free: tuba-2-target-1	free: tuba-2-source-2	free: tuba-2-target-2\	freeall:  tuba-mutant-list-1-1	freeall:  tuba-mutant-list-2-1	freeall:  tuba-mutant-list-1-2	freeall:  tuba-mutant-list-2-2\	free:  tuba-mutant-list-1-1	free:  tuba-mutant-list-2-1	free:  tuba-mutant-list-1-2	free:  tuba-mutant-list-2-2\	free:  tuba-mutant-player-1	free:  tuba-mutant-player-2\ 	free: all-shapes-1	free: all-shapes-2	free: c-tuba;if.forgotten tuba.term