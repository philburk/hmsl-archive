\ compositional algorithm for for jim, lou and ben\ movement 3\ lp\ 7/20/95anew task-rp3_algorithmob.shape section-lengthsob.shape section-fundamentals5 k: #_sectionsv: section-#\ current absolute width allowedv: step-width\ quarter = 220, 440 8ths per minute, 3 minutes\ 440 is a pretty fast tempo for this...3 440 * k: #_notes\ absolute note increment for the piece v: note-#\ note # for a secionv: phrase-note-#v: section-note-#\ keeps track of current indexv: curr-index\ 0 if down, 1 if upv: prev-direction\ 2/3's chance of keeping going in the same direction66 k: prev_direction_prob v: prev-note-index: INIT.SECTION-LENGTHS	5 1 new: section-lengths	stuff{ 		#_notes 10 100 */		#_notes 15 100 */		#_notes	20 100 */		#_notes 25 100 */		#_notes	30 100 */	}stuff: section-lengths	print: section-lengths;\ each section tends to pick starting pitches for phrases around the three fundamentals: INIT.SECTION-FUNDAMENTALS	5 1 new: section-fundamentals	stuff{ 		267		\ around G		702		\ around B		969		\ around D		267		\ around B			267		\ around G	}stuff: section-fundamentals	print: section-fundamentals;: INCREMENT.COUNTERS	1 note-# +!	1 phrase-note-# +!	1 section-note-# +!	;\ this is slightly weighted to widen the range of the whole piece...: WIDEN.RANGE { note -- index-range }		note  many: s-shape #_notes */ ( % thru piece )		2 max		dup		2/ 1 max wchoose;	: PICK.STARTING.PITCH { | cents-value ind -- index }	section-# @ 0 ed.at: section-fundamentals	-> cents-value	BEGIN		\ one out of every two times look for expanding range		2 choose 1 = 		IF			\ many: s-shape 1 wchoose 			 note-# @ widen.range		ELSE				many: s-shape 1 wchoose 		THEN		dup -> ind		2 ed.at: s-shape		cents-value		- abs 75 <		IF TRUE ELSE FALSE THEN	UNTIL	ind curr-index !\	ind 2 ed.at: s-shape .	increment.counters;	\ increase step size to octave over course of piece!: INTERPOLATE.STEP.SIZE ( note-# -- step-width )	( note-# @ ) 1200 *	#_notes /\	step-width !\	step-width ?		;: ISS interpolate.step.size ;	v: curr-phrase-length: CHOOSE.PHRASE.LENGTH (  -- )	section-# @  1+ \ section numbers go from 0 - 4\	dup 3 > IF 5 * ELSE 4 * THEN	5 *	2 max 17 min	dup 2/ wchoose	curr-phrase-length !;	: CPL choose.phrase.length ;	: INIT.SECTION	section-# @ 1+ 5 min section-# !	0 section-note-# !	0 phrase-note-# !	cr cr cr ." Section " section-# ? cr ;\ remember that the first note in the s-shape is a dummy 1/1, so only index\ 1 is used...v: index-counter: FIND.INDEX.RANGE { | prev-note cents-width search-index -- }	curr-index @ -> prev-note	prev-note -> search-index	note-# @ interpolate.step.size -> cents-width\	cents-width .		\ now pick direction to go in	\ change directions 1/3 of the time	100 choose prev_direction_prob > 	IF		prev-direction @ 1+ 2 mod		prev-direction !	THEN	\ search for ends of shape, and force them back the other way	search-index 1 =	IF		1 prev-direction !	THEN	search-index many: s-shape 1- =	IF		0 prev-direction !	THEN	\ now traverse from present index to find cents width that's bigger,	\ and spit out the two indices (current, range )	0 index-counter !	BEGIN		search-index \ dup .		prev-direction @ 0= IF -1 + ELSE 1 + THEN		\ clip it to the shape		1 many: s-shape 1- clipto		-> search-index 		prev-note 4 ed.at: s-shape		search-index 4 ed.at: s-shape		- abs		cents-width > 		IF	 true		ELSE			false		THEN		?terminal or\	." . " 	\ check to see if it's not finding, near ends of list...	1 index-counter +!	index-counter @ 50 >	IF\		." switching direction " 		prev-direction @ 1+ 2 mod prev-direction !		0 index-counter !	THEN	UNTIL	prev-note search-index 	;	: (PICK.NEXT.PITCH)	{ | i-current i-range i-diff -- new-index }	find.index.range 	-> i-range	-> i-current\	i-current . i-range .	i-range i-current - abs -> i-diff	i-diff 	i-diff choose 	\ 1/3 of the time weight the choice towards the high end of the interval...	3 choose 1 >	IF		choose  ( -- diff rand )	THEN	-\	dup .	1 max	i-range i-current >	IF		i-current +	ELSE		i-current swap -	THEN	( -- new index )	0 many: s-shape 1- clipto	curr-index !	\ now increment counters for next time around	increment.counters;: IS.NEW.SECTION?	section-note-# @ 		section-# @ 0 ed.at: section-lengths	=;: IS.NEW.PHRASE?	note-# 0=	not	IF		phrase-note-# @ 		curr-phrase-length @ 1- 		=	THEN;: INIT.PHRASE	cr ." New Phrase "	pick.starting.pitch	choose.phrase.length	." with length " curr-phrase-length ? 	tab ." (cents width = " note-# @ interpolate.step.size .  ." ) " 	cr	0 phrase-note-# !;	\ this is the basic engine that picks the new index, increments counters: PICK.NEXT.PITCH { | i-current i-range i-diff -- new-index }	is.new.section?	IF		." new section " cr		init.section		init.phrase	ELSE		\ new phrase but not new section		is.new.phrase?		IF			init.phrase		ELSE		(pick.next.pitch)		THEN	THEN	tab curr-index @ .	tab curr-index @ 0 ed.at: s-shape .	." / " curr-index @ 1 ed.at: s-shape .	tab curr-index @ 5 ed.at: s-shape 	hp = IF ." harp " ELSE ." guitar " THEN 	tab curr-index @ 6 ed.at: s-shape print.note.name 	curr-index @ 7 ed.at: s-shape .;				\  have some sort of registral trajectory for the whole piece? rise up and then down?	\ straight up??		\ write a short intro and outro: unisons and octaves...: TESTIT	many: s-shape choose curr-index !	#_notes choose dup ." Note-#: " . note-# !	#_sections choose section-# !;: INIT.RP3	12 tab-width !	init.section-lengths	init.section-fundamentals	0 note-# !	0 phrase-note-# !	0 section-note-# !	0 section-# !	init.phrase;: TERM.RP3	free: section-lengths	free: section-fundamentals;cr ." Initializing piece .... " cr init.rp3 : TP 0 DO  pick.next.pitch tab i . cr  ?terminal IF LEAVE THEN LOOP ;	if.forgotten term.rp3