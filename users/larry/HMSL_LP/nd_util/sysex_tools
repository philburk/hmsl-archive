\ slippers of steel\ 4/28/91\ Nick Didkovsky\ sysex_tools\ Some tools to communicate between machines via MIDI sysex.\ Tools to pass and receive 16 bit values.\ Routine to swallow sysex until eox.\ Each of the receiving routines check a flag to see if they should \ also pass on the sysex data stream to other machines.\ On a ring of machines, one machine should have this flag set to false,\ all others to true, so that there's no feedback loop.\ MOD: 14 bit wordsanew task-sysex_toolsdecimalvariable  kount-16variable value-16variable kount-14variable value-14variable sysex-done-flagvariable sysex-thru?sysex-thru? off10000 constant MIDI_buffer_size: BIG.MIDI.BUFFER ( -- )  midi.term  MIDI_buffer_size MIDI-recv-size !  MIDI_buffer_size MIDI-xmit-size !	\ must be >= MIDI-recv-size  MIDI-warnings on  midi.init;: SWALLOW.SYSEX ( -- )  BEGIN	midi.recv IF sysex-thru? @ IF dup $ F7 = 		( -- value flag)		     		   swap midi.xmit	( -- flag)				ELSE $ F7 =				THEN		  ELSE false		( -- flag)		  THEN  UNTIL  sysex-thru? @ IF midi.flush THEN;: MIDI.XMIT.7 ( 7bit -- ) midi.data.xmit ;: RECEIVE.SYSEX.7 ( -- 7bit true | false)  BEGIN  	midi.recv 	( -- 7bit true | false)  UNTIL  sysex-thru? @ IF dup midi.xmit THEN  dup $ F7 = IF drop false ELSE true THEN;\ convert 14 bit to signed value: 14->S dup $ 1FFF > IF $ FFFFC000 or THEN ;: MIDI.XMIT.14 ( 14-bit-value -- )  dup -7 ashift $ 7f and midi.xmit	( -- value , send 7 hibits)  $ 7f and midi.xmit			( --  , send 7 lobits);\ false if sysex end, true if you got a full 14 bit value.\ receive a 14 bit sysex value and pass it thru if flag set.: RECEIVE.SYSEX.14 ( -- 14-bit-value true | false )  receive.sysex.7 IF 	$ 7f and 7 ashift		( -- hi7)  		     	receive.sysex.7 IF $ 7f and or 14->S true  			sysex-thru? @ IF midi.flush THEN  		     ELSE drop false  		     THEN  		       ELSE false  THEN;: 16->8lo8hi ( 16-bit -- lo-byte hi-byte)  dup $ ff and swap -8 ashift;\ send out 16 bit value as 4 nibbles, highest to lowest: 16.XMIT ( 16-bit-val -- )  16->8lo8hi   midi.xmit.hilo  midi.xmit.hilo  midi.flush;\ false if sysex end, true if you got a full 16 bit value.\ receive a 16 bit sysex value and pass it on.: GET.SYSEX.16 ( -- 16-bit true | false )  0 kount-16 !  0 value-16 !  BEGIN  	midi.recv 	IF dup $ F7 = dup				 ( -- val flag flag)	NOT IF 	swap 				 ( -- false val)			sysex-thru? @ IF dup midi.xmit THEN ( -- false val)		       	value-16 @ 4 ashift or value-16 ! ( -- false)		       	1 kount-16 +!		       	sysex-done-flag off		ELSE 					  ( -- val flag)			sysex-thru? @ IF over midi.xmit THEN ( -- val flag)			nip				  ( -- true)		     	sysex-done-flag on		THEN	     	ELSE false 	THEN  kount-16 @ 4 = or  UNTIL  sysex-done-flag @ IF false ELSE value-16 @ w->s true THEN  sysex-thru? @ IF midi.flush THEN;  		  \ send forth-style string in sysex stream: SEND.STRING.X { some-str -- }   some-str c@ 1+ 0 do  	some-str i + c@ midi.data.xmit  loop;: RECEIVE.STRING.X { str | recflag -- flag , read chars into an allocd str }  true -> recflag  receive.sysex.7   IF dup str c!     0 DO receive.sysex.7    	IF i 1+ str + c!        ELSE ." RECEIVE.STRING.X couldn't get full name from remote" cr         	false -> recflag        	leave        THEN     LOOP  ELSE ." RECEIVE.STRING.X couldn't get count byte from remote" cr false  THEN  recflag;: TEST.16 ( -- )  midi.start.sysex 0 midi.xmit  1000 -1000 wchoose dup . ." sent "  cr 16.xmit  midi.end.sysex  midi.flush;: TEST.16.VECTOR ( vendor -- ) sysex-thru? @ 	IF midi.start.sysex midi.xmit	ELSE drop	THEN   get.sysex.16 IF . ."  received" cr		ELSE ." get.sysex.16 returns false" cr		THEN; : TEST.14 ( -- )  midi.start.sysex 0 midi.xmit  8191 -8192 wchoose dup . ." sent "  cr midi.xmit.14  midi.end.sysex  midi.flush;: TEST.14.VECTOR ( vendor -- ) sysex-thru? @ 	IF midi.start.sysex midi.xmit	ELSE drop	THEN   receive.sysex.14	    IF . ."  received" cr   ELSE ." receive.sysex.14 returns false" cr   THEN;: SEND.14.MANY ( -- )  midi.start.sysex 0 midi.xmit  1000 0 do  	i 500 - midi.xmit.14  loop  midi.end.sysex  midi.flush;ob.shape some-shape: REC.14.MANY.VECTOR ( vendor -- )  sysex-thru? @   IF midi.start.sysex midi.xmit  ELSE drop  THEN  BEGIN receive.sysex.14	   WHILE add: some-shape  REPEAT;: TEST.SYSEX.MANY ( -- )  1000 1 new: some-shape  sysex-thru? off  big.midi.buffer  mp.reset  midi.clear  midi.parser.on  'c rec.14.many.vector  mp-sysex-vector !  clear: shape-holder  some-shape add: shape-holder  hmsl.start  ." SEND.14.MANY" cr ;: TEST.SYSEX.TOOLS.14 ( -- )  big.midi.buffer  mp.reset  midi.clear  midi.parser.on  'c test.14.vector mp-sysex-vector !  hmsl.start  ." test.14 a few times" cr ;