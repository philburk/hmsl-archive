\ Roads mutations...ANEW TASK-ROADS_MUTATIONSOB.OBJLIST ROADS-DATA-LIST0 k: mut_type1 k: mut_shape2 k: mut_min3 k: mut_max4 k: doom_%8 value month27 value date\ mutation chooser uses a case statement: harmonic mutation, lcm/iuim, usim\ uuim/lcm: CHOOSE.MUTATION ( -- value for case statement )	 5 choose;: CHOOSE.½-SHAPE ( indx -- index to ternary shapes )	13 choose ;: CHOOSE.MIN  ( indx -- min )	1000 choose choose choose;\ there is a one in 17 chance that it will go all the way to 1000: CHOOSE.MAX ( indx -- max )	17 choose 8 = 	IF		1000	ELSE		1000 1000 choose choose choose -	THEN;: FILL.ROADS-DATA-SHAPE { data-shape -- }	17 5 data-shape new: []	17 data-shape set.many: [] 	" Mutation " 0 data-shape put.dim.name: []	" ½-shape "  1 data-shape put.dim.name: []	" Min. "     2 data-shape put.dim.name: []	" Max. "     3 data-shape put.dim.name: []	" DOOM % "   4 data-shape put.dim.name: []	17 0 DO		choose.mutation i 0 data-shape ed.to: []		choose.½-shape  i 1 data-shape ed.to: []		choose.min      i 2 data-shape ed.to: []		choose.max      i 3 data-shape ed.to: []		i 54 * dup choose choose choose - 		i 4 data-shape ed.to: [] \ the variations get less and less dense	LOOP\	data-shape print: [];\ Have to offset the index to the data shape by -1, because the lists\ start with the source, which needn't be mutated.... the lists of shapes\ are 19 long, 17 mutations plus source and target. the mutation data shape\ is only 17 long....: SETUP.ROADS.MUTATIONS { indx part# curr-mutant | data-shape -- }\	curr-mutant print: []	part# at: roads-data-list -> data-shape	part# at: r-sourcelist curr-mutant put.source: []	part# at: r-targetlist curr-mutant put.target: []		indx 1- mut_shape data-shape ed.at: [] 	at: ternary-shapes 	dup tab ." Ternary shape: " name: [] 	curr-mutant put.½.shape: []	indx 1- mut_min data-shape ed.at: [] 	tab ." Min: " dup . 	curr-mutant put.min.½: []	indx 1- mut_max data-shape ed.at: [] 	tab ." Max: " dup . 	curr-mutant put.max.½: [] \ the DOOM mutation is done after all else is finished, this is just a printout	indx 1- doom_% data-shape ed.at: [] 	tab ." DOOM % " .;\ temporarily commented out uoh: CHOOSE.ROADS.MUTATIONS { indx part# curr-mutant | data-shape -- }		part# at: roads-data-list -> data-shape		indx 1- mut_type data-shape ed.at: []		CASE			0 of curr-mutant usim: [] ." USIM " endof			1 of curr-mutant uoh: []  ." UOH "   endof			2 of curr-mutant lcm/iuim: []  ." LCM/IUIM "  endof		 	3 of curr-mutant isim: []  ." ISIM "  endof			4 of curr-mutant lcm/uuim: []  ." UUIM/LCM "  endof		ENDCASE;: PRINT.PART ( # -- )	CASE		0 of ." Vln 1 " endof		1 of ." Vln 2 " endof		2 of ." Viola " endof		3 of ." Cello " endof	ENDCASE;: ROADS.DOOM { indx part# curr-mutant | data-shape -- }\ first make sure that simple ½ value is used for DOOM	0 curr-mutant put.½.function: []	0 curr-mutant put.½.shape: []\ now grab ½ from the data shape and perform the mutation	part# at: roads-data-list -> data-shape	indx 1- doom_% data-shape ed.at: [] ( -- ½ )	curr-mutant put.½: []	1 curr-mutant put.curr-dim: []	curr-mutant doom: [];	: ROADS.MUTATE.DOOM { | curr-mutant indx -- }	\ don't mutate source, which is first in each list	18 1 DO		?terminal IF leave THEN		i -> indx 		4 0 DO			?terminal IF leave THEN			indx  			i  ( -- indx i )			at: r-master-list \ gives current list			at: [] -> curr-mutant			indx i curr-mutant roads.doom		LOOP 	LOOP;	: ROADS.MUTATE.MELODIES { | curr-mutant indx -- }	\ don't mutate source, which is first in each list	18 1 DO	cr cr		?terminal IF leave THEN		i -> indx 		indx ." Mutation " . 		r-targets.init \ make a new set of targets 		4 0 DO			?terminal IF leave THEN			indx  			cr i dup print.part ( -- indx i )			at: r-master-list \ gives current list			at: [] -> curr-mutant			indx i curr-mutant 			setup.roads.mutations 			indx i curr-mutant choose.roads.mutations		LOOP 	LOOP;: ROADS.MUTATE	10 tab-width !	" roads:roads_data " $logto	cr cr ." ROADS TO CHIMACUM " 	cr ." Data from computed run "	cr ." Month - day: " 	month . ." - " date . cr	roads.mutate.melodies	roads.mutate.doom	logend	8 tab-width !;: INIT.ROADS-DATA { | data-shape -- }	4 new: roads-data-list	4 0 DO		instantiate ob.shape		-> data-shape		data-shape add: roads-data-list	LOOP	'c fill.roads-data-shape do: roads-data-list;: TERM.ROADS-DATA	freeall: roads-data-list	free: roads-data-list;