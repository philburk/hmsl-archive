\ Roads to Chimacum\ author LPANEW TASK-ROADS_MELODIES\ these are in general, good procedures to use in following pieces\ finale uses 512 ticks per eigth note, in a 4/4 measure that makes\ 4096 ticks per measure...17 -> #-of-mutations3072 -> measure-length512 -> beat-length275 k: r_lengthob.collection c-roadsob.mutant-harmonic-et r-1-sourceob.mutant-harmonic-et r-2-sourceob.mutant-harmonic-et r-3-sourceob.mutant-harmonic-et r-4-source\ob.mutant-harmonic-et r-1-targetob.mutant-harmonic-et r-2-targetob.mutant-harmonic-et r-3-targetob.mutant-harmonic-et r-4-target\ob.mutantlist r-sourcelistob.mutantlist r-targetlistob.mutantlist r-1-listob.mutantlist r-2-listob.mutantlist r-3-listob.mutantlist r-4-listob.objlist r-master-list\75 value r-1-fund68 value r-2-fund63 value r-3-fund56 value r-4-fundfalse .if: READ.MF  ( -- , read a midifile into a shape )	0 " hmf:simple.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape sh1 sh.compress.notes     \ convert to compressed;: PLAY.MF  ( -- , play the shape read from MIDIFile )	sh1 ins1 build: pl1	0 put.offset: ins1     \ 0 offset because stored as MIDI notes	use.absolute.time: pl1 \ absolute not relative time	3 put.on.dim: pl1      \ use ontimes of compressed notes	pl1 hmsl.play;.thenscore{1000 rtc.rate!: SETUP.TEMPO  ( -- , for proper note durations )	4 ticks/beat @ * tpw!;\ ************\ SETUP  1: R-SOURCES.INIT { shape -- }\ First differentiate, so that we are working on durations and on-times.... not absolute times...	shape last: []	nip nip \ ( -- on-time duration )	+   ( -- on-time+duration )	0 0 shape ed.at: [] + \ this should not be necessary....	0 shape differentiate: []\ accent first note of melody	90 0 2 shape ed.to: []	1 shape put.curr-dim: []	shape use.fund-value: []	0 shape put.: []	shape zero-override?.on: []\ adjust the last values: they're all an eighth note with a dotted quarter rest	2048 shape many: [] 1- 0 shape ed.to: [] \ duration 	512 shape many: [] 1- 3 shape ed.to: []  \ on-time;\ read in the individual midifiles, and also, set each harmonic fundamental differently: R-1-SOURCE.INIT ( -- )	r_length 4 new: r-1-source	r_length 4 new: r-1-target\ read in the midifile	1 " roads:violin1.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape r-1-source sh.compress.notes     \ convert to compressed absolute	r-1-source r-sources.init	r-1-fund 1 r-1-source put.fund-value: []	beat-length 5 * 0 96 beat-length 5 * 0 insert: r-1-source	many: r-1-source set.many: r-1-target	r-1-fund 1 r-1-target put.fund-value: []	1  put.curr-dim: r-1-target 	use.fund-value: r-1-target	0  put.: r-1-target	zero-override?.on: r-1-target;\ 2nd violin/mandolin: R-2-SOURCE.INIT ( -- )	r_length 4 new: r-2-source	r_length 4 new: r-2-target\ read in the midifile	1 " roads:violin2.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape r-2-source sh.compress.notes     \ convert to compressed absolute	r-2-source r-sources.init	r-2-fund 1 r-2-source put.fund-value: []	beat-length 8 * 0 96 beat-length 8 * 0 insert: r-2-source	many: r-2-source set.many: r-2-target	r-2-fund 1 r-2-target put.fund-value: []	1  put.curr-dim: r-2-target 	use.fund-value: r-2-target	0  put.: r-2-target	zero-override?.on: r-2-target;\ mandola or viola: R-3-SOURCE.INIT ( -- )	r_length 4 new: r-3-source	r_length 4 new: r-3-target\ read in the midifile	1 " roads:viola.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape r-3-source sh.compress.notes     \ convert to compressed absolute	r-3-source r-sources.init	r-3-fund 1 r-3-source put.fund-value: []	beat-length 8 * 0 0 beat-length 8 * 0 insert: r-3-source	many: r-3-source set.many: r-3-target	r-3-fund 1 r-3-target put.fund-value: []	1  put.curr-dim: r-3-target 	use.fund-value: r-3-target	0  put.: r-3-target	zero-override?.on: r-3-target;\ cello: R-4-SOURCE.INIT ( -- )	r_length 4 new: r-4-source	r_length 4 new: r-4-target\ read in the midifile	1 " roads:cello.mf" $mf.load.shape  \ loads as absolute expanded	mf-shape r-4-source sh.compress.notes     \ convert to compressed absolute	r-4-source r-sources.init	r-4-fund 1 r-4-source put.fund-value: []	beat-length 9 * 	0 0 beat-length 9 * 	0 insert: r-4-source	many: r-4-source set.many: r-4-target		r-4-fund 1 r-4-target put.fund-value: []	1  put.curr-dim: r-4-target 	use.fund-value: r-4-target	0  put.: r-4-target	zero-override?.on: r-4-target;: R-TARGETS.INIT { | sour targ s-min s-max -- }	4 0 DO		i at: r-sourcelist		-> sour		i at: r-targetlist 		-> targ		1 sour calc.non-zero.dim.stats: []		1 sour get.dim.max: [] -> s-max		1 sour get.dim.min: [] -> s-min		sour many: [] 0 		DO			i 0 sour ed.at: [] ( d )			100 choose 80 > 			i 1 > and			IF						2 choose+/-				i 1- 1 targ ed.at: []				+			ELSE				s-max s-min - 2/ ( -- 1/2 range )				dup 				s-min + swap 				gaussian  ( d p )			THEN				i 2 sour ed.at: [] ( d p v )			i 3 sour ed.at: [] ( d p v on )			i targ put: []	LOOP		\ after created target, 1 in 4 chance that the target will be recreated as		\ a scrambled version of the source...		100 choose 25 < 		IF			sour many: [] 0			DO				i 1 sour ed.at: []				i 1 targ ed.to: []			LOOP\				." Scrambling a shape.... " 				0 targ many: [] 1- 1 targ scramble: []  		THEN		1 targ put.curr-dim: []		targ use.fund-value: []		0 targ put.: []		targ zero-override?.on: []		0 0 1 targ ed.to: []  \ first beat of all of the targets is a rest	LOOP;		: (INIT.ROADS.MUTANTS) { mutant -- }	1 mutant put.curr-dim: []	mutant use.fund-value: []	0 mutant put.: []	mutant zero-override?.on: [];	: R-1-MUTANTS.INIT { mutant -- }	mutant clone: r-1-source	r-1-source mutant put.source-shape: []	r-1-target mutant put.target-shape: []	mutant (INIT.roads.MUTANTS)	r-1-fund 1 mutant put.fund-value: [];: R-2-MUTANTS.INIT { mutant -- }	mutant clone: r-2-source	r-2-source mutant put.source-shape: []	r-2-target mutant put.target-shape: []	mutant (INIT.roads.MUTANTS)	r-2-fund 1 mutant put.fund-value: [];: R-3-MUTANTS.INIT { mutant -- }	mutant clone: r-3-source	r-3-source mutant put.source-shape: []	r-3-target mutant put.target-shape: []	mutant (INIT.roads.MUTANTS)	r-3-fund 1 mutant put.fund-value: [];: R-4-MUTANTS.INIT { mutant -- }	mutant clone: r-4-source	r-4-source mutant put.source-shape: []	r-4-target mutant put.target-shape: []	mutant (INIT.roads.MUTANTS)	r-4-fund 1 mutant put.fund-value: [];: R-LISTS.FILL { | mutant -- }	4 new: r-master-list\ first fill the two lists...	." Newing the mutant lists .... " cr	#-of-mutations  2 + new: r-1-list	#-of-mutations  2 + new: r-2-list	#-of-mutations  2 + new: r-3-list	#-of-mutations  2 + new: r-4-list		#-of-mutations 0 DO		instantiate ob.mutant-harmonic-et		-> mutant		r_length 4 mutant new: [] 		mutant add: r-1-list		instantiate ob.mutant-harmonic-et		-> mutant		r_length 4 mutant new: [] 		mutant add: r-2-list		instantiate ob.mutant-harmonic-et		-> mutant		r_length 4 mutant new: [] 		mutant add: r-3-list		instantiate ob.mutant-harmonic-et		-> mutant		r_length 4 mutant new: [] 		mutant add: r-4-list	LOOP	4 new: r-sourcelist	4 new: r-targetlist	stuff{ r-1-source r-2-source r-3-source r-4-source }stuff: r-sourcelist	stuff{ r-1-target r-2-target r-3-target r-4-target }stuff: r-targetlist	stuff{ r-1-list r-2-list r-3-list r-4-list }stuff: r-master-list;: R-SHAPES.INIT	." Initing shapes and reading in MIDIFiles " cr	r-1-source.init 	r-2-source.init	r-3-source.init	r-4-source.init;: R-LISTS.INIT	." Initializing lists... " cr	." Now initializing each individual mutant list ... " cr 	'c r-1-mutants.init  do: r-1-list	'c r-2-mutants.init  do: r-2-list	'c r-3-mutants.init  do: r-3-list	'c r-4-mutants.init  do: r-4-list	." Mutants initialized " cr	r-1-source 0 insert: r-1-list	r-2-source 0 insert: r-2-list	r-3-source 0 insert: r-3-list	r-4-source 0 insert: r-4-list	." Lists initialized " cr;	: ROADS.SHAPES.TERM	free: r-1-source	free: r-2-source	free: r-3-source	free: r-4-source\	freeall: r-master-list	free: r-master-list\	freeall:  r-1-list	freeall:  r-2-list	freeall:  r-3-list	freeall:  r-4-list\	free:  r-1-list	free:  r-2-list	free:  r-3-list	free:  r-4-list\	free: r-sourcelist	free: r-targetlist;