\ JOBS for HORN piece\ Composer: LP\ 2/17/90\ update 4/22/90\ 10/28/92  RDG  Begin port to DSPANEW TASK-HORN_JOBSOB.OBJLIST		DSP-JOBS	\ holds the jobs which play the DSP arpeggioOB.OBJLIST		FB-JOBS		\ holds the jobs which play the FB01 arpeggio5 VALUE DSP_VOLUME_OFFSET 	\ max volume for a note is 127....10 VALUE DENSITY_TWEAK 		\ the higher the value, the lower the density22 value MIN_DURATION \ =============================================================\ 	PERFORMANCE JOBS \ =============================================================\ These are the jobs which actually play the piece.  They choose \ pitches from the master arpeggio that is constantly being \ modified by the code in arp.f, and determine volume and duration\ with all sorts of clever algorithms...: DSP.ALLOC.JOBS	16 new: dsp-jobs	16 0 DO		instantiate ob.job		dup ( -- job job )		add: dsp-jobs ( -- job )		dup		10000000 swap put.repeat: []		\ each job has a variable start time		500 60 wchoose swap put.start.delay: []	LOOP;: FB.ALLOC.JOBS { | job -- }	16 new: fb-jobs	16 0 DO		instantiate ob.job dup -> job		add: fb-jobs ( -- job )		10000000 job put.repeat: []		\ each job has a variable start time		500 60 wchoose  job put.start.delay: []		\ data is used for MIDI channel		i 1+ job put.data: []	LOOP;: DSP.TOAST.JOBS	many: dsp-jobs 0 DO		i at: dsp-jobs deinstantiate	LOOP	free: dsp-jobs;: FB.TOAST.JOBS	many: fb-jobs 0 DO		i at: fb-jobs deinstantiate	LOOP	free: fb-jobs;: PLAY.THIS.TIME?  ( -- ? )	\ First, a random chance that no note will be played... 	\ including a simple algorithm that makes it a little	\ more likely in the middle.	\ By changing these values, the 'activity' in different	\ sections of the piece can be finetuned...	measure-# @ 17 / 	\ to increase a section's density, lower its value in the case statement	CASE 		0 OF 0 ENDOF		1 OF 3 ENDOF		2 OF 8 ENDOF		3 OF 3 ENDOF		4 OF 0 ENDOF		5 OF 0 ENDOF  \ Only measure 85 case	ENDCASE	\ to make the piece denser, lower the value of density tweak	density_tweak + choose 7 <;		: GET.NOTE.DURATION   { pitch-index | harm# -- dur}\  this section determines the duration of the note, based on\  the harmonic series number, which series, and the overall tempo...	pitch-index 0 ed.at: arp  dup -> harm#  ( -- harm# )	17 swap - 					\ get inverse of harmonic series	60 * 						\ convert to seconds \ this next bit subtracts a bit from the tempo\ to make the piece a bit slower in the first and last 17 measures.. 	horn-tempo   	measure-# @ 17 < measure-# @ 68 >	or	IF		4 choose -	THEN\ now divide the duration by the overall tempo...	/ 				( -- seconds/tempo )	harm# / 		( -- [seconds/tempo]/series# );	\ prevent really short durations: PREVENT.CLICKS  ( dur -- dur )	min_duration max;: DSP-JOB.FUNCTION { job | pitch-index inst att dec dur sust -- }	job get.instrument: []	dup -> inst	off: []					\ save instrument address and turn it off		play.this.time?	IF		many: arp choose  -> pitch-index  \ pick pitch from arpeggio randomly		pitch-index 1 ed.at: arp 					inst  put.frequency: []				pitch-index 2 ed.at: arp 		choose			dsp_volume_offset + 200 max			inst put.volume: []					\ pick random volume between 0 and max		pitch-index  get.note.duration   		prevent.clicks	-> dur			( note duration goes from 20 to max )		\ this picks attacks and decays which could be each as long as 5/12's of the note		\ duration		dur 5 12 */ choose		6 max		-> att		dur 5 12 */ choose		6 max		-> dec		dur att dec + - 		dup choose choose  -		-> sust				\ temp KLUDGE for dealing with attack and decay times		sust inst put.sustain: []			att inst put.attack: []		dec inst put.decay: []		att dec sust + + dur > 		IF ." ERROR: Envelope longer than duration " cr THEN\		dur 4 + job put.duration: []		\			inst on: []	THEN;\ These are the dimensions of the arp for memory's sake...\ harm# pitch/Hz volume flag note/midi fraction cents : FB-JOB.FUNCTION { job | pitch-index inst att dec dur sust -- }	play.this.time?	IF		many: arp choose  -> pitch-index  \ pick pitch from arpeggio randomly		pitch-index 4 ed.at: arp 					pitch-index 5 ed.at: arp 				pitch-index 2 ed.at: arp		( Ñ- note# fract velocity )		job get.data: [] midi.channel!		fb.start.events fb.fract.on		pitch-index  get.note.duration   		prevent.clicks			job put.duration: []				fb.stop.events	THEN;: DSP.CONFIGURE.JOBS ( -- )	16 0 DO		1  i at: dsp-jobs ( -- job address )		new: []		'c dsp-job.function i at: dsp-jobs  add: []\ put instruments		instantiate ob.sine_instrument dup		\ make a new instance		load: []								\ stuff into DSP		i at: dsp-jobs  put.instrument: []		\ put in job	LOOP;: FB.CONFIGURE.JOBS ( -- )	16 0 DO		1  i at: fb-jobs new: []		'c fb-job.function i at: fb-jobs  add: []	LOOP;: DSP.DECONFIGURE.JOBS ( -- )	many: dsp-jobs 0 DO		i at: dsp-jobs ( -- job address )		get.instrument: []		deinstantiate 	LOOP;: FB.DECONFIGURE.JOBS ( -- , included for parallelism's sake );: INIT.HORN.JOBS ( -- )	." Initalizing performance jobs" cr	dsp.alloc.jobs	dsp.configure.jobs	fb.alloc.jobs	fb.configure.jobs;: TERM.HORN.JOBS ( -- )	dsp.deconfigure.jobs	dsp.toast.jobs	fb.deconfigure.jobs	fb.toast.jobs;if.forgotten term.horn.jobs