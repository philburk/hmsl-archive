\ Create an instrument class that does simple sine waves \ with attack sustain and decay.\\ Author: Darren Gibbs\ Date:   11/12/92\\ MOD 11/18/92 RDG   Added a kludge in the envelope calculation methods \                         to deal with roundoff error -- my lame integer math skills. \					 Removed the Update: method and put the frequency update\					       code into the put.frequency: method.ANEW TASK-SINE_INSTRUMENTdecimalFPINIT:UNIT U_SINE	plug	U_SINE_FREQ1	unit 	u_oscillator 	U_SINE_OSC1	plug	U_SINE_LEVEL1\	unit	u_envelope		U_SINE_ENV1	8 plugs	U_SINE_segments1;UNITMETHOD PUT.SEGMENT:		METHOD GET.SEGMENT:METHOD TRIGGER:METHOD PUT.FREQUENCY:	METHOD GET.FREQUENCY:METHOD PUT.VOLUME:		METHOD GET.VOLUME:METHOD PUT.ATTACK:		METHOD GET.ATTACK:METHOD PUT.SUSTAIN:		METHOD GET.SUSTAIN:METHOD PUT.DECAY:		METHOD GET.DECAY::CLASS OB.SINE_INSTRUMENT  <SUPER  OB.56K.CIRCUIT	IV.LONG		IV-SINE-PITCH	IV.LONG		IV-SINE-PITCH-HZ	IV.LONG		IV-SINE-VOLUME:M INIT:  ( -- )	init: super	sizeof()  u_sine  iv=> iv-circ-xsize;M:M COMPILE:  ( -- , compile into 56000 )\ Control Rate code	56k{		U_SINE_env1	x+ 56k.LinEnvelope		\ define envelope unit		U_SINE_level1 x+ 56k.x!				\ output level		56K.RTS	}56k.control\ Audio Rate code	56k{		U_SINE_freq1 	x+ 56k.x@			\ fetch frequency		U_SINE_osc1 	x+ 56K.OscillatorI  \ execute oscillator		U_SINE_level1 	x+ 56k.x*			\ calculate output level		56K.MixMono							\ mix outputs		56K.RTS	}56k.audio;M\ 440 Hz = @167973 in HMSL/DSP frequency specification381.756818 FCONSTANT FREQ-CONST\ this constant (167973/440) is multiplied by FHz to get \ the proper proper pitch specification.  Used FP for accuracy.: HZ->DSP.TUNING  ( FHz -- dsp-pitch ) 	float	freq-const f*	int;		:M PUT.FREQUENCY:  ( freq -- )	dup iv=> iv-sine-pitch-hz	hz->dsp.tuning	dup iv=> iv-sine-pitch	u_sine_freq1  x+ dsp.x!;M:M GET.FREQUENCY:  ( -- freq )	iv-sine-pitch-hz;M: 56K.ENV.SET.END { slot# env -- }	56k-CircuitOff		env_end_func env + dsp.x!	slot# env_end_data env + dsp.x!;:M PUT.SEGMENT: ( count incr index -- )	U_SINE_env1 swap 2* + env_zero + tuck	1+ put: self	put: self;M:M GET.SEGMENT: (  index --  count incr )	U_SINE_env1 swap 2* + env_zero + dup get: self	swap 1+ get: self;M:M TRIGGER:  ( -- )	U_SINE_env1 x+ 56k.reset.env;M46 K: time-const\ 2800 = 1sec of HMSL/DSP control rate time\ 60 = 1sec of HMSL time  \ 2800 60 / = 46\ multiplying 46 by the incoming ticks value will convert to approx DSP \  time value.\ NOTE: RTC.RATE MUST BE 60 or this wont work properly!!!:M PUT.ATTACK:  { | acount -- }	time-const * -> acount	acount  iv-sine-volume acount /   ( -- count incr )	0 put.segment: self;M:M GET.ATTACK:  ( -- rtc-ticks )	0 get.segment: self 	( -- acount incr )	drop	time-const /;M:M PUT.SUSTAIN:  ( rtc-ticks -- )	time-const *  0  1  put.segment: self;M:M GET.SUSTAIN:  ( -- rtc-ticks )	1 get.segment: self drop	time-const /;M:M PUT.DECAY:  { | dcount -- }	time-const *  -> dcount	dcount  iv-sine-volume dcount / negate  ( -- dcount -incr )\ Due to slight roundoff error in integer math, the envelope decay increment is often\  slightly too small... making it one larger will ensure that 0 is crossed.\ The envelope start value will be reset to zero in the on: method.	1- 	2 put.segment: self;M:M GET.DECAY:  ( -- count )	2 get.segment: self drop	time-const /;M57500 k: volume-const		\ to roughly but quickly convert 0-127 to 0-$700000ish DSP vol:M PUT.VOLUME:  { volume | vcount -- }	volume volume-const *	iv=> iv-sine-volume	\ re-calculate attack segment based on new volume	0 get.segment: self drop  -> vcount	vcount  iv-sine-volume vcount /   ( -- vcount incr )	0 put.segment: self\ re-calculate decay segment	2 get.segment: self drop  -> vcount	vcount  iv-sine-volume vcount / negate  ( -- vcount -incr )	2 put.segment: self;M:M GET.VOLUME:  ( -- volume )	iv-sine-volume	volume-const /;M:M PRINT: ( -- )	print: super cr	." OB.SINE_INSTRUMENT " cr	base @	decimal	."   Volume:     " get.volume: 	   self . cr	."   Frequency:  " get.frequency:  self . cr	."   Attack:     " get.attack:     self . cr	."   Sustain:    " get.sustain:    self . cr	."   Decay:      " get.decay:      self . cr	base !;M	:M SETUP: ( -- )	U_SINE_osc1 x+ 56k.init.oscillator	U_SINE_env1 x+ 56k.init.envelope	440  put.frequency:  self	200    put.volume:   self	10      put.attack:   self	20     put.sustain:  self	10      put.decay:    self	0 0 3  put.segment:  self   \ mark termination;M:M ON:	0 U_SINE_osc1 osc_phase + put: self	0 U_SINE_level1 put: self   \ KLUDGE for inaccurices in envelope computation...	trigger: self	on: super	iv-circ-slot# U_SINE_env1 x+ 56k.env.set.end;M\ stubs for calls from jobs:M OPEN:;M:M CLOSE:;M;CLASS