\ This code does the basic composition of the piece. It contains the \ pitch replacement and measure advancement algorithms. \ Composer: LP\ 2/17/90\ update 4/22/90\ 10/28/92  RDG  Begin port to DSPANEW TASK-ARPOB.SHAPE ENTRY-ORDER	\ contains order of entry of harmonics...OB.SHAPE ARP			\ contains dsp arpeggio at any given time...\ the dimensions of the arp are:\ harm# pitch/Hz volume flag note/midi fraction cents \ Again, cents is currently not used but was left in for ???OB.JOB   ARP-CHANGER 	\ this job changes the content of arpeggioOB.JOB 	 XFADER			\ cross fades the entering pitch with the leaving one\ =============================================================\ 	REPLACEMENT\ =============================================================\ This is the basic harmonic series replacement. it takes the entering value, and\ identifies the value in the series it is replacing (excluding the ones that have \ already entered from the new series). the pitch to be replaced is simply \ the closest to the entering oneV: MEASURE-# 				\ where in piece you are at a given time							\ there are 85 measures in the piece600 VALUE MEASURE-TIME 		\ average length of a measure... 							\ 600 yields measures between 10-15 secs long5 VALUE  HORN-TEMPO			\ this value is used only for note durations.							\ the smaller the number for horn-tempo the 							\ longer the pitches. this is the number by 							\ which all "seconds" values are divided...V: ENTERING-PITCH-INDEX		\ index into arpeggio of new pitch V: LEAVING-PITCH-INDEX  	\ index into arpeggio of pitch being replacedV: TICKS/MEASURE			\ actual length of current measure, used for xfades127 VALUE MAX-VOLUME		\ set max volume to be MIDI max velocity\ this code xfades the entering pitch with the leaving pitch \ during the course of the measure: CALC.XFADE  { | ticks job-dur incre --  }	ticks/measure @ -> ticks					\ # ticks in current measure	max-volume ticks 2dup <						\ calculate step increment	IF   swap / -> job-dur  1 -> incre			\  and repeat rate	ELSE / -> incre  1 -> job-dur	THEN 		BEGIN		job-dur  rtc.rate@ 16 /  <				\ make min duration 1/16 of rtc-rate	WHILE										\ to keep from hogging all of the 		job-dur  2* -> job-dur					\ scheduler's time for xfading		incre 2* -> incre	REPEAT	job-dur put.duration: xfader	max-volume incre / put.repeat: xfader	incre put.data: xfader						\ store increment in job;\ do the actual cross fade: XFADE.FUNC  { job | incre -- }	job get.data: [] -> incre 	entering-pitch-index @ 2 ed.at: arp	incre +							\ add increment to entering pitch	entering-pitch-index @ 2 ed.to: arp	leaving-pitch-index @ 2 ed.at: arp	incre -							\ subtract increment from leaving pitch	leaving-pitch-index @ 2 ed.to: arp	job set.done: [];: ENTERING.SERIES  ( -- series )	measure-# @ 1-	17 / ( -- N, which series are we in: 1= 5, 2=3, 3=1 )	CASE		1 OF 5-series  ENDOF		2 OF 3-series  ENDOF		3 OF 1-series  ENDOF	ENDCASE;\ search arp for nearest pitch to the incoming one and store it's arp index\   in "leaving-pitch": MARK.LEAVING.PITCH  { pitch | indx diff --  } 	ho_max_int -> diff		\ largest possible difference to start	many: arp  0  DO		i 3 ed.at: arp 		( -- replacement-flag )		NOT IF				\ If the pitch hasn't been replaced already...			pitch			i 1 ed.at: arp			- abs 			( -- abs-value of difference )			dup diff < 		\ is new difference less than old one			IF -> diff i -> indx			ELSE drop			THEN		THEN	LOOP	true indx 3  arp ed.to: []		\ set flag in arp	indx leaving-pitch-index !;: ADD.NEW.PITCH { | new-pitch np-index series -- }	measure-# @ 17 mod					\ which step in the series replacement?	dup	IF									\ do in reverse order (0 relative) and		17 swap -						\ deal with mod 0, i.e. last new pitch 	THEN								\   from current entering series	at: entry-order  -> np-index		\ use the result to lookup new index  	entering.series -> series							np-index 0  series  ed.at: []  dup  -> new-pitch	mark.leaving.pitch	np-index 1+  new-pitch  0  true 		np-index 1 series ed.at: []	np-index 2 series ed.at: []	np-index 3 series ed.at: []	( -- harm# pitch vol flag note fract cents )			entering-pitch-index @ put: arp		\ put entering pitch in arp;\ FIRST SECTION OF PIECE\ Expand arp by one each measure in first section.\ Pitches are added to the arp in entry-order from 1-series. \ When measure 17 comes around, the arp is expanded to 18 in\ length and the octave of the fundamental is added at low volume\ to serve as a place holder for the replacement pitches which will be \ entering beginning in the 18th measure...: DO.FIRST.ARP  { | arp-indx pitch-indx harm# -- }	measure-# @ dup	17 =							\ is this the last pitch of the first section?	IF 		17 entering-pitch-index !	\ (always in last position)		drop 18 set.many: arp		\ make room for entering pitch during replacement		1  0 at: 1-series  20 		\ 		true 		1 1 1-series ed.at: []		\ THIS IS A "FAKE" ENTRY TO MAKE SPACE FOR		1 2 1-series ed.at: []		\  PITCHES TO BE ADDED DURING THE NORMAL		1 3 1-series ed.at: []		\  ARP ALGORITHM		( -- harm# pitch vol flag note fract cents )				entering-pitch-index @  		put: arp					\ fill entering pitch spot until a "real" 	ELSE							\   new pitch enters in next measure		set.many: arp	THEN\ add a pitch from 1-series to the arp	measure-# @ 1- -> arp-indx		\ zero relative indexing into arpeggio!!	arp-indx at: entry-order -> pitch-indx	\ get index of new pitch to be											\ retrieved from 1-series										pitch-indx 1+ 					( -- harm# )	pitch-indx 0 ed.at: 1-series	( -- harm# pitch )							max-volume false  	pitch-indx 1 1-series ed.at: []			pitch-indx 2 1-series ed.at: []			pitch-indx 3 1-series ed.at: []		( -- harm# pitch vol flag note fract cents )		arp-indx put: arp;\ this is the standard arpeggio for the piece: DO.NORMAL.ARP  ( -- )	measure-# @ 17 mod		1 = 								\ first pitch of a new replacement sequence?	IF		false 3 fill.dim: arp			\ reset replacement flags	ELSE		entering-pitch-index @ get: arp	\ install new pitch on top of leaving pitch		leaving-pitch-index  @ put: arp	\   now that xfade is complete	THEN	add.new.pitch	calc.xfade	start: xfader;\ Becuase of the replacment that has been going on, 1-series\ is now installed fully into the arp, but not in entry order.\ This word re-orders the pitch information in the arp by simply\ grabbing the info from the 1-series tuning shape and stuffing it.: DO.LAST.ARP  ( -- )	measure-# @ ( if it's the beginning of the end, reorder shape )	69 = 	IF 		17 0 DO			i at: entry-order dup 1+ 			i 0 ed.to: arp		\ harm#			get: 1-series 				( -- pitch note fract cents )			i 6 ed.to: arp			i 5 ed.to: arp			i 4 ed.to: arp			0 3 fill.dim: arp			i 1 ed.to: arp		LOOP	cr tab ." Series on 1 arp reconfigured " cr	THEN	86 measure-# @ - set.many: arp;\ this one changes nature of arp: ARP-CHANGER.FUNCTION { job -- }	measure-# @ ?dup			\ dreadful kludge to deal with measure zero	IF								1- 17 / ( -- 0,1,2,3,4 )		CASE 0 OF DO.FIRST.ARP  ENDOF			 1 OF DO.NORMAL.ARP ENDOF			 2 OF DO.NORMAL.ARP ENDOF			 3 OF DO.NORMAL.ARP ENDOF			 4 OF DO.LAST.ARP   ENDOF	     		ENDCASE 	THEN	job set.done: [];( this job moves the piece thru the various measures.)( it changes the measure number at the appropriate time... ): HORN.TIMER-FUNCTION { job | ticks -- }	measure-# @  17 / 	CASE       0 OF measure-time  dup 			measure-# @ 36 swap - 13 */ swap wchoose ENDOF 		\ buildup	   1 OF measure-time  dup 			17	measure-# @ 17 mod - 3 / 13 + 13 */ swap wchoose ENDOF 	   2 OF measure-time  dup 11 13 */  wchoose ENDOF	   3 OF measure-time  dup 16 13 */ swap  wchoose ENDOF 	\ 1 series	   4 OF measure-time  dup 			measure-# @ 17 mod 15 + 13 */ swap wchoose ENDOF 	\ get longer	ENDCASE	-> ticks	ticks job put.duration: [] 						\ set new duration for job	ticks 60 / 	cr cr	tab ." MEASURE'S TIME IS: " .  cr 	 			\ this is for the performer to see 													\   on the screen 	1 measure-# +!	tab ." MEASURE # = " measure-# ? tab bell cr cr cr	ticks ticks/measure !;\ The arp-changer stop function; when it get called\ All of the performance jobs are stopped as well. \ It should be re-defined in jobs.fdefer END.PIECE: ohhhhhno { job -- }	." Defer PIECE ENDED!!!!";'c ohhhhhno is end.piece\ -------------------------------------------------------------------\ Initalization\ -------------------------------------------------------------------: SET.ENTRY.ORDER ( Ñ- )	16 12 10 13 6 14 9 4 8 11 5 2 15 7 3 1 0  ( psaltery order, 0 relative )  	17 0 DO		add: entry-order	LOOP;: INIT.ENTRY.ORDER ( Ñ- )	17 1 new: entry-order	set.entry.order;: INIT.ARP.SHAPE ( Ñ- )	18 7 new: arp 	( -- harm# pitch volume flag note fraction cents )	\ flag = true if already replaced	" HARM# " 0 put.dim.name: ARP	" PITCH " 1 put.dim.name: ARP	" VOLUME " 2 put.dim.name: ARP	" Flag " 3 put.dim.name: arp	" FBO1 Note" 4 put.dim.name: ARP	" FBO1 Fraction " 5 put.dim.name: ARP	" Cents " 6 put.dim.name: ARP;: INIT.ARP.CHANGER ( Ñ- )	2 new: ARP-CHANGER	'c horn.timer-function add: arp-changer	'c arp-changer.function add: arp-changer	85 put.repeat: arp-changer		\ set number of measures in piece	'c end.piece put.stop.function: arp-changer;: INIT.XFADER ( Ñ- )	1 new: xfader	'c xfade.func add: xfader;: INIT.ARP ( Ñ- )	cr ." Initalizing arpeggiation and pitch replacement" cr	init.entry.order	init.arp.shape	init.arp.changer	init.xfader;: TERM.ARP ( Ñ- )	free: entry-order	free: arp	free: arp-changer	free: xfader;if.forgotten term.arp