\ JOBS for HORN piece\ Composer: LP\ 2/17/90\ update 4/22/90\ 10/28/92  RDG  Begin port to DSPANEW TASK-HORN_JOBS\ OB.OBJLIST		DSP-JOBS	\ holds the jobs which play the DSP arpeggioOB.OBJLIST		FB-JOBS		\ holds the jobs which play the FB01 arpeggio5  VALUE DSP_VOLUME_OFFSET 	\ max volume for a note is 127....80 VALUE DENSITY_TWEAK 		\ the higher the value, the lower the densityV: note-#\ =============================================================\ 	PERFORMANCE JOBS \ =============================================================\ These are the jobs which actually play the piece.  They choose \ pitches from the master arpeggio that is constantly being \ modified by the code in arp.f, and determine volume and duration\ with all sorts of clever algorithms...false .if: DSP.ALLOC.JOBS	16 new: dsp-jobs	16 0 DO		instantiate ob.job		dup ( -- job job )		add: dsp-jobs ( -- job )		dup		10000000 swap put.repeat: []		\ each job has a variable start time		500 60 wchoose swap put.start.delay: []	LOOP;.then: FB.ALLOC.JOBS { | job -- }	16 new: fb-jobs	16 0 DO		instantiate ob.job dup -> job		add: fb-jobs ( -- job )		10000000 job put.repeat: []		\ each job has a variable start time		500 60 wchoose  job put.start.delay: []		\ data is used for MIDI channel		i 1+ job put.data: []	LOOP;false .if: DSP.TOAST.JOBS	many: dsp-jobs 0 DO		i at: dsp-jobs deinstantiate	LOOP	free: dsp-jobs;.then: FB.TOAST.JOBS	many: fb-jobs 0 DO		i at: fb-jobs deinstantiate	LOOP	free: fb-jobs;: PLAY.THIS.TIME?  ( -- ? )	\ First, a random chance that no note will be played... 	\ including a simple algorithm that makes it a little	\ more likely in the middle.	\ By changing these values, the 'activity' in different	\ sections of the piece can be finetuned...	measure-# @ 17 / 	\ to increase a section's density, lower its value in the case statement	CASE 		0 OF 0 ENDOF		1 OF 3 ENDOF		2 OF 8 ENDOF		3 OF 3 ENDOF		4 OF 0 ENDOF		5 OF 0 ENDOF  \ Only measure 85 case	ENDCASE	\ to make the piece denser, lower the value of density tweak	density_tweak + choose 70 <;		: GET.NOTE.DURATION   { pitch-index | harm# -- dur}\  this section determines the duration of the note, based on\  the harmonic series number, which series, and the overall tempo...	pitch-index 0 ed.at: arp  dup -> harm#  ( -- harm# )	17 swap - 					\ get inverse of harmonic series	60 * 						\ convert to seconds \ this next bit subtracts a bit from the tempo\ to make the piece a bit slower in the first and last 17 measures.. 	horn-tempo   	measure-# @ 17 < measure-# @ 68 >	or	IF		8 choose -	THEN\ the following is  a last minute kluge to slow the piece down in the middle a bit...\ subtracting a bit from the horn tempo sometimes... not nearly as much as the first\ and last sections...	5 choose 3 < IF		3 choose -	THEN	\ now divide the duration by the overall tempo...		/ 				( -- seconds/tempo )	harm# / 		( -- [seconds/tempo]/series# );	\ prevent really short durations: PREVENT.CLICKS  ( dur -- dur )	min_duration 2* min_duration wchoose	max;false .if: DSP-JOB.FUNCTION { job | pitch-index inst att dec dur sust -- }	job get.instrument: []	dup -> inst	off: []					\ save instrument address and turn it off		play.this.time?	IF		many: arp choose  -> pitch-index  \ pick pitch from arpeggio randomly		pitch-index 1 ed.at: arp 					inst  put.frequency: []				pitch-index 2 ed.at: arp 		choose			dsp_volume_offset + 200 max			inst put.volume: []					\ pick random volume between 0 and max		pitch-index  get.note.duration   		prevent.clicks	-> dur			( note duration goes from 20 to max )		\ this picks attacks and decays which could be each as long as 45% of the note's		\ duration		dur 45 100 */ choose		8 max		-> att		dur 45 100 */ choose		8 max		-> dec		dur att dec + - 		dup choose choose  -		-> sust				\ temp KLUDGE for dealing with attack and decay times		sust inst put.sustain: []			att inst put.attack: []		dec inst put.decay: []		att dec sust + + dur > 		IF ." ERROR: Envelope longer than duration " cr THEN\		dur 4 + job put.duration: []		\			inst on: []	THEN;.then\ These are the dimensions of the arp for memory's sake...\ harm# pitch/Hz volume flag note/midi fraction cents 	v: rand-var: FB-JOB.FUNCTION { job | pitch-index temp-pitch inst att dec dur sust note# fract vel -- }	play.this.time?		IF		\ reinforce the possibility of selecting the entering and leaving pitch....		100 choose rand-var !		rand-var @ 24 < 		measure-# @ 17 > 		measure-# @ 68 <		and 		and		IF			rand-var @ 17 >			IF				leaving-pitch-index @ -> pitch-index			ELSE				entering-pitch-index @ -> pitch-index			THEN		ELSE			many: arp choose  -> pitch-index  \ pick pitch from arpeggio randomly		THEN		job get.data: [] midi.channel!\ printing for csound						." i" midi-channel @ . tab		time@ start-piece @ - . tab		pitch-index  get.note.duration  prevent.clicks -> dur		\ now add a bit of jitter so that notes aren't always the same amount...		dur dur 12 100 */ choose + -> dur		dur . tab		pitch-index 1 ed.at: arp 		float 10.0 f/ 		fdup f>i -> temp-pitch		f. tab tab								\ this is all volume computation		\ if it's not equal to entering or leaving pitch, here's the general		\ volume computation				\ here just get what's in the arp!!!! (this is a fade in or out)		pitch-index 2 ed.at: arp		-> vel		\ the general volume level is this range...		\ this tests to make sure it's not one of the crossfaded pitches		pitch-index 		leaving-pitch-index @ = not		pitch-index 		entering-pitch-index @ = not		and 		IF			max-volume float 0.9 f* f>i			max-volume float 0.5 f* f>i 			wchoose			-> vel		THEN				\ an occasional accent for the incoming note!		pitch-index entering-pitch-index @ =		100 choose 20 < and		IF			max-volume			max-volume float 0.9 f* f>i wchoose			-> vel		THEN				\ if it's in the first 17 measures		measure-# @ 17 < 		IF			max-volume			17 measure-# @ -			0 min			1000 *			-			choose			-> vel		THEN				\ if it's in the last 17 measures		measure-# @ 68 >		IF			7 choose 5 < 			IF				max-volume 				measure-# @ 68 -				900 * abs				-				900 max				choose 				-> vel			ELSE				max-volume float 0.8 f* f>i 				choose				-> vel			THEN		THEN				\ check for zeros, and just make them really quiet		vel 0=		IF			500 choose			-> vel		THEN				vel . tab\ now print out the randomly jittered attack and decay times....		dur  1479 temp-pitch  - 7 /  160 + 55 wchoose 1000 */ 	min_duration 3 / max . tab		dur  1479 temp-pitch - 7 /  160 + 55 wchoose 1000 */ 	min_duration 3 / max . tab			cr	\		fb.start.events fb.fract.on				dur		job put.duration: []	\		1 note-#  +!	\		note-# @ 500 mod 0= IF tab tab note-# @ . tab time@ . cr THEN\		fb.stop.events	THEN;false .if: DSP.CONFIGURE.JOBS ( -- )	16 0 DO		1  i at: dsp-jobs ( -- job address )		new: []		'c dsp-job.function i at: dsp-jobs  add: []\ put instruments		instantiate ob.sine_instrument dup		\ make a new instance		load: []								\ stuff into DSP		i at: dsp-jobs  put.instrument: []		\ put in job	LOOP;.then: FB.CONFIGURE.JOBS ( -- )	16 0 DO		1  i at: fb-jobs new: []		'c fb-job.function i at: fb-jobs  add: []	LOOP;false .if: DSP.DECONFIGURE.JOBS ( -- )	many: dsp-jobs 0 DO		i at: dsp-jobs ( -- job address )		get.instrument: []		deinstantiate 	LOOP;.then: FB.DECONFIGURE.JOBS ( -- , included for parallelism's sake );: INIT.HORN.JOBS ( -- )	." Initalizing performance jobs" cr\	dsp.alloc.jobs\	dsp.configure.jobs	fb.alloc.jobs	fb.configure.jobs;: TERM.HORN.JOBS ( -- )\	dsp.deconfigure.jobs\	dsp.toast.jobs	fb.deconfigure.jobs	fb.toast.jobs;if.forgotten term.horn.jobs