\ Class of objects called TUNERS\ for tuning any scale\ HMSL Copyright 1986 - Phil Burk, Larry Polansky,\ and David Rosenboom\ All rights reserved\ Subclass of shapes with a lot of extra features\ Uses simple Amiga local sound as tuning\ author lp dec 21, 22, 1988anew task-tuner_class\ spare variablev: temp\ constant names for various dims in tuner0 constant frequency_dim1 constant period_dim2 constant cents(l)_dim3 constant cents(f)_dim4 constant numerator(f)_dim5 constant denominator(f)_dim6 constant coarse_numerator(f)_dim7 constant coarse_denominator(f)_dim8 constant coarse_ratio_deviation(f)_dim9 constant interval_rank_dim10 constant name_dim11 constant numerator(l)_dim12 constant denominator(l)_dim13 constant coarse_numerator(l)_dim14 constant coarse_denominator(l)_dim15 constant coarse_ratio_deviation(l)_dim\ method declarationsmethod put.fundamental-degree:method get.fundamental-degree:method put.fundamental-frequency:method get.fundamental-frequency:method get.current-note:method put.current-note:method get.current-index:method put.current-index:method play.note:method raise.note:method raise2.note:method lower.note:method lower2.note:method tune.note:method put.current-loudness:method get.current-loudness:method store.current-note:method compute.cents(f):method compute.cents(l):method compute.frequency:method tune.tuner:method lower.current-index:method raise.current-index:method play.scale:method get.noodle-tempo:method put.noodle-tempo:method put.noodle-random%:method get.noodle-random%:method noodle.note:method noodle:method period.stuff:method frequency.stuff:method play.interval:method name.stuff:method play.degree:method use.sine:method use.triangle:method use.sawtooth:\ Class definition:class   OB.TUNER   <super ob.shape	iv.long iv-fundamental-degree	iv.long iv-fundamental-frequency	iv.long iv-noodle-tempo	iv.long iv-noodle-random%	iv.long iv-current-note	iv.long iv-current-loudness	iv.long iv-current-index\ Usage: Name.Stuff: object, and will ask for (1-digit) names\ for each scale degree. Typically, numbers, letters, etc.:m NAME.STUFF:	many: self 0	DO 		cr i 1+ ." name element #" . ." : " key		dup emit		i name_dim ed.to: self	LOOP	cr cr ." Names of the elements are: "	cr tab	many: self 0	DO		i name_dim ed.at: self		emit 2 spaces	LOOP;m\ Like usual stuff for elements class, a way\ to set up a tuner with some periods		:m PERIOD.STUFF: ( pn pn-1 pn-2 ....p1 N --- )	0 DO 		i period_dim ed.to: self	LOOP;m\ More useful than period.stuff:, and used as\ in elements class. For example, if want to hear,\ and measure a tuning already known in hertz, this\ is the word to use:m FREQUENCY.STUFF: ( fn fn-1 fn-2 .... f1 N --- )	0 DO		i frequency_dim ed.to: self	LOOP;m\ methods for storing and retrieving  fundamental scale degree and/or frequency:m PUT.FUNDAMENTAL-DEGREE:  ( scale-degree -- )	iv=> iv-fundamental-degree;m:m PUT.FUNDAMENTAL-FREQUENCY:  ( freq -- )	iv=> iv-fundamental-frequency;m:m GET.FUNDAMENTAL-DEGREE:  ( -- scale-degree )	iv-fundamental-degree;m\ Returns frequency always. If no fundamental frequency is\ given, for example, one that is outside the scale,\ this word gets the fundamental frequency from the fundamental\ degree, which, by default, is 0:m GET.FUNDAMENTAL-FREQUENCY:  ( --  freq )	iv-fundamental-frequency dup 0=	IF drop get.fundamental-degree: self	   frequency_dim ed.at: self	THEN;m\ methods for storing and retrieving current-note for tuning purposes\ current-note if mostly for internal use by the tuning program,\ it can be anything:m GET.CURRENT-NOTE:  ( -- n )	iv-current-note;m:m PUT.CURRENT-NOTE: ( n -- )	iv=> iv-current-note;m\ methods for storing and retrieving current-index\ mostly for internal use by the tuning program.:m GET.CURRENT-INDEX:  ( -- n )	iv-current-index;m:m PUT.CURRENT-INDEX: ( n -- )	iv=> iv-current-index;m\ Methods for picking new waveforms:M USE.SINE:		0 da.channel!	da_sine da.wave!	3 da.channel!	da_sine da.wave!;m:M USE.TRIANGLE:		0 da.channel!	da_triangle da.wave!	3 da.channel!	da_triangle da.wave!;m:M USE.SAWTOOTH:		0 da.channel!	da_sawtooth da.wave!	3 da.channel!	da_sawtooth da.wave!;m\ for use by the tuning program. simple note sounding routine:m PLAY.NOTE:  ( -- )	0 da.channel!	iv-current-loudness da.loudness!	iv-current-note da.period!	da.start;m\ Hear one note from tuning:m PLAY.DEGREE: ( scale-degree -- play that note )	cr ." Playing note: " dup name_dim ed.at: self emit	period_dim ed.at: self	put.current-note: self	play.note: self	1000 msec da.stop;m	\ Methods used by the tuning program for altering pitch\ Note that default ratios for large jumps are 8/7 's:m RAISE.NOTE: ( -- )	get.current-note: self	1 - put.current-note: self;m:m RAISE2.NOTE: ( -- )	get.current-note: self	7 8 */ put.current-note: self;m:m LOWER.NOTE: ( -- )	get.current-note: self	1 +  put.current-note: self;m:m LOWER2.NOTE: ( -- )	get.current-note: self	8 7 */ put.current-note: self;m\ Index lowering and raising for the tuning program:m LOWER.CURRENT-INDEX:	get.current-index: self	1- dup 0< IF drop 0 THEN	dup	put.current-index: self	." Tuning degree: " . cr	." Note: " get.current-index: self name_dim ed.at: self emit cr;m:m RAISE.CURRENT-INDEX:	get.current-index: self	1+ dup 	many: self = IF drop many: self 1- THEN	dup	put.current-index: self	." Tuning degree: " . cr	." Note: " get.current-index: self name_dim ed.at: self emit cr;m\ For use by the tuning program, saves current note\ at current index:m STORE.CURRENT-NOTE:	iv-current-note	iv-current-index	period_dim ed.to: self	tab ." Stored degree: " iv-current-index . cr	tab ." Note: " get.current-index: self name_dim ed.at: self emit cr;m	: PRINT.HELP	cr cr 	tab ." 'h': higher  a little " cr	tab ." 'H': higher   a lot   " cr	tab ." 'l' lowers a little " cr	tab ." 'L' lowers a lot " cr	tab ." 'S' or 's' stores the current pitch at current degree " cr	tab ." 'Q' or 'q' exits the program " cr	tab ." 'N' or 'n' advances one degree " cr	tab ." 'P' or 'p' moves back one degree " cr cr;\ Large tuning routine, big case statement	:m TUNE.NOTE:	cr cr tab ." Type  '?' for list of commands "	cr cr	false temp !	play.note: self	BEGIN		key 		CASE 			104 of raise.note:   self else \ h			72  of raise2.note:  self else \ H			108 of lower.note:   self else \ l			76  of lower2.note:  self else \ L			113 of true temp !        else \ q			81  of true temp !        else \ Q			27  of true temp !        else \ esc			115 of store.current-note: self else  \ s			3   of store.current-note: self else  \ S			112 of lower.current-index: self else \ p			110 of raise.current-index: self else \ n			80  of lower.current-index: self else \ P			78  of raise.current-index: self else \ N			63  of print.help else \ ?		drop		ENDCASE		play.note: self		temp @	UNTIL	da.stop;m\ Methods for loudness		:m PUT.CURRENT-LOUDNESS: ( n -- )	iv=> iv-current-loudness	;m:m GET.CURRENT-LOUDNESS: ( -- n )	iv-current-loudness ;m\ Methods for setting tempo for scale playing and for noodling:m GET.NOODLE-TEMPO:	iv-noodle-tempo;m:m PUT.NOODLE-TEMPO:	iv=> iv-noodle-tempo;m\ Set a random deviation, as percent of tempo, for durations in\ noodling and scale playing:m GET.NOODLE-RANDOM%:	iv-noodle-random%;m:m PUT.NOODLE-RANDOM%:	iv=> iv-noodle-random%;m			:m INIT:		init: super	0 put.fundamental-degree: self	0 put.fundamental-frequency: self	64 put.current-loudness: self	200 put.noodle-tempo: self	500 put.current-note: self	use.sine: self	;m:m NEW:  ( n -- n x 16 dims )	dup	16 NEW: super	set.many: self;m\ Computations for frequency, and cents:m COMPUTE.FREQUENCY:	many: self 0 	DO		i period_dim ed.at: self		da.sample@ swap drop da.fl->p		i frequency_dim ed.to: self	LOOP;m:m COMPUTE.CENTS(F):	many: self 0 	DO		i frequency_dim ed.at: self		get.fundamental-frequency: self				ratio->cents ( -- cents ) 		abs		i cents(f)_dim ed.to: self	LOOP;m:m COMPUTE.CENTS(L):	many: self 1 	DO		i frequency_dim ed.at: self		i 1- frequency_dim ed.at: self		ratio->cents  abs		i cents(l)_dim ed.to: self	LOOP;m		\ Print statement, all computation done here:m PRINT: ( completely new print statement )	compute.frequency: self	compute.cents(l): self	compute.cents(f): self	cr cr 	name: self cr	tab ." Fundamental frequency is:  " get.fundamental-frequency: self .	cr	tab ." Fundamental degree is:     " get.fundamental-degree: self .	cr cr	." # " tab ." Name " tab	." Freq. " tab ." Per."  tab ." cnts(f)" tab  ." cnts(L)"	cr cr	many: self 0 	DO		i . tab 		i name_dim ed.at: self emit tab		i frequency_dim ed.at: self . tab		i period_dim ed.at: self . tab		i cents(f)_dim ed.at: self . tab tab		i cents(l)_dim ed.at: self . tab		cr	LOOP;m\ Noodle and play scale and interval routines:m NOODLE.NOTE: ( index -- , plays note )		cr		dup name_dim ed.at: self emit 2 spaces		period_dim ed.at: self		da.period!		get.current-loudness: self		da.loudness!		da.start		get.noodle-tempo: self		dup get.noodle-random%: self		choose		100 */ 		+ msec		da.stop	;m:m PLAY.SCALE:	many: self 0	DO		i noodle.note: self	LOOP	500 msec	many: self 0 	DO 		many: self 1- i - noodle.note: self	LOOP;mv: prev-note\ 70 percent chance of scalar motion:m NOODLE: 	cr	0 prev-note !	BEGIN		100 choose 300 < 		IF			many: self choose 		ELSE			prev-note @				2 choose 0 = IF 1- ELSE 1+ THEN			many: self mod abs		THEN dup prev-note !		noodle.note: self		?terminal	UNTIL;m:m PLAY.INTERVAL: ( deg1 deg2 --- )	2dup	." Playing notes: cr tab " name_dim ed.at: self .	."  and " name_dim ed.at: self . cr	\ set up for channels 0 and 3, for non-stereo speaker	0 da.channel!	63 da.loudness!	period_dim ed.at: self 	da.period! da.start	3 da.channel!	63 da.loudness! period_dim ed.at: self 	da.period! da.start	BEGIN		?terminal	UNTIL	3 da.channel! da.stop	0 da.channel! da.stop	;m							;class\ set up simple tuner, 7 longob.tuner my-tuner: SETUP.MY-TUNER	7 new: my-tuner	800 1000 1200 1340 1500 1800 2000 7 period.stuff: my-tuner;setup.my-tuner