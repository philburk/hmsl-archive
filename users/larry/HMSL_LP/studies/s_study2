\ Study #2\ lp\ 5/24/90\ play one melody; try to continually match that melody's contour;\ the more the contour is matched, make a chord contract into\ unsion; change rate of repeated chords so that they contract\ variation of study1anew task-s_study2ob.radio.grid study2-checkob.objlist s2-jobsob.collection study2-collectionv: curr-metric: INPUT.CHORD-RATE	." For STUDY2, input average rate of 6-part chord repetition: "	cr tab ." (in 60ths of a second): "  input#	IF chord-rate ! ELSE 30 chord-rate ! THEN;: FMAJ7 ( fundamental -- new-fund ) 	4 choose	CASE		0 of 0 + ENDOF		1 of 4 + endof		2 of 7 + endof		3 of 11 + endof	ENDCASE;: CDOM9b5 ( fundamental -- new-fund )	6 choose	CASE		0 of 7 + endof		1 of 1 - endof		2 of 2 + endof		3 of 5 + endof		4 of 9 + endof		5 of 13 + endof	ENDCASE;: PICK.NEW.FUNDAMENTAL ( -- )	chord-fundamental @	curr-metric @ 100 / choose	CASE		0 of  fmaj7  endof  \ f, a, c, e		1 of  2 +   endof  \ g 		2 of  14 +   endof  \ g		3 of  cdom9b5  endof   \ Bb		4 of 7 -    endof   \ Bb		5 of  1+  endof   \ F#		6 of  5 +  endof		7 of  5 -  endof		8 of  5 -  endof		9 of  1 -  endof		10 of  3 +  endof	ENDCASE;	: S2-JOB.FUNCTION { curr-job -- }	midi-channel @ >r	curr-job get.data: []	midi.channel!	pick.new.fundamental	90 60 wchoose 20 midi.noteon.for	r> midi.channel!	chord-rate @	curr-metric @ 100 / 2* choose		+ 	curr-job put.duration: [];	: BUILD.S2-JOBS { | curr-job -- }	6 new: s2-jobs	6 new: study2-collection	60 48 wchoose chord-fundamental !	6 0 DO		instantiate ob.job			add: s2-jobs	LOOP	6 0 DO		i at: s2-jobs		dup add: study2-collection		-> curr-job		1 curr-job new: []		i chord-channel @ + curr-job put.data: []		chord-rate @ curr-job put.duration: []		'c s2-job.function curr-job add: []	LOOP;: STUDY2.RECORD	empty: s-s-1	s-s-1 record.wait;: STUDY2.STOP 	time@ record.stop	empty: s-m-1	s-s-1 s-m-1 sh.compress.notes	shortest-note @ deglitch: s-t-1	many: s-m-1 cr cr	tab ." #notes to target (after deglitch): " . cr\ now take a metric...	many: s-m-1 \ input shape	many: s-t-1 \ shape to compare it to	min \ take smaller value...	dup set.many: s-m-1	set.many: s-t-1	1 put.curr-dim: s-m-1	1 put.curr-dim: s-t-1	s-m-1 ocd: s-t-1	curr-metric !	curr-metric @ 0 put.value: s-metric-value	draw: s-metric-value	cr 	tab ." Metric (OCD) value:   " curr-metric @ .  	start: study2-collection;	: STUDY2.FUNCTION ( value part -- )	swap drop	CASE		0 of study2.record endof		1 of study2.stop endof	ENDCASE;	: BUILD.STUDY2.CONTROLS	1 2 new: study2-check	500 500 put.wh: study2-check	0 0 put.value: study2-check	stuff{ " Rec " " Stop " }stuff.text: study2-check	" Input melody (S2) " put.title: study2-check	study2-check 1400 500 add: study-screen	'c study2.function put.down.function: study2-check;	: INIT.STUDY2	free: s-player-1	1 new: s-player-1	s-t-1 add: s-player-1		1 put.repeat: s-player-1;: TERM.STUDY2	free: study2-check	study2-check remove: study-screen;: DO.STUDY2	input.chord-rate	init.study2	build.study2.controls	input.study.chord	input.study.melody	build.s2-jobs	HMSL	midi.killall	term.study2;