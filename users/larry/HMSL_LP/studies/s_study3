\ Study #3\ lp\ 5/24/90\ play one melody; try to continually match that melody's contour;\ the more the contour is matched, \ the four melodies being mutated contract into one melody\ variation of #1 and #2anew task-s_study3ob.radio.grid study3-checkob.objlist s3-playersob.objlist s3-shapesob.objlist s3-instrumentsob.collection s3-collectionob.mutator s3-sourceob.objlist s3-sources\ utilities for inputting information...	: INPUT.STUDY3.MELODIES	cr ." What channel should six channels of melodies start on? "	cr ." (needs four channels, starting with this): "	input# 		IF chord-channel !		ELSE ." not a valid channel !!!! "			." (channel 2 selected...) " cr		2 chord-channel !		THEN;\ fill pitches with ascending scale...: STUFF.SOURCE.MELODY	30 set.many: s3-source	30 0 DO		i 40 + i 1 ed.to: s3-source			8 4 wchoose i 0 ed.to: s3-source		90 30 wchoose i 2 ed.to: s3-source	LOOP;\ prefab the source melody, access it later through the shape holder...: BUILD.SOURCE.MELODY	1 put.curr-dim: s3-source	30 3 new: s3-source	stuff.source.melody	s3-source add: shape-holder;: BUILD.S3-PLAYERS	6 new: s3-players	6 new: s3-shapes	6 new: s3-collection	6 new: s3-instruments	6 new: s3-sources	6 0 DO		instantiate ob.midi.instrument			add: s3-instruments		instantiate ob.mutator			add: s3-shapes		instantiate ob.player			add: s3-players		instantiate ob.mutator			add: s3-sources	LOOP	6 0 DO\ shapes....		30 3 i at: s3-shapes new: []		1 i at: s3-shapes put.curr-dim: []		30 3 i at: s3-sources new: []		1 i at: s3-sources put.curr-dim: []		\ stuff these in with random data...		30 0 DO			15 2 wchoose			72 40 wchoose			100 40 wchoose 			j at: s3-sources			add: []		LOOP\ instruments		i chord-channel @ + 		i at: s3-instruments		put.channel: []		36 12 choose + i at: s3-instruments		put.offset: []\ players			0 i at: s3-players put.repeat.delay: []		150 i at: s3-players put.repeat: []		1 i at: s3-players new: []		i at: s3-shapes		i at: s3-instruments		i at: s3-players build: []\ collection		i at: s3-players add: s3-collection			LOOP;: STUDY3.RECORD	empty: s-s-1	s-s-1 record.wait;: STUDY3.STOP 	time@ record.stop	empty: s-m-1	s-s-1 s-m-1 sh.compress.notes	shortest-note @ deglitch: s-t-1	many: s-m-1 cr cr	tab ." #notes recorded to target: " . cr\ now take a metric...	many: s-m-1 \ input shape	many: s-t-1 \ shape to compare it to	min \ take smaller value...	dup set.many: s-m-1	set.many: s-t-1	1 put.curr-dim: s-m-1	1 put.curr-dim: s-t-1	s-m-1 ocd: s-t-1	curr-metric !	curr-metric @ 0 put.value: s-metric-value	draw: s-metric-value	cr 	tab ." Metric (OCD) value:: " curr-metric @ .\ now permute the shapes...	6 0 DO		i at: s3-shapes s3-source clone: []		1 i at: s3-shapes put.curr-dim: []		1 i at: s3-sources put.curr-dim: []		curr-metric @ curr-metric @ 2/ wchoose		i at: s3-shapes put.mutation-degree: []		i at: s3-sources		i at: s3-shapes			mutate.partial.olm.signed: []\ now do repeat delays		curr-metric @ 15 / choose 		i at: s3-players put.repeat.delay: []	LOOP	start: s3-collection;	: STUDY3.FUNCTION ( value part -- )	swap drop	CASE		0 of study3.record endof		1 of study3.stop endof	ENDCASE;	: BUILD.STUDY3.CONTROLS	1 2 new: study3-check	500 500 put.wh: study3-check	0 0 put.value: study3-check	stuff{ " Rec " " Stop " }stuff.text: study3-check	" Input melody (s3) " put.title: study3-check	study3-check 1400 500 add: study-screen	'c study3.function put.down.function: study3-check;	: INIT.STUDY3	s3-source add: shape-holder	free: s-player-1	1 new: s-player-1	s-t-1 add: s-player-1		1 put.repeat: s-player-1;: TERM.STUDY3	clear: shape-holder	free: s3-collection	free: study3-check	freeall: s3-players	free: s3-players	freeall: s3-shapes	free: s3-shapes	free: s3-source	study3-check remove: study-screen;: (DO.STUDY3)	build.source.melody	input.study3.melodies	input.study.melody	init.study3	build.study3.controls	build.s3-players;: Do.STUDY3	(do.study3)	HMSL	midi.killall	term.study3;