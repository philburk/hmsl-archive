\ Study #1\ lp\ 5/24/90\ play one melody; try to continually match that melody's contour;\ the more the contour is matched, make a chord contract into\ unsionanew task-s_study1		: START.CHORD	cr cr	tab ." Six part chord is being played on MIDI-CHANNEL " 	chord-channel @	.  cr	72 60 wchoose chord-fundamental !	chord-channel @ 6 + chord-channel @	DO		i midi.channel!		chord-fundamental @ 90 60 wchoose midi.noteon		[ hex ]		3fff choose midi.bend		[ decimal ]		1000 200 wchoose msec	LOOP;: STUDY1.RECORD	empty: s-s-1	s-s-1 record.wait;: STUDY1.STOP { | curr-metric -- }	time@ record.stop	empty: s-m-1	s-s-1 s-m-1 sh.compress.notes	shortest-note @ deglitch: s-m-1	many: s-m-1 cr cr	tab ." # notes to target (after deglitch): " . cr\ now take a metric...	many: s-m-1 \ input shape	many: s-t-1 \ shape to compare it to	min \ take smaller value...	dup set.many: s-m-1	set.many: s-t-1	1 put.curr-dim: s-m-1	1 put.curr-dim: s-t-1	s-m-1 ocd: s-t-1	-> curr-metric	curr-metric 0 put.value: s-metric-value	draw: s-metric-value	cr 	tab ."  Metric (OCD):   " curr-metric . cr  	chord-channel @ 6 + chord-channel @	DO		i midi.channel!		curr-metric 16 *		choose midi.bend		1000 200 wchoose msec	LOOP;	: STUDY1.FUNCTION ( value part -- )	swap drop	CASE		0 of study1.record endof		1 of study1.stop endof	ENDCASE;	: BUILD.STUDY1.CONTROLS	1 2 new: study1-check	500 500 put.wh: study1-check	0 0 put.value: study1-check	stuff{ " Rec " " Stop " }stuff.text: study1-check	" Target melody (S1) " put.title: study1-check	study1-check 1400 500 add: study-screen	'c study1.function put.down.function: study1-check;	: INIT.STUDY1	free: s-player-1	1 new: s-player-1	s-t-1 add: s-player-1		1 put.repeat: s-player-1;: TERM.STUDY1	free: study1-check	study1-check remove: study-screen;: DO.STUDY1	init.study1	build.study1.controls	input.study.chord	input.study.melody	start.chord	HMSL	midi.killall	term.study1;