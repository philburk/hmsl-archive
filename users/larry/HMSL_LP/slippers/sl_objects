\ Slippers of Steel\ authors: Didkovsky, Polansky\ 4/26/91\ last rev: 4/26/91\ Full name of piece:\ There is more headroom but one's feet are forced into slippers of steel.\ from THE TIME IS NOW, by Melody Sumneranew task-sl_objects\ this is defined in lp_util, but redefined here...: ADD.RANGE ( range -- value , value to add )	dup choose swap 2/ -;\ **************\ define s-data\ it contains current data for cross-machine communication\ and at any given point, it contains the ranges and means for \ parameters in a layer\ four elements are: s_start, s_end, my current, his current\ ten dimensions are:\ Pitch mean, pitch range, loudness mean, loudness range,\ vertical density mean, vertical density range, \ horizontal density mean, horizontal density range, legato mean, legato range\ weight of the collection tells you what mode it is currently in\ 0= imitate, 1 = opppose, 2= independent\ data field of the collection tells you how long it is going to last: PICK.INTERPOLATOR	10 choose 7 < 	IF		'c set.cos.interp is ..curr-set-interp		'c cos.interp is ..curr-interp\		." using cosine interpolator" cr	ELSE		'c set.interp is ..curr-set-interp		'c interp is ..curr-interp\		." using linear interpolator" cr	THEN;: PRINT.MY_CURR	dimension: s-data 0		DO			my_curr i ed.at: s-data .		LOOP		cr;\ some protection words for s-data, first protect the input: PUT.PITCH_MEAN ( value -- , stores in curr_data )	0 127 clipto my_curr pitch_mean ed.to: s-data;: PUT.PITCH_RANGE ( value -- , stores in curr_data )		0 200 clipto my_curr pitch_range ed.to: s-data;: PUT.VEL_MEAN ( value -- , stores in curr_data )	0 127 clipto my_curr vel_mean ed.to: s-data;: PUT.VEL_RANGE ( value -- , stores in curr_data )		0 200 clipto my_curr vel_range ed.to: s-data;: PUT.HD_MEAN ( value -- , stores in curr_data )	0 200 clipto my_curr hd_mean ed.to: s-data;: PUT.HD_RANGE ( value -- , stores in curr_data )	0 200 clipto my_curr hd_range ed.to: s-data;: PUT.VD_MEAN ( value -- , stores in curr_data )	0 200 clipto my_curr vd_mean ed.to: s-data;: PUT.VD_RANGE ( value -- , stores in curr_data )	0 200 clipto my_curr vd_range ed.to: s-data;: PUT.LEG_MEAN ( value -- , stores in curr_data )	0 200 clipto my_curr leg_mean ed.to: s-data; : PUT.LEG_RANGE ( value -- , stores in curr_data )	0 200 clipto my_curr leg_range ed.to: s-data;\ now protect the getting of data and combining that with add.range\ nick has in sl_user_nick, these words are broken up into\ two functions....: GET.PITCH  ( -- pitch, adjusted to have range...)	my_curr pitch_mean ed.at: s-data 	\ 0 127 clipto	my_curr pitch_range ed.at: s-data 	\ 0 127 clipto	add.range +  	0 127 clipto;: GET.VEL  ( -- vel, adjusted to have range...)	my_curr vel_mean ed.at: s-data \ 0 127 clipto	my_curr vel_range ed.at: s-data \ 0 127 clipto	add.range +  	0 120 clipto;: GET.HD  ( -- HD, adjusted to have range...)	my_curr HD_mean ed.at: s-data \ 0 120 clipto	my_curr HD_range ed.at: s-data \  0 120 clipto	add.range +  	0 120 clipto \	dup ." HD is.... " . cr	;: GET.VD  ( -- VD, adjusted to have range...)	my_curr VD_mean ed.at: s-data \ 0 16 clipto	my_curr VD_range ed.at: s-data \ 0 16 clipto	add.range +  	0 16 clipto;: GET.LEG  ( -- LEG, adjusted to have range...)	my_curr LEG_mean ed.at: s-data \ 0 16 clipto	my_curr LEG_range ed.at: s-data \ 0 12 clipto	add.range +  	0 120 clipto;\ ************: MOVE.HIS.TO.MINE ( -- , copy values for element 3 to element 2)  dimension: s-data 0 	DO	his_curr i ed.at: s-data	my_curr i ed.to: s-data  LOOP;:	MOVE.START.TO.CURR	dimension: s-data 0 	DO		s_start i ed.at: s-data		my_curr i ed.to: s-data	LOOP;				: INIT.S-DATA	4 10 new: s-data 	\ names of elements	" Start data " 0 put.dim.name: s-data	" End data " 1 put.dim.name: s-data	" My current " 2 put.dim.name: s-data	" His current " 3 put.dim.name: s-data	4 0 DO			110 36 wchoose 24 choose \ pitch			127 10 wchoose 20 choose \ loudness			12 choose 1+ 3 choose \ vertical density			45 8 wchoose 12 choose \ horizontal density			120 30 wchoose 30 choose \ legato mean and range			add: s-data 	LOOP	pick.interpolator	get.weight: c-layers		CASE			imitate of move.his.to.mine endof			oppose of move.his.to.mine ..oppose.function endof			independent of move.start.to.curr endof		ENDCASE	print.my_curr;\ ********\ functions and init for c-layers\ C-LAYERS\ this next block of code is common to starting and repeating a c-layers: C-LAYERS.START.REPEAT.COM { coll -- }\ first pick a mode and print it out to screen	3 choose 	coll put.weight: [] \ this sets the mode for a layer	coll get.weight: []	CASE		imitate of ." (imitate mode) " cr endof		oppose of ." (opposition mode) " cr endof		independent of ." (independent mode) " cr endof	ENDCASE\ now pick a length for the individual layer	layer-longest @ layer-shortest @ wchoose 	coll put.data: [] \ data is used for time of the layer	cr\	tab ." This layer is " \	coll get.data: [] 60 / . ." seconds long " cr\ put that total time in the timeout job	coll get.data: [] 	put.start.delay: j-timeout\ now pick a repeat delay\ repeat silences are about a golden mean shorter than layers...	layer-longest @ 13 21 */ layer-shortest @ 13 21 */ wchoose 	coll put.repeat.delay: [] \	cr tab\	." This layer has a repeat delay of " \	coll get.repeat.delay: [] 60 / . ." seconds long " cr\ this word has to be written by both users...	..stuff.user-collection\	init.s-data\  Interpolating job's counter is stored in its data field.\ It is incremented by the duration of the job every time the job fires,\ and used as the x value of the interp function  0 put.data: j-interpolator;: CHANGE.TO.HITS? ( -- flag )	100 choose change-to-hits-prob @  < 	IF		cr cr cr tab tab		." CHANGING TO HITS !!!!!! " 		cr cr cr		true	ELSE		false	THEN;: START.C-LAYERS { coll -- }	." starting c-layers " cr	..shut.up.dep-5	coll c-layers.start.repeat.com;  : REPEAT.C-LAYERS { coll -- }	change.to.hits? not	IF		coll c-layers.start.repeat.com	ELSE		stop: c-layers-section \ stop my layers		rtc.time@ vtime!		send.hits  \ change him too...	THEN;: INIT.C-LAYERS ( -- )\ put in objects	layer-longest @ layer-shortest @ wchoose	put.start.delay: c-layers	act.parallel: c-layers	3 new: c-layers	j-timeout add: c-layers	user-collection add: c-layers	j-interpolator add: c-layers\ setup c-layers		independent put.weight: c-layers \ starts out independent	'c start.c-layers put.start.function: c-layers	'c repeat.c-layers put.repeat.function: c-layers	10000 put.repeat: c-layers	;\ *************\ C-LAYERS-SECTION: INIT.C-LAYERS-SECTION	act.parallel: c-layers-section	3 new: c-layers-section  	c-layers add: c-layers-section	j-guitar-commands add: c-layers-section	j-snapshot add: c-layers-section;\ ********************\ j-timeout: J-TIMEOUT.FUNCTION\	." j-timeout killing one layer " cr	stop: []	stop: user-collection	stop: j-interpolator;			: INIT.J-TIMEOUT	1 new: j-timeout	'c j-timeout.function add: j-timeout;\ ******************\ interpolator functions\ Interpolate new s-data.  X values of interpolator are 0 and duration of layer\ Y values of interpolator are start/stop values stored in s-data.\  The x value sent to interp function is derived from the relationship\ of the duration of the repeating interpolating job divided into the duration\ of the layer itself.\ (layer-duration)/(job-duration) = #times the job will fire, stored in job's weight.\ The job's data is used to accumulate the x value, adding the job's duration every time\ the job fires.: INTERPOLATE.S-DATA ( -- )  dimension: s-data 0 	DO        0 s_start i ed.at: s-data	( -- 0 y1)  		get.data: c-layers 		s_end i ed.at: s-data ( -- 0 y1 x2 y2, x2 is duration of layer)		..curr-set-interp		get.data: j-interpolator ..curr-interp	( -- newval)		my_curr i ed.to: s-data				( -- , store in mydata field)	 LOOP 	 interp-dur @ get.data: j-interpolator + put.data: j-interpolator ;\ j-interpolator: J-INTERPOLATOR.FUNCTION ( job -- )	drop	get.weight: c-layers	CASE		imitate of move.his.to.mine endof		oppose of move.his.to.mine ..oppose.function  endof		independent of interpolate.s-data endof	ENDCASE\	my_curr pitch_mean ed.at: s-data .\	my_curr vel_mean ed.at: s-data .\	my_curr hd_mean ed.at: s-data . cr;		: INIT.J-INTERPOLATOR	1 new: j-INTERPOLATOR	'c j-interpolator.function add: j-interpolator	interp-dur @ put.duration: j-interpolator	0 put.data: j-interpolator;\ ********\ HITS\ ********: CHANGE.TO.LAYERS? ( -- flag )	100 choose change-to-layers-prob @  <	IF		cr cr cr tab tab		." CHANGING TO LAYERS !!!!!! "		cr cr cr		true	ELSE		false	THEN;: C-HIT.START.REPEAT.COM { coll -- }	highest-hit-rate @ lowest-hit-rate @ wchoose	coll put.repeat.delay: []	..stuff.user-hit;	: C-HIT.REPEAT.FUNCTION { coll -- }	change.to.layers? not 	IF 	\	." repeating c-hit " cr		coll c-hit.start.repeat.com	ELSE		stop: c-hit		rtc.time@ vtime!		send.layers	THEN;: C-HIT.START.FUNCTION { coll -- }\	." starting c-hit " cr	coll c-hit.start.repeat.com;\ this happens every time user hit, don't change this!!!!!: J-SEND.A.HIT.FUNCTION { job -- }	job set.done: []	send.a.hit\ big note: larry has to insert changing dep output in his word for hit.dep-5!!	..hit.dep-5;: INIT.J-SEND.A.HIT	1 new: j-send.a.hit	1 put.duration: j-send.a.hit	'c j-send.a.hit.function add: j-send.a.hit;\ this guy does all the timing of hits... you just supply\ the hitters in user-hit: INIT.C-HIT	300 60 wchoose put.start.delay: c-hit	'c c-hit.start.function put.start.function: c-hit	'c c-hit.repeat.function put.repeat.function: c-hit	act.sequential: c-hit	2 new: c-hit\	300 hit-delay-time ! ( emergency measure )	hit-delay-time @ put.start.delay: user-hit	\ USAH DON'T CHANGE THIS!!!	j-send.a.hit add: c-hit ( communication and dep )	user-hit add: c-hit	10000 put.repeat: c-hit;: STOP.C-SLIPPERS 	drop	cr cr cr cr cr tab tab	10 0 DO		." DONE DONE DONE " cr	LOOP;		: INIT.C-SLIPPERS	2 new: c-slippers	act.sequential: c-slippers	c-layers-section add: c-slippers	c-hit add: c-slippers	slippers-repeats @ put.repeat: c-slippers	'c stop.c-slippers put.stop.function: c-slippers;\ snapshot job: J-SNAPSHOT.FUNC { job -- }	 send.data;: INIT.J-SNAPSHOT	1 new: j-snapshot	'c j-snapshot.func add: j-snapshot	snapshot-rate @ put.duration: j-snapshot;	: GUITAR.HEADLINE	 tab  ." GUITAR:   " ;: PICK.J-GUITAR-COMMANDS	guitar.headline	5 choose		CASE			0 of	." cease to play "	endof			1 of	." STOP "			endof			2 of	." IMITATE "		endof			3 of	." OPPOSE "			endof			4 of	." INDEPENDENT "	endof		ENDCASE	cr;			: J-GUITAR-COMMANDS.FUNC { job -- }	layer-longest @ layer-shortest @ wchoose 	job put.duration: []	pick.j-guitar-commands;: INIT.J-GUITAR-COMMANDS	1 new: j-guitar-commands	layer-longest @ layer-shortest @ wchoose 	put.duration: j-guitar-commands	'c j-guitar-commands.func add: j-guitar-commands;\ !!!!!!!!!!!!!!!!!!!!\ SAMPLES OF USER CODE\ *********************************\ sample user-collectionob.job sample-user-coll-job: SAMPLE-USER-COLL-JOB.FUNC { curr-job -- }	1 midi.channel!\	30 choose midi.preset\	midi.lastoff	get.hd	curr-job put.duration: []	get.pitch	get.vel\	midi.noteon	get.leg	midi.noteon.for;: INIT.SAMPLE-USER-COLL-JOB	3 put.start.delay: sample-user-coll-job	1 new: sample-user-coll-job	'c sample-user-coll-job.func add: sample-user-coll-job;: INIT.SAMPLE-USER-COLL	init.sample-user-coll-job	\ user is repsonsible for doing this new on user-collection	1 new: user-collection	sample-user-coll-job add: user-collection;'c init.sample-user-coll is ..stuff.user-collectioninit.sample-user-coll\ *******************\ sample user-hitterob.job j-sample-hitter: SAMPLE.HIT.DEP-5	." send dep " cr 	16 midi.channel!	100 choose 1+ midi.preset;: REVERB.DEP-5 ( -- )  16 midi.channel!  42 midi.preset;'c sample.hit.dep-5 is ..hit.dep-5'c reverb.dep-5 is ..shut.up.dep-5v: hi-hitv: lo-hit: J-SAMPLE-HITTER.FUNCTION { job -- }	."  hit " cr	job set.done: []\    midi.alloff  ( can't do that, it's a controller.... )\	time@ vtime!	90 20 wchoose lo-hit !	127 lo-hit @ wchoose hi-hit !	10 0 DO	 	8 choose 1+ midi.channel!		hi-hit @ lo-hit @ wchoose 		127 20 wchoose		60 10 wchoose midi.noteon.for\		5 choose vtime+!	LOOP;: INIT.J-SAMPLE-HITTER	1 new: j-sample-hitter	'c j-sample-hitter.function add: j-sample-hitter	1 new: user-hit	j-sample-hitter add: user-hit;init.j-sample-hitter'c init.j-sample-hitter is ..stuff.user-hit\ first data is moved into my-curr, this oppose function must operate on my_curr\ and moves the the new data back into my_curr\ **********************\ sample oppose function: pitch, loudness, horizontal density: SAMPLE.OPPOSE.FUNCTION		\ invert pitch mean		127			my_curr pitch_mean ed.at: s-data		-		put.pitch_mean		\ invert loudness mean		127			my_curr vel_mean ed.at: s-data		-		put.vel_mean		\ invert horizontal density		120			my_curr hd_mean ed.at: s-data		-		put.hd_mean;'c sample.oppose.function is ..oppose.function		