\ Interpolate a value along a line defined by two points\ (x1,y1) and (x2,y2).\ by LP and ND\ 4/27/91\ rev:4/28/91\ this half cosine fixed point interpolator is modelled after the normal\ interpolator in HMSL: x1 y1 x2 y2 set.cos interp       xnew cos.interp\ the algorithm is drawn from Tenney's description of it in his article\ about CHANGES, in Perspectives of New Music\ it is fixed point for amiga portability, it would be useful to have a floating point\ version for local usage\ cos-interp-x1 should be zero if you want to start at the crest or valley of the cos wave.include? task-sine_table ht:sine_tableanew task-half_cosine_interp_fixv: COS-INTERP-X1  v: COS-INTERP-Y1v: COS-INTERP-X2  V: COS-INTERP-Y2V: COS-DX  		  V: COS-DYv: y-averagev: y-diff: CALC.SCALAR ( -- )	cos-interp-x2 @ cos-interp-x1 @ -	cos-dx !	cos-interp-Y2 @ cos-interp-Y1 @ -	cos-dY !;\ y1+y2/2: Y.AVERAGE ( -- , y-average )	cos-interp-y1 @ cos-interp-y2 @ + 	2 /	y-average !;\ y1-y2/2: Y.DIFF ( -- , y-diff )	cos-interp-y1 @ cos-interp-y2 @ -	2 /	y-diff !;	\ pass in endpoints: SET.COS.INTERP  ( x1 y1 x2 y2 -- , define line for interpolation )	COS-INTERP-Y2 ! COS-INTERP-X2 !	COS-INTERP-Y1 ! COS-INTERP-x1 !	cos-interp-x2 @ cos-interp-x1 @ =\ will crash HMSL if these two following values are equal! bug in */	IF		1 cos-interp-x2 +!	THEN	calc.scalar	y.average 	y.diff;\ inner part of tenney's formula... (see page 67 of PNM issue): COS.XDIFF ( xnew -- , value )	cos-interp-x1 @ - 	65536	cos-interp-x2 @ cos-interp-x1 @ - 	 */ 	$ 20000 		65536 */  ( this is fixed point value for pi, scaled......)	icos 	cos-dy @  	65536 */;		: COS.INTERP { X-NEW -- , y , interpolate value along line }	\ FORMULA IS:	\ (y1 + y2)/2 + (y1-y2)/2* cos(pi* ((x-new - x1)/(x2-x1))	\ or   ---- yaverage + ydiff(cos(xdiff))	y-average @	y-diff @	x-new cos.xdiff \ range is +dy to -dy     cos-dy @ + 		\ range is 0 .. 2* dy    2/				\ 0..dy    *    +    y-diff @ negate cos-dy @ * dup>r +	\ shift to positive	cos-dy @ r>	dup 0= IF drop 1 THEN ( protects for zero divide in */ )	*/     cos-interp-y1 @ +;\ test 1/2 cosine interpolator\ simple test, puts values into a shape so you can see the half cosine in the shape editorob.shape i-shape: INIT.I-SHAPE	0 4 50  6 set.cos.interp	50 1 new: i-shape	50 0 DO		 i cos.interp add: i-shape 	LOOP	i-shape add: shape-holder;\ init.i-shape\ no need to do this every time, just execute it from hmsl...: TERM.I-SHAPE	free: i-shape	clear: shape-holder;IF.Forgotten term.i-shape