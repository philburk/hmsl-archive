\ control grids for DUET\ 4/22/90\ author lp\ last change 5/21/90\ 5/26/90 updated to use mac stuff... changed font\ a future change for this piece would be to make these\ lists of grids just one grid! 4/22/90anew task-d_controls\ controlsob.menu.grid s-unclog-midiob.numeric.grid d-presetsob.numeric.grid d-ratesob.numeric.grid d-ebob.check.grid d-echoob.numeric.grid d-repeat-delaysob.objlist d-startersob.objlist d-degreesob.objlist d-targetob.objlist d-job-gridsob.screen d-screen: BUILD.D-CONTROLS	1 8 new: d-presets	1 8 new: d-rates	1 8 new: d-repeat-delays	1 1 new: d-eb	1 1 new: d-echo	8 new: d-starters	8 new: d-degrees	8 new: d-target	8 new: d-job-grids	89 3 new: d-screen	" DUET " Put.title: d-screen	70 put.key: d-screen;: INSTANTIATE.D-CONTROLS	8 0 DO		instantiate ob.radio.grid			add: d-starters		instantiate ob.numeric.grid			add: d-degrees		instantiate ob.radio.grid			add: d-target		instantiate ob.radio.grid			add: d-job-grids	LOOP;\ ===================================================\ these are the functions that record in the shape in\ and play it back: REC.FUNCTION { | grid-# -- }	midi.clear	current.object get.data: [] -> grid-#	grid-# rc-curr-channel ! \ set channel for echoing...	grid-#  at: d-source-shapes empty: []	grid-# at: d-source-shapes 	record.wait	." Recording on # " grid-# . ." ... " ;	: PLAY.FUNCTION { | grid-# -- }	current.object get.data: [] -> grid-#\ first check to see if preset grid forces preset	grid-# get.value: d-presets -1 = not\ if not, choose a new one every so often...	IF		3 choose 0= 		IF			100 choose grid-# at: d-instruments put.preset: []		THEN	THEN	grid-# at: d-players start: [];: STOP.FUNCTION { | grid-# -- }	current.object get.data: [] -> grid-#		time@ record.stop	cr ." Recording completed on # " grid-# . cr \ first, clone in the source to the mutator...	grid-# at: d-source-shapes 	grid-# at: d-mutators	sh.compress.notes	grid-# at: d-mutators	max.elements: []	dup . ." (notes recorded) " cr cr	17 < IF	\ if it's too small, make it 17 long		17 grid-# at: d-mutators max.elements: [] -		grid-# at: d-mutators extend: []	ELSE	\ if it's too big, make it 17 long		17 grid-# at: d-mutators set.many: []	THEN	grid-# at: d-players stop: [];: STARTER.FUNCTION ( value part -- )	swap drop	CASE 		0 OF rec.function ENDOF		1 OF stop.function ENDOF		2 OF play.function ENDOF	ENDCASE;\ ====================================================\ these are functions for recording in the target shape: STOP.TARGET {  | grid-# -- }	current.object get.data: [] -> grid-#	time@ record.stop	grid-# at: d-target-shapes 	grid-# at: d-c-targets\ need some sort of check here...	sh.compress.notes		grid-# at: d-c-targets	max.elements: []	17 < IF	\ if it's too small, make it 17 long		17 grid-# at: d-c-targets max.elements: [] -		grid-# at: d-c-targets extend: []	ELSE	\ if it's too big, make it 17 long	17 grid-# at: d-c-targets set.many: []	THEN	;\ this records in a target shape to the current place...: RECORD.TARGET { | grid-# -- }	midi.clear	current.object get.data: [] -> grid-#	grid-#  at: d-target-shapes	dup empty: []	record.wait	." Record until key hit" cr;: TARGET.FUNCTION ( value part -- )	swap drop	0= 		IF record.target		ELSE stop.target		THEN;	\ ===================================================================\ these are functions for the numeric grid which changes mut degrees..: DEGREE.FUNCTION { value part | grid-# -- }	current.object 	get.data: [] -> grid-#\ first, clone in the source to the mutator...\ since every time you do it, you want to mutate the original shape	grid-# at: d-source-shapes 	grid-# at: d-mutators	sh.compress.notes	grid-# at: d-mutators	max.elements: []	17 < IF	\ if it's too small, make it 17 long		17 grid-# at: d-mutators max.elements: [] -		grid-# at: d-mutators extend: []	ELSE	\ if it's too big, make it 17 long		17 grid-# at: d-mutators set.many: []	THEN\ then set mutation degree for mutator...	value grid-# at: d-mutators put.mutation-degree: []\ mutate all four dimensions: abs time, pitch, vel, on time	4 0 DO		i grid-# at: d-c-targets  put.curr-dim: []		i grid-# at: d-mutators   put.curr-dim: []		grid-# at: d-c-targets 		grid-# at: d-mutators  		mutate.partial.olm.signed: []	LOOP;\ =======================\ functions for job grids: D-JOB.START { | grid-# -- }	current.object 	get.data: [] -> grid-#	grid-# at: d-jobs start: [];: D-JOB.STOP { | grid-# -- }	current.object 	get.data: [] -> grid-#	grid-# at: d-jobs stop: [];: D-JOB.FUNCTION ( value part -- )	swap drop	0= 		IF d-job.start		ELSE d-job.stop		THEN;\ function for jobs themselves		: DEGREE.CHANGING.FUNCTION { job | grid-# -- }	job get.data: [] \ -- data	-> grid-#    	grid-# at: d-mutators get.mutation-degree: [] \ --  degree	20 10 wchoose +  \ -- new-degree	dup 1000 > 		IF drop 1000 THEN		 ( -- new-degree )  	dup      ( -- newdegree newdegree )	0 \ -- degree degree part# 	grid-# at: d-degrees  put.value: []	grid-# at: d-mutators put.mutation-degree: []\ mutate all four dimensions: abs time, pitch, vel, on-time	4 0 DO		i grid-# at: d-c-targets  put.curr-dim: []		i grid-# at: d-mutators   put.curr-dim: []		grid-# at: d-c-targets 		grid-# at: d-mutators  		mutate.partial.olm.signed: []	LOOP\ redraw the numeric	grid-#	at: d-degrees draw: [];: SETUP.D-JOB-GRIDS { | temp-object -- }	8 0 DO	\ jobs		i at: d-job-grids		-> temp-object		i temp-object put.data: []		1 2 temp-object new: []		275 300 temp-object put.wh: []		9 temp-object  put.text.size: []		stuff{ " St" " Sp" 		temp-object }stuff.text: []		true 1 temp-object put.value: []		'c d-job.function temp-object put.down.function: []\ at this point, add in the function to the jobs themselves...		'c degree.changing.function i at: d-jobs add: []			LOOP;: SETUP.D-STARTERS { | temp-object -- }	8 0 DO	\ d-starters		i at: d-starters		-> temp-object		i temp-object put.data: []		1 3 temp-object new: []		275 300 temp-object put.wh: []		9 temp-object  put.text.size: []		stuff{ " R" " S" " P"		temp-object }stuff.text: []		true 1 temp-object put.value: []		'c starter.function temp-object put.down.function: []	LOOP;: SETUP.D-TARGET { | temp-object -- }	8 0 DO		i at: d-target		-> temp-object		i temp-object put.data: []		1 2 temp-object new: []		300 300 temp-object put.wh: []		9 temp-object  put.text.size: []		stuff{ " R" " S" 		temp-object }stuff.text: []		true 1 temp-object put.value: []		'c target.function temp-object put.down.function: []	LOOP;: SETUP.D-DEGREES { | temp-object -- }	8 0 DO	\ degrees of mutations		i at: d-degrees		-> temp-object		i temp-object put.data: []		1 1 temp-object new: []		275 300 temp-object put.wh: []		9 temp-object  put.text.size: []		0 0 temp-object put.min: []		1000 0 temp-object put.max: []		0 0 temp-object put.value: []\		'c degree.function temp-object 	put.move.function: []		'c degree.function temp-object 	put.up.function: []		\		'c degree.function temp-object 	put.down.function: []	LOOP;: D-PRESET.FUNCTION ( value part -- , change preset of appropriate player )		at: d-instruments 		put.preset: []	;	: SETUP.D-PRESETS	-1 -1 put.min: d-presets ( -1 minimum on all parts )	99 -1 put.max: d-presets	265 275 put.wh: d-presets	9  put.text.size: d-presets	8 0 DO		-1 i put.value: d-presets ( initial value no preset... )	LOOP	stuff{ " Pre." }stuff.text: d-presets	'c d-preset.function put.up.function: d-presets	'c d-preset.function put.down.function: d-presets;: D-RATES.FUNCTION ( value part -- )	over -1 = not 	IF		at: d-jobs		put.duration: []	ELSE	2drop	THEN;: SETUP.D-RATES	-1 -1 put.min: d-rates 	500 -1 put.max: d-rates	265 275 put.wh: d-rates	9  put.text.size: d-rates	8 0 DO		-1 i put.value: d-rates	LOOP	stuff{ " Rate" }stuff.text: d-rates	'c d-rates.function put.up.function: d-rates	'c d-rates.function put.down.function: d-rates;: D-EB.FUNCTION ( value part -- )	drop	time-advance !;	: SETUP.D-EB	300 0 put.value: d-eb	5 0 put.min: d-eb	600 0 put.max: d-eb	175 260 put.wh: d-eb	9   put.text.size: d-eb	stuff{ " E. Buff. " }stuff.text: d-eb	'c d-eb.function put.up.function: d-eb	'c d-eb.function put.down.function: d-eb;: D-ECHO.FUNCTION ( value part -- )	drop 	dup ." value is " . cr	rc-echo-on? !;: SETUP.D-ECHO	0 0 put.value: d-echo	350 275 put.wh: d-echo	stuff{ " Echo " }stuff.text: d-echo	'c d-echo.function put.down.function: d-echo	'c d-echo.function put.up.function: d-echo;: S-UNCLOG-MIDI.FUNCTION ( value part -- )	2drop midi.unclog;: BUILD.S-UNCLOG-MIDI	1 1 new: s-unclog-midi	500 200 put.wh: s-unclog-midi	9 put.text.size: s-unclog-midi	stuff{ " unclog " }stuff.text: s-unclog-midi	'c s-unclog-midi.function put.down.function: s-unclog-midi;	: D-DELAY.FUNCTION ( value part -- )	at: d-players	put.repeat.delay: [];: SETUP.D-REPEAT-DELAYS	0 -1 put.min: d-repeat-delays 	600 -1 put.max: d-repeat-delays	265 275 put.wh: d-repeat-delays	9  put.text.size: d-repeat-delays	8 0 DO		120 i put.value: d-repeat-delays	LOOP	stuff{ " Del." }stuff.text: d-repeat-delays	'c d-delay.function put.up.function: d-repeat-delays	'c d-delay.function put.down.function: d-repeat-delays;	: SETUP.D-SCREEN				0 scg.selnt	8 0 DO		i at: d-starters			i 275 * 280  add: d-screen		i at: d-target			i 275 * 1600 add: d-screen		i at: d-degrees			i 275 * 2600 add: d-screen		i at: d-job-grids			i 275 * 3200 add: d-screen	LOOP		d-presets 2500 280 add: d-screen		d-rates   3100 280 add: d-screen		d-repeat-delays 3700 280 add: d-screen\		d-eb 	  2800 3000 add: d-screen		d-echo 	  3000 3000 add: d-screen		s-unclog-midi 2800 3500 add: d-screen		d-screen default-screen !;: INIT.D-CONTROLS	build.d-controls	instantiate.d-controls	setup.d-presets	setup.d-rates	setup.d-repeat-delays	setup.d-eb	setup.d-echo	build.s-unclog-midi	setup.d-starters	setup.d-target 	setup.d-degrees	setup.d-job-grids	setup.d-screen; init.d-controls: TERM.D-CONTROLS	free: d-presets	free: d-rates	free: d-eb	free: d-echo	freeall: d-starters	freeall: d-degrees	freeall: d-target	freeall: d-job-grids	freeall: d-screen\	free: d-starters	free: d-degrees	free: d-target	free: d-job-grids	free: d-repeat-delays	free: d-presets	free: d-screen;if.forgotten term.d-controls