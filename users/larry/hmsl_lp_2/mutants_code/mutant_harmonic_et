\ MUTANTS: Harmonic\ author: LP\ 1/11/92\ This file contains extensions to mutant class, which allow the mutation\ along harmonic ideasANEW TASK-MUTANT_HARMONIC_ET\ UTILITIES\ INNER ROUTINES FOR MUTATIONS\ types of mutations:\		Octave harmonic (UOH)\		Non-octave harmonic (INH, UNH)\ The former retains octave (and sign), the latter loses it and only works\ on interval, which it collapses into the octave above the fundamental of the \ target morph.\ There is no IOH, because that would be the same as a simple Irregular replacement\ (like an ISIM).\method (uoh.interval.change):\method (unh.interval.change):\method (inh.interval.change):method (inh.no.change):method (inh.clumping):method (inh.stochastic):\ MUTATIONSmethod INH: ( Irregular non-octave harmonic )method UNH: ( Uniform non-octave harmonic )method UOH: ( Uniform octave harmonic )\ Note: There is a not a strict correspondence between octave/contour and \ interval/magnitude. For example, there is no mutation here which changes\ the octave but not the interval (that could be useful....)\ There ARE two mutations (INH, UNH) which change the interval, while collapsing octave,\ and then one more mutations (UOH) which add the crossfaded :CLASS OB.MUTANT-HARMONIC-ET <SUPER OB.MUTANT\ default is stochastic clumping	:M INIT:	init: super;M\ The following mutation collapses all octaves into a pitch above the fundamental, which\ is the interval of the source. Note that the only reason for this to exist, since it's pretty\ similar to the IUIM, is that it collapses all octaves into the same ET interval.\ Basically, what it does is change selected intervals in the mutant into harmonic intervals\ of the source, in a kind of replacement fashion.\ ================================\   INH Mutation\ ================================:M (INH.INTERVAL.CHANGE): { indx -- }	indx iv-target-shape get.interval-index: [] ( -- i )	indx ( -- j )	 ( -- i-ind j-ind )	iv-target-shape harmony.interval.et: [] ( get the value of the harmonic interval)	at: harmony-et-table ( -- val )	\ Add it to the fund. element of the source	indx (add.to.mut.int): self;m:M (INH.NO.CHANGE): ( indx -- )	 (lcm.no.change): self ( this routine is defined from the superclass );m:M (INH.STOCHASTIC):	\ stochastic clumping algorithm	many: self      \ length of mutator	interval.start: self	DO		1000 choose i get.smart.½: self		<  		IF			i (INH.INTERVAL.CHANGE): self		ELSE			i (INH.NO.CHANGE): self		THEN	LOOP;m:M (INH.CLUMPING): 	cr ." Clumping not implemented yet for non-stochastic clumping " cr cr;m:M INH:	check.sizes: self	IF stochastic.clumping?: self		IF			(INH.stochastic): self		ELSE			(INH.clumping): self		THEN	ELSE		print.size.warning	THEN;m\ ================================\   UNH Mutation\ ================================\ Equation for change:\ new-harm = ½(abs(targ-harm - source-harm )) + s-int\ this mutation creates an "octave rectified" morph which\ is ½ * the difference of the harmonic values of intervals in\ the source and target, all calculated to be above the fundamental:M (UNH.INTERVAL.CHANGE): { indx | target-int source-int -- }	indx get.interval-index: self 	indx ( -- i j )	harmony.interval.et: self 	-> source-int	indx iv-target-shape get.interval-index: []	indx ( -- i j )	iv-target-shape harmony.interval.et: [] 	-> target-int	\ leaves source and target harmonic intervals on stack...	source-int target-int 	- abs ( -- abs value of diff between harmonic intervals )	indx get.smart.½: self ( -- abs ½ ) 	1000 */.roundup ( , times ½ ) 	\ stack: adjusted harmonic value	\ the following test is for bringing it to the source or away from	\ the source, depending on the relationship between the source and	\ target harmonic interval	target-int source-int > 		IF			source-int +		ELSE			source-int swap - 		THEN	\ stack: new harmonic intervals	at: harmony-et-table	indx (add.to.mut.int): self;m	\ Uniform unsigned interval magnitude mutation:M UNH:	check.sizes: self	IF 		many: self		interval.start: self		DO			i (unh.interval.change): self		LOOP	ELSE		print.size.warning	THEN;M\ ================================\   UOH Mutation\ ================================\ Changes the harmonic interval and in addition cross-fades the octave according\ to the mutation degree:M (UOH.INTERVAL.CHANGE): { indx | tr-int sr-int t-oct s-oct val oct-diff -- }	indx get.interval-index: self 	indx ( -- i j )	harmony.interval.et: self	-> sr-int ( this is the actual interval above the source fundamental )	indx iv-target-shape get.interval-index: []	indx ( -- i j )	iv-target-shape harmony.interval.et: [] 	-> tr-int ( this is the actual interval above the target fundamental )	\ leaves source and target harmonic intervals on stack...	sr-int tr-int 	- abs ( -- abs value of diff between harmonic intervals )	indx get.smart.½: self ( -- abs ½ ) 	1000 */.roundup ( , times ½ ) 	\ stack: adjusted harmonic value	\ the following test is for bringing it to the source or away from	\ the source, depending on the relationship between the source and	\ target harmonic interval	tr-int sr-int > 		IF			sr-int +		ELSE			sr-int swap - 		THEN	( -- new-harmonic-interval )	at: harmony-et-table -> val 	( -- , val is the real number of 1/2 steps for the new pitch.... )\ OCTAVE ADJUSTMENT 	indx get.interval-index: self 	indx iv-target-shape octave#: [] -> t-oct 	indx get.interval-index: self 	indx iv-source-shape octave#: [] -> s-oct \ now find the proper crossfaded octave...	t-oct  s-oct  - abs  	indx get.smart.½: self 	1000 */.roundup 	-> oct-diff 	t-oct s-oct >	IF		\ if T>S, then s-diff gets added to s-oct		s-oct oct-diff + ( --  new-octave# )	ELSE		\ if T<S, then s-diff gets subtracted from s-oct		s-oct oct-diff - ( -- new-oct )	THEN	( -- adj-oct-# ) 	12 * ( -- adj-oct*12 ) 	( now need to re-offset it by the fundamental )	indx get.interval-index: self 	curr-dim ed.at: self 	12 /mod drop ( find mod 12 remainder of fundamental ) 	+ ( this adds the "absolute value" of the fundamental to the absolute octave desired )	val +	indx curr-dim clip.ed.to: self;M:M UOH:	check.sizes: self	IF 		many: self		interval.start: self ( just doing intervals )		DO			i (uoh.interval.change): self		LOOP	ELSE		print.size.warning	THEN;M;CLASS\ Testsob.mutant-harmonic-et mh-1ob.mutant-harmonic-et mh-2ob.mutant-harmonic-et mh-3: INIT.MH.TESTS	6 1 new: mh-1	6 1 new: mh-2	6 1 new: mh-3	0 put.curr-dim: mh-1	0 put.curr-dim: mh-2	0 put.curr-dim: mh-3	stuff{ 27 105 3 94 52 48 }stuff: mh-1	stuff{ 48 42 50 51 24 53 }stuff: mh-2	mh-3 clone: mh-1	use.fundamental: mh-1	use.fundamental: mh-2	use.fundamental: mh-3	51 0 put.fundamental: mh-1	51 0 put.fundamental: mh-2	51 0 put.fundamental: mh-3	cr ." MH-1 " 0 ph: mh-1	cr ." MH-2 " 0 ph: mh-2	cr ." MH-3 " 0 ph: mh-3	mh-1 put.source: mh-3	mh-2 put.target: mh-3	1000 put.½: mh-3;			