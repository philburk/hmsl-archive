\ Harmonic mutant demo\ for ICMC 1992ANEW TASK-HARMONIC_MUTANT_DEMOob.objlist h-sourcesob.objlist h-targetsob.objlist h-mutantsob.objlist h-playersob.collection h-collectionob.job h-job120 time-advance !20 value shape-length8 value #-shapes1000 value curr-½15 value ½-inc: FILL.SOURCE.SHAPE { curr-shape -- }	50 15 wchoose 60 60 curr-shape add: []	shape-length 1	DO		8 3 wchoose 4 * \ durations		12 choose		CASE			0 of 0 endof			1 of 0 endof			2 of 0 endof			3 of 0 endof			4 of 7 endof			5 of 7 endof			6 of 4 endof			7 of 4 endof			8 of 4 endof			9 of 7 endof			10 of 10 endof			11 of 10 endof		ENDCASE		12 7 4 wchoose * + 		90 60 wchoose 		curr-shape add: []	LOOP		;: FILL.TARGET.SHAPE { curr-shape -- }	30 5 wchoose 60 60 curr-shape add: []	shape-length 1	DO		25 2 wchoose		96 30 wchoose		100 30 wchoose		curr-shape add: []	LOOP;	: INIT.H-SHAPES { | curr-shape -- }	#-shapes new: h-sources	#-shapes new: h-targets	#-shapes 0 DO		instantiate ob.mutant-harmonic-et		-> curr-shape		shape-length 3 curr-shape new: []		curr-shape fill.source.shape 		0 curr-shape put.fund-index: []		curr-shape add: h-sources		curr-shape use.fund-index: []		instantiate ob.mutant-harmonic-et		-> curr-shape		shape-length 3 curr-shape new: []		curr-shape fill.target.shape 		0 curr-shape put.fund-index: []		curr-shape add: h-targets		curr-shape use.fund-index: []	LOOP;: INIT.H-MUTANTS { | curr-shape -- }	#-shapes new: h-mutants	#-shapes 0 DO		instantiate ob.mutant-harmonic-et		-> curr-shape		shape-length 3 curr-shape new: []		curr-shape		i at: h-sources		clone: []		curr-shape add: h-mutants		curr-shape use.fund-index: []		i at: h-sources curr-shape put.source: []		i at: h-targets curr-shape put.target: []		0 curr-shape put.fund-index: []		0 curr-shape put.½.function: []		0 curr-shape put.½.shape: []	LOOP;v: curr-mut: H-JOB.FUNCTION { job | curr-shape curr-target curr-source -- }	curr-mut @ at: h-mutants	-> curr-shape	curr-mut @ at: h-targets	-> curr-target	curr-mut @ at: h-sources	-> curr-source	curr-½ curr-shape put.½: []	0 curr-shape put.curr-dim: []	0 curr-target put.curr-dim: []	0 curr-source put.curr-dim: []	curr-shape usim: []	1 curr-shape put.curr-dim: []	1 curr-target put.curr-dim: []	1 curr-source put.curr-dim: []	curr-shape usim: []	2 curr-shape put.curr-dim: []	2 curr-target put.curr-dim: []	2 curr-source put.curr-dim: []	curr-shape uoh: []	15 2 wchoose put.duration: job		curr-½ ½-inc - 0 max -> curr-½\	100 choose 20 < IF curr-½ . THEN	curr-mut @ 1+ #-shapes mod curr-mut !;: INIT.H-PLAYERS { | curr-player -- }	#-shapes new: h-players	#-shapes 0 DO		instantiate ob.player		-> curr-player		curr-player add: h-players		1 curr-player new: []		1000 curr-player put.repeat: []		i at: h-mutants		add: curr-player		10 1 wchoose curr-player put.repeat.delay: []		instantiate ob.midi.instrument curr-player put.instrument: []		i 1+ curr-player get.instrument: [] put.channel: []		0 curr-player get.instrument: [] put.offset: []	LOOP;: INIT.H-JOB 	1 new: h-job	1000 -> curr-½	60 3 wchoose put.duration: h-job	'c h-job.function add: h-job;: INIT.H-COLLECTION	#-shapes 1+ new: h-collection	#-shapes 0 DO		i at: h-players add: h-collection	LOOP	h-job add: h-collection	act.parallel: h-collection;: H.INIT	init.h-shapes ." shapes "	init.h-mutants ." mutants "	init.h-players ." players "	init.h-collection ." collection "	init.h-job ." job ";: H.TERM	freeall: h-sources	freeall: h-players	freeall: h-mutants	freeall: h-targets	free: h-collection	free: h-job	free: h-players	free: h-sources	free: h-targets	free: h-mutants;: H.DO	h.init h-collection hmsl.play;if.forgotten h.term