\ Mutator class\ author: LP\ Solo, Central Java, Indonesia 1/18/89\ Important note: This (Mutator class) was a very transitional bit of code that is no longer\ necesarry except to be able to run a few old pieces which used it\ (Bedhaya..., 3 Studies, Duet). It should not be used, since the subclass\ mutants does the same things, and is MUCH improved. Some of the methods for the\ mutant class are defined here however. This mutator class is buggy, inefficient, and so\ on... don't use the mutators here. Everything else is ok (the various utilities and so on)\ which are inherited by the mutant class (the one to really use)\ 3/27/92 !!!!! Removed this file from load sequence, and also, removed it as parent class\ of MUTANTS. There should be no reason ever to use this file again. It is just being kept\ around for historical reasons, because it was used in Bedhaya.....\ Class of shapes, subclass of metric shapes, which\ mutate themselves into lists of other shapes\ Last changed, 5/17/89\ rev. 8/21/91, added new names to mutator types...\ as of 8/21, all the irregular mutators are stochastic, no values for clumping are used here...\ All of these mutators currently mutate "around" some fundamental\ in the source and target, which may be different.anew task-mutator\ UTILITIESmethod put.mutation-degree:method get.mutation-degree:method target.big.enough?:\ SOME MUTATORS, CORRESPONDING ROUGLY TO METRICS\ DIRECTION TYPEmethod mutate.old: \ OLM TYPE\ method mutate.full.olm.signed: ( chucked this one, use mutant class )method mutate.full.olm.abs:method mutate.partial.olm.abs:method mutate.partial.olm.signed:method new.mutate.partial.olm.signed:\ SOME VARIABLES FOR STORING INTERVALS IN HAIRY CALCULATIONSv: t-intv: s-intv: new-int:CLASS OB.MUTATOR <super ob.m.shape	iv.long iv-mutation-degree\ adjaceny interval of 1 is default (from metrics class):m INIT:	init: super	0 iv=> iv-mutation-degree;m: PRINT.SIZE.WARNING.1 ( -- , target not as big as source )	cr ." Target shape not big enough to mutate from!! "	cr ." (smaller than source shape in many, or dimensions) ";\ ===========================================================\                            OLD TYPE\ ===========================================================\ MUTATORS\ Some notes: all mutators clip new values to current dimension\ limits (3/28/89)\ Change a certain percentage of ordered linear contours, but leave absolute\ intervals to fundamental the same or zero's interval.\ This algorithm just changes linear contour.\ Fundamental  value is left unchanged.\ Target shape must be at least as big as the source!\ Direction in the target of zero forces a zero in the mutant\ This used in Guthrie Bedhaya 5/17/89, and checked out fine...\ LCM, or linear contour mutation:m MUTATE.OLD: ( target-shape -- , mutated target-shape from source )	iv=> iv-target-shape	sync.target-index: self	target.big.enough?: self	IF		many: self         \ length of mutator		interval.start: self	        DO			1000 choose iv-mutation-degree <  			IF				\ get direction from target				i iv-target-shape get.interval-index: []				i				iv-target-shape direction.interval: []				( -- -1|0|1 )				i 				i get.interval-index: self				abs.diff.interval: self				( -- -1|0|1 value )				* ( -- signed value, or 0 if target was equal... )				i get.interval-index: self				curr-dim ed.at: self				+ 				i curr-dim clip.ed.to: self			THEN		LOOP	ELSE print.size.warning.1	THEN;m\ ===========================================================\                    OLM Type\ ===========================================================\ Same as above, but this time, the contour\ of the original is preserved, and just the\ absolute value of the interval is added or subracted\ to the original according to the contour of the original.\ This mutator used in Bedhaya Guthrie, 5/17, and checked out fine...\ IUIM: Irregular unsigned interval magnitude:m MUTATE.FULL.OLM.ABS: (  target-shape -- , mutated target-shape from source )	iv=> iv-target-shape	sync.target-index: self	target.big.enough?: self	IF		many: self  \ length of mutator		interval.start: self		DO		1000 choose iv-mutation-degree <  \ choose to see if mutated...			IF				\ get the interval from the target				i				i iv-target-shape get.interval-index: [] 				iv-target-shape abs.diff.interval: []				( -- unsigned value )				\ get direction value from source				i get.interval-index: self				i  				direction+-.interval: self				* \ Change the sign appropriately,				\ possibility of zero				\ if only target doesn't move.				\ Add it to the fund. element of the source.				i get.interval-index: self				curr-dim ed.at: self				+ i curr-dim clip.ed.to: self			THEN		LOOP	ELSE print.size.warning.1	THEN;m\ Note that this makes every absolute interval in the source\ a percentage of the difference between the\ source interval and the corresponding interval in the target,\ according to the current mutation degree. \ That is, intervals in the source are made "closer"\ to the target: if the target interval is smaller,\ the source interval is shrunk, and vice versa. \ The direction of the source is kept, so that a positive\ large interval in the target, for example, will result\ as a "larger" (depending on the mutation degree) negative\ interval in the source if the source was already negative!\ Intervals are taken to the currently defined interval mechanism.\ this one needs checking!!!! 5/15/89:M MUTATE.PARTIAL.OLM.ABS: ( target-shape -- , mutates )	iv=> iv-target-shape	sync.target-index: self	target.big.enough?: self	IF		many: self 		interval.start: self		DO			i			i iv-target-shape get.interval-index: [] 		        iv-target-shape abs.diff.interval: []			t-int !			i  			i iv-target-shape get.interval-index: []			abs.diff.interval: self			s-int !			t-int @ s-int @ - abs \ -- |diff-int|\ N.B   degree/1000 : new-int/t-int, so\ new-int = t-int*degree/1000			get.mutation-degree: self  ( diff-int  degree )\			1000 */ ( -- new-int ) 			1000 */.roundup			new-int !\ get the sign of the source interval			i i get.interval-index: self			direction+-.interval: self  ( -- -1|1 )			s-int @ t-int @ < \	if source interval is smaller than target, add new value\	to source	 			IF				s-int @ new-int @ + \ mutate the interval				* \ multiply by sign				i get.interval-index: self				curr-dim ed.at: self				+ \ add the interval to the source				i curr-dim  clip.ed.to: self\ 	if source interval is greater or equal to target, subtract\	new value from source			ELSE					s-int @ new-int @ - \ mutate the interval				* \ multiply by sign				i get.interval-index: self				curr-dim ed.at: self				+ \ add the interval to the source				i curr-dim clip.ed.to: self			THEN		LOOP	THEN;M\ Same as above, but this time, the absolute value of the difference\ of the two signed intervals is taken, of the signed or unsigned \ intervals in source and\ target, and the source interval is mutated, through the positive\ or negative axis, if necessary, towards the target. That is, the\ source shape's intervals are incremented or decremented by\ the mutation-degree percentage of the difference in the\ corresponding intervals, and then that percentage\ is added or subtracted from the source interval,\ and added (or subtracted) from the actual value\ depending on the original direction of the source.\ This mutator checked out well in guthrie piece, 5/17/89\ USIM: Uniform signed interval magnitude...:M MUTATE.PARTIAL.OLM.SIGNED: ( target-shape -- , mutates )	iv=> iv-target-shape	sync.target-index: self	target.big.enough?: self	IF		many: self 		interval.start: self		DO			i iv-target-shape get.interval-index: []			i 		        iv-target-shape signed.diff.interval: []			t-int !			i get.interval-index: self  			i signed.diff.interval: self			s-int !			t-int @ s-int @ - abs \ -- |diff-int|\ N.B   degree/1000 : new-int/t-int, so\ new-int = t-int*degree/1000			get.mutation-degree: self  ( diff-int  degree )\			1000 */ ( -- new-int ) 			1000 */.roundup ( -- new-int, rounded up or down )			new-int !			s-int @ t-int @ < \	if source interval is smaller  than target, \	then add new value to source	 			IF				s-int @ new-int @ + \ mutate the interval				i get.interval-index: self				curr-dim ed.at: self				+ \ add the interval to the source				i curr-dim  ed.to: self\ 	if source interval is greater or equal to target, subtract\	new value from source			ELSE					s-int @ new-int @ - \ mutate the interval				i get.interval-index: self				curr-dim ed.at: self				+ \ add the interval to the source				i curr-dim ed.to: self			THEN		LOOP	THEN;M\ ===========================================================\ 		PRINT DELUXE\ ===========================================================:M PRINT:	print: super cr 	get.mutation-degree: self ." Mutation degree (½): " . ;m;class