\ MUTANTS\ author: LP\ 8/21/91\ 3/27/92\ This file contains extensions to the metric shape class\ which follow the new syntax developed by the author and\ Martin McKinney: SOURCE TARGET ½ MUTATION.\ That is, each mutant has a source, target and ½ associated with it, \ as instance variables, and as such, the mutations follow the new\ form of the equations more closely.\ Need to revise language: instead of Source and Target, it should be Source1\ and Source2 (lp5/92)\ Clumping is not added yet!!!!!\ Added notion of mutation degree function and shape. If there is no\ mutation degree function (0), and no mutation\ degree shape (0), use the mutation degree. If there is a shape and a function, function\ overrides. Shape cannot be longer than mutation. Function takes mutant as argument (as\ is conventional in HMSL\ 7/28/92\ Added USE.MIN.MAX.FROM.SHAPE:\ Replaced all fetches of ½ with smart fetches...\ Added DOOM: : drop out only mutation\ Mutation degree chance of value in selected dimension being simply zeroed out...\ 8/15/92\ added interpolation for mutation degree trajectoriesANEW TASK-MUTANT\ ½method put.mutation-degree:method get.mutation-degree:method get.smart.mutation-degree:method put.mutation-degree.function:method get.mutation-degree.function:method put.mutation-degree.shape:method get.mutation-degree.shape:method compand.temp-½-shape:method put.min.mutation-degree:method get.min.mutation-degree:method put.max.mutation-degree:method get.max.mutation-degree:method use.max.min.from.shape:method ½.shape?:\ methods for interpolation of ½ from ½-shapemethod interpolate.½-shape:method non-interpolate.½-shape:method set.interpolate-case?:method (interpolate.½):method interpolate.½:method interpolate.½-shape?:\ ½  synonyms for mutation degreemethod put.½:method get.½:method get.smart.½:method put.½.function:method get.½.function:method put.½.shape:method get.½.shape:method put.min.½:method get.min.½:method put.max.½:method get.max.½:\ zero override handlingmethod put.zero-override?:method get.zero-override?:method zero-override?.on:method zero-override?.off:\ clumping stuffmethod get.clumping-value:method put.clumping-value:method get.¶: ( synonyms for the above )method put.¶:method use.stochastic.clumping:method stochastic.clumping?:method is.stochastic?:\ Error checking, diagnosticsmethod has.shape?:method check.sizes:method show.mutation:method print.temp-½-shape:method get.temp-½-shape:method target.big.enough.dim?:method target.big.enough.many?:method source.big.enough.dim?:method source.big.enough.many?:method source.big.enough?:\ Methods for the individual mutation equationsmethod calc.t-abs:method calc.s-abs:method calc.t-sign:method calc.s-sign:method calc.s-signed-int:method calc.t-signed-int:\ a nice thing to add would be calc.int: which filled all the\ instance variables, or individually for s and t\ Inner routines for mutationsmethod compute.clumpsize:method (add.to.mut.int):method (lcm.stochastic): method (lcm.interval.change):method (lcm.clumping):method (lcm.no.change):method (iuim.stochastic):method (iuim.interval.change):method (iuim.no.change):method (iuim.clumping):method (vm.interval.change):method (uuim.interval.change):method (usim.interval.change):method (isim.interval.change):method (isim.no.change):method (isim.clumping):method (isim.stochastic):method (doom.change):method (doom.stochastic):\ MUTATIONSmethod DOOM:method VM:method LCM:method ISIM:method IUIM:method UUIM:method USIM:method LCM/IUIM:method LCM/UUIM::CLASS OB.MUTANT <SUPER OB.M.SHAPE	iv.long iv-mutation-degree	\ this is the actual shape, must be a new shape, used for change	iv.long iv-mutation-degree.shape	iv.long iv-mutation-degree.function	iv.long iv-min-mutation-degree	iv.long iv-max-mutation-degree	iv.long iv-clumping-value	iv.short iv-clumpsize \ # in a row to mutate	iv.short iv-noclumpsize \ # in a row not to mutate	iv.short s-abs	iv.short s-sign	iv.short t-abs	iv.short t-sign	iv.short s-signed-int \ signed intervals	iv.short t-signed-int 	iv.short zero-override? 	iv.short interpolate.½-shape?	\ this will be a temporary cloner	ob.new-shape temp-½-shape\ default is stochastic clumping	:M INIT:	init: super	0 iv=>  iv-mutation-degree	-1 iv=> iv-clumping-value	1 iv=>  zero-override? \ default is to use it	0 iv=>  iv-mutation-degree.shape	0 iv=>  iv-mutation-degree.function	0 iv=>  iv-min-mutation-degree	\ the default is interpolation of the shape if there is one	true iv=> interpolate.½-shape?	1000 iv=> iv-max-mutation-degree;M:M FREE: 	free: super	free: temp-½-shape;m\ ================================================\ 	NEW UTILITIES\ ================================================:M INTERPOLATE.½-SHAPE: 	true iv=> interpolate.½-shape?;m:M INTERPOLATE.½-SHAPE?: ( -- flag )	interpolate.½-shape?;m:M NON-INTERPOLATE.½-SHAPE:  	false iv=> interpolate.½-shape?;m\ Shapes are abstract shapes here, the starting and ending values are used to scale\ the morphology. the only restriction is that if the "directionality" of the shape has \ to agree with the directionality of the starting and ending values. that is, if the last\ value in the shape is bigger than the first, the same thing must be true with the\ starting and ending values...:m GET.MUTATION-DEGREE.SHAPE: ( -- shape )	iv-mutation-degree.shape;m	\ This routine happens everytime a new min or max value is put, or a new shape is put..:M COMPAND.TEMP-½-SHAPE: 	temp-½-shape iv-mutation-degree.shape clone: []	iv-min-mutation-degree 	iv-max-mutation-degree 	0 temp-½-shape compand: [];M	\ there is some wierd bug in this routine that happens when the changing shape\ is newed bigger than its many.... it's non-fatal, but asks for free: first...:M PUT.MUTATION-DEGREE.SHAPE: ( shape -- )	free: temp-½-shape	dup	iv=> iv-mutation-degree.shape	0= not	IF		\ make room in cloner shape		iv-mutation-degree.shape many: [] 		1 new: temp-½-shape		compand.temp-½-shape: self	THEN;M:M PRINT.TEMP-½-SHAPE: ( -- )	temp-½-shape print: [];m:M GET.TEMP-½-SHAPE:	temp-½-shape;m\ stack diagram for user function:( mutant -- ½ ):M ½.SHAPE?: ( -- val t|f )	iv-mutation-degree.shape 0= 	IF		." Mutant doesn't have ½-shape " cr		drop		false	ELSE		true	THEN;m	:m GET.MUTATION-DEGREE.FUNCTION: ( -- cfa )	iv-mutation-degree.function;m	:m PUT.MUTATION-DEGREE.FUNCTION: ( cfa -- )	iv=> iv-mutation-degree.function;m:m GET.MIN.MUTATION-DEGREE: ( -- min )	iv-min-mutation-degree;m	:m PUT.MIN.MUTATION-DEGREE: ( min -- )	½.shape?: self	IF		0 1000 clipto		iv=> iv-min-mutation-degree		compand.temp-½-shape: self	THEN;m:m GET.MAX.MUTATION-DEGREE: ( -- max )	iv-max-mutation-degree;m	:m PUT.MAX.MUTATION-DEGREE: ( max -- )	½.shape?: self	IF		0 1000 clipto		iv=> iv-max-mutation-degree		compand.temp-½-shape: self	THEN;m:m GET.MIN.½: ( -- min )	iv-min-mutation-degree;m	:m PUT.MIN.½:  ( min -- )	put.min.mutation-degree: self;m:m GET.MAX.½: ( -- max )	iv-max-mutation-degree;m	:m PUT.MAX.½: ( max -- )	put.max.mutation-degree: self;m:m GET.½.SHAPE:	iv-mutation-degree.shape;m	:m PUT.½.SHAPE:	put.mutation-degree.shape: self;m:m GET.½.FUNCTION:	iv-mutation-degree.function;m		:m PUT.½.FUNCTION:	iv=> iv-mutation-degree.function;m:M USE.MAX.MIN.FROM.SHAPE: ( , extracts max and min from ½-shape, and uses them...)	\ in other words, compands shape to its current form....	iv-mutation-degree.shape 0= 	IF		." Mutant doesn't have ½-shape " cr	ELSE		0 iv-mutation-degree.shape calc.dim.stats: []		0 iv-mutation-degree.shape get.dim.max: []		put.max.½: self		0 iv-mutation-degree.shape get.dim.min: []		put.min.½: self	THEN;M\ ================================================================\ 			INTERPOLATING FROM A MUTATION DEGREE SHAPE\ ================================================================0 value interpolate-case?0 k: last_index1 k: first_index2 k: no_½_shape3 k: interpolate_½:M (INTERPOLATE.½): { indx | ½-length length ½-prev ½-next -- ½ }	many: self -> length	iv-mutation-degree.shape many: [] 1- -> ½-length	indx ½-length * length / length * -> ½-prev	½-prev length + -> ½-next  	½-prev  ( -- x1 )	½-prev length / 0 temp-½-shape ed.at: []	( -- x1 y1 )	½-next	½-next length / 0 temp-½-shape ed.at: []\	.s	( -- x1 y1 x2 y2 )	set.interp	indx ½-length *\	.s	interp ;m: (INDEX.TOO.BIG) { indx -- indx }		." Index too big, clipped....!!! " cr		indx 0 many: self clipto;: (GET.LAST.INDEX) ( -- ½ )		iv-mutation-degree.shape many: [] 1- 0 		temp-½-shape ed.at: [] ( -- ½ );: (GET.FIRST.INDEX) ( -- ½ )		0 0 temp-½-shape ed.at: [];: (NO.½.SHAPE) ( -- ½ )	." There is no mutation degree shape !!!! " cr	." Returning ½ " 	iv-mutation-degree;\ This routine takes Common Multiple of the two shapes, and uses that to\ interpolate a ½ from the mutation degree shape.\ There are special cases for the first and last values of the mutant.\ This routine is intended to be most useful if the ½-shape is smaller than\ the mutant, so that one can specify simple trajectories for a long mutant. \ However, it doesn't have to be the case, it should handle all lengths of\ ½-shape and mutant:M SET.INTERPOLATE-CASE?: { indx -- ½ }	\ first set the value of the case check to be interpolating...	interpolate_½ -> interpolate-case?	\ first check to see if the indx is too big, if so, just reset the index	\ and just set the case to make sure, although the next IF...THEN down should	\ get it...	indx many: self 1- > 	IF		indx (index.too.big)  -> indx		last_index -> interpolate-case?	THEN	\ now check for the case that you're trying to find the last element, which	\ will simply take the last element of the mutation degree shape	indx many: self 1- =	IF		last_index -> interpolate-case?	THEN	\ now check to see if you're trying to get the first element of the mutant	\ if so, set it to the first element of the mutation degree shape	indx 0=	IF		first_index -> interpolate-case?	THEN	iv-mutation-degree.shape 	0= 	IF		no_½_shape -> interpolate-case?	THEN;M:M INTERPOLATE.½: { indx -- ½ }	indx set.interpolate-case?: self	interpolate-case? 	CASE		last_index     OF (get.last.index) ENDOF		first_index    OF (get.first.index)  ENDOF		no_½_shape     OF (no.½.shape) ENDOF		interpolate_½  OF indx (interpolate.½): self ENDOF		." Can't find ½, bad case value " dup . cr 	ENDCASE;m\ ======================================================\ 		SMART ½ ROUTINE\ ======================================================\ Mutation degree should be used by all mutation methods\ number between 0 and 1000, like metrics\ In the routine below, mut-shape is the external shape, ½-shape is the instance-shape\ the execution of the user function should uses exec.stack? from misc_tools\ and pass itself the name of the mutation, but it doesn't at present. it just\ takes nothing on the stack and executes the word\ If you just want ½, without using the function or the shape, call GET.½:\ If there is a function use it. If there's not, but there is a shape, use that. \ If there is a shape, it can be interpolated, or just used as is ("spread" across\ the mutant).\ If neither shape nor function, just get ½:m GET.SMART.MUTATION-DEGREE: { indx -- ½ }	get.½.function: self	0= not 	IF		self get.½.function: self 0 exec.stack?		0 1000 clipto	ELSE		get.½.shape: self		0= not		IF		interpolate.½-shape?			IF				 indx interpolate.½: self			ELSE				\ don't interpolate the shape, just "stretch" the mutation				\ degree shape over the mutant				iv-mutation-degree.shape many: [] 		  	  	indx many: self 				*/				0 temp-½-shape ed.at: []			THEN		ELSE			iv-mutation-degree		THEN	THEN;m:M GET.SMART.½: { indx -- ½ }	indx get.smart.mutation-degree: self;m:m PUT.MUTATION-DEGREE:	0 1000 clipto	iv=> iv-mutation-degree;m:m GET.MUTATION-DEGREE:	iv-mutation-degree;m:M GET.½: 	get.mutation-degree: self;m:M PUT.½: 	put.mutation-degree: self;m\ =================================================\ 			SIZE CHECKING \ =================================================:M TARGET.BIG.ENOUGH.DIM?: ( -- flag, tests dim to see if target shape is )( at least as big as the source )	iv-target-shape 	\ first check to see if the shape exists	dup 0=	IF		drop ." No target shape present .... " cr		true	ELSE		dim>: self		not 	THEN;m:M TARGET.BIG.ENOUGH.MANY?: ( -- flag, tests dim and many to see if )\ target is at least as big as the source.	\ If the source is bigger than the target, do not do it...	\ currently there is no scaling algorithm...	iv-target-shape 	dup 0=	IF		drop ." No target shape present .... " cr		true	ELSE		many>: self		not 	THEN;m\ Added this method because in this new class, both a source and\ target are used by the mutator...:M SOURCE.BIG.ENOUGH.MANY?: ( -- flag, tests dim and many to see if )	iv-source-shape 	dup 0=	IF		drop ." No source shape present .... " cr		true	ELSE		many>: self		not 	THEN;m:M SOURCE.BIG.ENOUGH.DIM?: ( -- flag, tests dim and many to see if )	iv-source-shape 	dup 0=	IF		drop ." No source shape present .... " cr		true	ELSE		dim>: self		not 	THEN;m: PRINT.SIZE.WARNING ( -- , target not as big as source )	source.big.enough.many?: self IF ." Source is too small in many to mutate " cr THEN	source.big.enough.dim?: self IF ." Source is too small in dim to mutate " cr THEN	target.big.enough.dim?: self IF ." Target too small dimension to mutate " cr THEN	target.big.enough.many?: self IF ." Target too small in many to mutate " cr THEN;		:M CHECK.SIZES: ( -- flag )	sync.target-index: self	source.big.enough.dim?: self	source.big.enough.many?: self or	target.big.enough.dim?: self or	target.big.enough.many?: self or;M\ ***************************************\ Zero-override? is a value which decides whether or not a source\ interval  (either contour or magnitude) of zero will be used:\ that is, if z-override? is ON (true), then for a source int. of\ zero, the target contour and magnitude will be used, if it is OFF\ then the source interval will "zero" out whatever target direction\ or magnitude:M ZERO-OVERRIDE?.ON:	-1 iv=> zero-override?;m:M ZERO-OVERRIDE?.OFF:	0 iv=> zero-override?;m:M PUT.ZERO-OVERRIDE?: ( flag -- )	iv=> zero-override?;m:M GET.ZERO-OVERRIDE?:	zero-override?;m\ A clumping value of -1 means stochastic clumping:m GET.CLUMPING-VALUE: ( -- clumping-value )	iv-clumping-value;m:m PUT.CLUMPING-VALUE: ( -- , -1 indicates stochastic clumping... )	-1 1000 clipto iv=> iv-clumping-value;m:M PUT.¶:	put.clumping-value: self;m:M GET.¶:	get.clumping-value: self;m:m STOCHASTIC.CLUMPING?: ( -- flag )	get.clumping-value: self	-1 = IF true ELSE false THEN;M\ just an alternate name in case I forget:M IS.STOCHASTIC?: ( -- flag )	stochastic.clumping?: self;m\ any other value is clumping value....:M USE.STOCHASTIC.CLUMPING: 	-1 put.clumping-value: self;m:M PUT.½:	put.mutation-degree: self;M:M GET.½:	get.mutation-degree: self;M\ ==============================\ INTERNAL INTERVAL CALCULATIONS\ ===============================:M CALC.S-ABS: { indx -- }	indx indx get.interval-index: self	iv-source-shape abs.diff.interval: [] ( -- -1|0|1 value )	iv=> s-abs;m:M CALC.T-ABS: { indx -- }	indx indx get.interval-index: self	iv-target-shape abs.diff.interval: [] ( -- -1|0|1 value )	iv=> t-abs;m\ Remember: if i < j, -1 ("is less than", goes up); \ i>j +1 ("is greater than", goes down):M CALC.T-SIGN: { indx -- }	indx indx get.interval-index: self	iv-target-shape direction.interval: [] 	( -- -1|0|1 )	iv=> t-sign;m:M CALC.S-SIGN: { indx -- }	indx indx get.interval-index: self	iv-source-shape direction.interval: [] 	( -- -1|0|1 )	iv=> s-sign;m:M CALC.S-SIGNED-INT: { indx -- }	indx indx get.interval-index: self	iv-source-shape signed.diff.interval: [] 	iv=> s-signed-int;m:M CALC.T-SIGNED-INT: { indx -- }	indx indx get.interval-index: self	iv-target-shape signed.diff.interval: [] 	iv=> t-signed-int;m\ #-changed = (#-different*½/1000)\ #-changed*¶ = clumpsize\ only count non-different intervals...\ You pass it it's own #-different because that will be different\ for the specific interval for each mutation.\ Mutate rate is an adjusted clumpsize, which takes into account \ a ¶ of zero, and greater than .5:M COMPUTE.CLUMPSIZE: {  #-different   -- }	get.¶: self 0=	not \ if non-zero: ½ * ¶ * #-diff	IF		#-different get.smart.½: self 1000 */.roundup		get.¶: self 1000 */.roundup ( gives you actual number of interval that are going to be changed )		iv=> iv-clumpsize	THEN;m\ simply adds a value to the current index, which could be a phantom\ fundamental:M (ADD.TO.MUT.INT): { val indx -- }	indx get.interval-index: self	curr-dim ed.at: self ( -- old-val )	val + 	indx curr-dim clip.ed.to: self;M\ Significant change this for new mutants from older mutators:\ here if either the target or the source is 0, the mutant interval\ will be zero (not the case in the old interval calculation).\ In other words, if the INTERVAL overrides the CONTOUR....\ That is, if the interval of the source is zero, and the direction of the \ target is positive or negative, the mutant will have a zero interval and thus\ a zero direction....	\ ===============\   LCM Mutation\ ===============\ Inner routine for changing a linear contour interval, either clumping or stochastic clumping:M (LCM.INTERVAL.CHANGE): { indx -- }	indx calc.t-sign: self	indx calc.s-abs: self	s-abs 0= zero-override? and 	IF		indx calc.t-abs: self ( if the mag. of the source is zero )		t-abs t-sign ( use the mag. of the target with z-override? on )	ELSE		s-abs t-sign	THEN	* ( -- signed value, or 0 if target was equal... )		indx (add.to.mut.int): self;m:M (LCM.NO.CHANGE): { indx -- }	indx calc.s-abs: self	indx calc.s-sign: self	s-abs s-sign	*	indx (add.to.mut.int): self;m\ inner routine for stochastic clumping mutation of LCM:m (LCM.STOCHASTIC): \ stochastic clumping algorithm\ doesn't matter here if you check to see if the intervals are different: the probability\ doesn't change depending on how many intervals you change	many: self         \ length of mutator	interval.start: self	DO		1000 choose i get.smart.½: self 		< 		IF			i (LCM.INTERVAL.CHANGE): self		ELSE			i (LCM.NO.CHANGE): self		THEN	LOOP;M:m (LCM.CLUMPING): { |  int-count clump-count -- }	iv-target-shape iv-source-shape #.diff.lin.cont: []	compute.clumpsize: self	0 -> int-count 	0 -> clump-count	many: self \ end of the morphology	interval.start: self \ start of the morphology	DO		\ first check to see if intervals are the same		i iv-source-shape get.interval-index: []		i iv-source-shape direction.interval: []		i iv-target-shape get.interval-index: []		i iv-target-shape direction.interval: []		= not	\ yes they are different		IF		THEN	LOOP;M\ LINEAR CONTOUR MUTATION\ ½, source and target must already be stored into mutant:M LCM: 	( -- )	check.sizes: self	IF		stochastic.clumping?: self		IF			(lcm.stochastic): self		ELSE			(lcm.clumping): self		THEN	ELSE print.size.warning	THEN;m\ ================================\   IUIM Mutation\ ================================:M (IUIM.INTERVAL.CHANGE): { indx -- }	indx calc.t-abs: self	indx calc.s-sign: self	s-sign 0= zero-override? and 	IF		indx calc.t-sign: self ( if the sign of the source is zero )		t-abs t-sign ( use the sign of the target with z-override? on )	ELSE		t-abs s-sign 	THEN	* \ Change the sign appropriately,	\ Add it to the fund. element of the source	indx (add.to.mut.int): self;m:M (IUIM.NO.CHANGE): ( indx -- )	 (lcm.no.change): self;m:M (IUIM.STOCHASTIC):	\ stochastic clumping algorithm	many: self         \ length of mutator	interval.start: self	DO		1000 choose i get.smart.½: self <  		IF			i (IUIM.INTERVAL.CHANGE): self		ELSE			i (IUIM.NO.CHANGE): self		THEN	LOOP;m:M (IUIM.CLUMPING): {  | curr-skip -- }	iv-target-shape iv-source-shape #.DIFF.LIN.ABS.MAG: []	compute.clumpsize: self	many: self	interval.start: self	DO		\ first check to see if intervals are the same		i iv-source-shape get.interval-index: []		i iv-source-shape absolute.difference.interval: []		i iv-target-shape get.interval-index: []		i iv-target-shape absolute.difference.interval: []		= not		IF		THEN	LOOP;m:M IUIM:	check.sizes: self	IF stochastic.clumping?: self		IF			(IUIM.stochastic): self		ELSE			(IUIM.clumping): self		THEN	ELSE		print.size.warning	THEN;m\ ================================\   UUIM Mutation\ ================================\ Martin's equation: mi + s-sign((s-abs+½(|(t-abs) - (s-abs)|):M (UUIM.INTERVAL.CHANGE): { indx  -- }	indx calc.t-abs: self	indx calc.s-abs: self	indx calc.s-sign: self	t-abs s-abs - ( abs ) ( absolute value of diff. of absolute intervals source & target )	indx get.smart.½: self 1000 */.roundup ( times ½ )	s-abs + ( plus the absolute source interval )	s-sign 0= zero-override? and 	IF		indx calc.t-sign: self ( if the sign of the source is zero )		t-sign *	ELSE		s-sign * ( times the sign of the source, standard interval change )	THEN	indx (add.to.mut.int): self;m	\ Uniform unsigned interval magnitude mutation:M UUIM:	check.sizes: self	IF 		many: self		interval.start: self		DO			i (uuim.interval.change): self		LOOP	ELSE		print.size.warning	THEN;M\ ================================\   USIM Mutation\ ================================\ Mi = Mi-1 + (½*(tmag*tsgn) - (ssgn*smag)) + (ssgn*smag):M (USIM.INTERVAL.CHANGE): { indx  -- }		indx calc.t-signed-int: self		indx calc.s-signed-int: self		t-signed-int s-signed-int -		indx get.smart.½: self 1000 */.roundup ( times ½ )		s-signed-int +		indx (add.to.mut.int): self;m\ There is a typo in Martin's thesis, the AM should just be called\ a value mutation, it doesn't crossfade absolute values, just values\ Uniform signed interval magnitude mutation:M USIM:	check.sizes: self	IF 		many: self		interval.start: self ( just doing intervals )		DO			i (usim.interval.change): self		LOOP	ELSE		print.size.warning	THEN;M\ value mutation, same as USIM: if the starting values \ are the same, otherwise a point-by-point crossfade:M (VM.INTERVAL.CHANGE): { indx -- }	indx curr-dim iv-source-shape ed.at: []	indx curr-dim iv-target-shape ed.at: [] ( -- si ti )	indx curr-dim iv-source-shape ed.at: [] ( -- si ti si )	- ( -- si ti-si )	indx get.smart.½: self 1000 */.roundup	+	indx curr-dim ed.to: self;m\ absolute magnitude mutation	:M VM:  		check.sizes: self	IF 		many: self		0		DO			i (Vm.interval.change): self		LOOP	ELSE		print.size.warning	THEN;M\ ================================\   DOOM Mutation\ ================================\ \ Inner routine for zeroing an interval, either clumping or stochastic clumping:M (DOOM.CHANGE): { indx -- }	0 indx curr-dim ed.to: self;m\ inner routine for stochastic clumping mutation of LCM:m (DOOM.STOCHASTIC): \ stochastic clumping algorithm\ doesn't matter here if you check to see if the intervals are different: the probability\ doesn't change depending on how many intervals you change	many: self         \ length of mutant	0	DO		1000 choose i get.smart.½: self < 		IF			i (DOOM.CHANGE): self		THEN	LOOP;M\ at present, use this one last... none of the other mutations are sensitive to zero values...\ so it'll really screw up the other interval calculations if used as the inner in a \ concatenated mutation....\ DROP OUT ONLY MUTATION\ ½, source and target must already be stored into mutant:M DOOM: 	( -- )	check.sizes: self	IF		stochastic.clumping?: self		IF			(doom.stochastic): self		ELSE		   ." not defined for clumping yet " cr		THEN	ELSE print.size.warning	THEN;m\ ================================\   ISIM Mutation\ ================================\ \ This is the same as an VM or USIM mutation, but with an irregular indx.: (ISIM.INTERVAL.CHANGE) { indx -- }		indx calc.t-abs: self		indx calc.t-sign: self		t-abs t-sign * \ Change the sign appropriately,		\ Add it to the fund. element of the source		indx (add.to.mut.int): self;:M (ISIM.NO.CHANGE): ( indx -- )	 (lcm.no.change): self;m:M (ISIM.STOCHASTIC):	\ stochastic clumping algorithm	many: self         \ length of mutator	interval.start: self	DO		1000 choose 		i get.smart.½: self <  		IF			i (ISIM.INTERVAL.CHANGE)		ELSE			i (ISIM.NO.CHANGE): self		THEN	LOOP;m:M (ISIM.CLUMPING): {  | curr-skip -- }	iv-target-shape iv-source-shape #.DIFF.LIN.SIGNED.MAG: []	compute.clumpsize: self	many: self	interval.start: self	DO		\ first check to see if intervals are the same		i iv-source-shape get.interval-index: []		i iv-source-shape signed.diff.interval: []		i iv-target-shape get.interval-index: []		i iv-target-shape signed.diff.interval: []		= not		IF		THEN	LOOP;m:M ISIM:	check.sizes: self	IF stochastic.clumping?: self		IF			(ISIM.stochastic): self		ELSE			(ISIM.clumping): self		THEN	ELSE		print.size.warning	THEN;m\ these preserve the source, and put it back in at the end:M LCM/IUIM: { | old-source -- }	get.source: self	-> old-source	lcm: self	self put.source: self	iuim: self	old-source put.source: self;M:M LCM/UUIM: { | old-source -- }	get.source: self	-> old-source	lcm: self	self put.source: self	uuim: self	old-source put.source: self;M\ ==============================\ Printing utilities\ ==============================\ Diagnostic print statement\ uses current dimension, and prints source, target and mutant:M SHOW.MUTATION: 	cr ." Source " cr	get.curr-dim: self	dup get.source: self 	dup 0= not 	IF ph: []	ELSE drop drop	THEN	cr ." Target " cr	dup get.target: self 	dup 0= not 	IF ph: []	ELSE drop drop	THEN	cr ." Mutant " cr 	ph: self;m:M PRINT:	print: super	get.½: self ." Mutation degree (½): " . cr	iv-mutation-degree.shape dup 0= not 		IF ." Mutation-degree shape: " name: [] cr 		ELSE drop ." No ½-shape " cr		THEN	." Minimum ½: " get.min.½: self . cr	." Maximum ½: " get.max.½: self . cr		iv-mutation-degree.function dup 0= not 		IF	." Mutation-degree function: "			iv-mutation-degree.function cfa. cr		ELSE			drop ." No ½-function " cr		THEN	is.stochastic?: self	IF		." Stochastic clumping "	ELSE		." Clumping value (¶) is: " get.¶: self  	THEN	cr	zero-override? 	IF		." Zero override is on "	ELSE		." Zero override is off "	THEN	cr	iv-mutation-degree.shape 0= 	IF		." Interpolating from ½-shape (if shape in use) "	ELSE		." Not interpolating from ½-shape "	THEN	cr;M;CLASSob.mutant mooob.mutant moo-sourceob.mutant moo-targetob.new-shape change-shape: CALC drop 1000 choose ;	: TERM.MUTANT	free: moo	free: moo-source	free: moo-target	free: change-shape;	: TEST.MUTANT	6 1 new: change-shape	stuff{ 100 20 25 100 80 0 }stuff: change-shape	10 1 new: moo	10 1 new: moo-source	10 1 new: moo-target	stuff{ 60 64 62 67 69 60 72 65 66 61 }stuff: moo	stuff{ 60 61 62 64 66 68 69 72 73 76 }stuff: moo-source	stuff{ 80 76 70 67 64 61 58 53 53 53 }stuff: moo-target\	'c calc put.½.function: moo	change-shape put.½.shape: moo	0 put.min.½: moo	1000 put.max.½: moo	moo-source put.source: moo	moo-target put.target: moo	use.fundamental: moo	66 0 put.fundamental: moo	use.fundamental: moo-target	66 0 put.fundamental: moo-target	use.fundamental: moo-source	66 0 put.fundamental: moo-source	." moo " 0 ph: moo cr	." target " 0 ph: moo-target cr 	." source " 0 ph: moo-source cr	interpolate.½-shape: moo;if.forgotten term.mutant