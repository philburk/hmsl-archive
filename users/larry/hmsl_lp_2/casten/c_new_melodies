\ create new melodies and test them....anew task-c_new_melodiesob.objlist new-whole-pieceob.shape new-s-whole-pieceob.objlist new-all-groupsob.objlist new-section-1ob.objlist new-section-2ob.objlist new-section-3ob.objlist new-section-4ob.objlist new-section-5ob.shape new-metrics-1ob.shape new-metrics-2ob.shape new-metrics-3ob.shape new-metrics-4ob.shape new-metrics-5ob.objlist new-metric-list4 k: much-longer: INIT.NEW-WHOLE-PIECE	2500 2 new: new-s-whole-piece	5 new: new-whole-piece	5 new: new-metric-list	400 new: new-all-groups	new-section-1 add: new-whole-piece	new-section-2 add: new-whole-piece	new-section-3 add: new-whole-piece	new-section-4 add: new-whole-piece	new-section-5 add: new-whole-piece\	new-metrics-1 add: new-metric-list	new-metrics-2 add: new-metric-list	new-metrics-3 add: new-metric-list	new-metrics-4 add: new-metric-list	new-metrics-5 add: new-metric-list;: INIT.NEW-SECTIONS	much-longer 12 * dup 	new: new-section-1 	11 new: new-metrics-1	much-longer 15 * dup 	new: new-section-2 	11 new: new-metrics-2	much-longer  57 * dup 	new: new-section-3 	11 new: new-metrics-3	much-longer  15 * dup 	new: new-section-4 	11 new: new-metrics-4	much-longer 12 * dup 	new: new-section-5 	11 new: new-metrics-5;: INTERPOLATE.METRICS 	{ idx section-# curr-int #-new | curr-m-list --  }		11 0 DO			0   \ x1			idx i  			section-# rcs-metric-list at: [] 			ed.at:  []  \ x1 y1			#-new 1+   \ x2			idx 1+ i  section-# rcs-metric-list at: [] ed.at: []  \ y2			set.interp			curr-int 1+  			interp 		LOOP		section-#  at: new-metric-list		-> curr-m-list		curr-m-list add: [];: MAKE.NEW-SHAPES 	." Instiantiating new shapes " cr	{ | #-new section-# curr-int idx len curr-section curr-shape curr-m-list curr-old-section curr-old-shape -- }	5 0 DO		cr ." section  " i 1+ . 		i -> section-#		i at: new-whole-piece  -> curr-section		i at: whole-piece -> curr-old-section		curr-old-section many: [] 0 		DO				i -> idx			idx curr-old-section at: []			-> curr-old-shape		\ first new the new shape....			instantiate ob.m.shape 			-> curr-shape			." . "		\ now check to see if it's not the first or last shapes...			idx 0= not			idx curr-old-section many: [] 1- = not 			and			IF				curr-old-shape many: []				much-longer choose + 			ELSE				curr-old-shape many: []			THEN			dup -> len			2 curr-shape new: []	\ put in weight functions			'c mw.1/i curr-shape put.linear.weight.function: []			'c mw.1/i curr-shape put.row.weight.function: []				'c mw.1/i curr-shape put.column.weight.function: []	\	now add it in to the new section...					curr-shape curr-section			add: []	\ now do the metrics...			section-#  at: new-metric-list			-> curr-m-list			idx section-# at: rcs-metric-list get: []			curr-m-list add: []			1 curr-shape put.curr-dim: []\ now interpolate in some new shapes, unless it's the last in the section...			idx curr-old-section many: [] 1- = not			IF				much-longer 0 wchoose -> #-new				#-new 0 DO					i -> curr-int					instantiate ob.m.shape 					-> curr-shape					." ' "					 0 len  #-new 1+					idx 1+ curr-old-section at: [] 					many: []  					set.interp					curr-int 1+ interp 					2 curr-shape new: []\ put in weight functions					'c mw.1/i curr-shape put.linear.weight.function: []					'c mw.1/i curr-shape put.row.weight.function: []						'c mw.1/i curr-shape put.column.weight.function: []	\	now add it in to the new section...							curr-shape curr-section					add: []						1 curr-shape put.curr-dim: []\ now add in metrics...					idx section-# curr-int #-new interpolate.metrics				LOOP			THEN		LOOP	LOOP;: STUFF.NEW-SHAPES { | curr-section curr-shape -- }	cr ." Stuffing new shapes " cr	5 0 DO		i get: new-whole-piece		-> curr-section		curr-section many: []  0		DO			i curr-section at: []			-> curr-shape			curr-shape max.elements: [] 0 			DO				16th 0 curr-shape add: []			LOOP		LOOP	LOOP;	: INIT.NEW-ALL-GROUPS { | curr-section -- }	cr ." Initializing all groups " cr	5 0 DO		i get: new-whole-piece		-> curr-section		curr-section many: []  0		DO			i curr-section at: []			add: new-all-groups		LOOP	LOOP	cr;	: PRINT.NEW.MANYS { | curr-section curr-shape -- }	cr	many: new-whole-piece 0 	DO		i  		dup ." Section " . tab		at: new-whole-piece		-> curr-section 		curr-section many: [] 0		DO			i  curr-section at: []			-> curr-shape			curr-shape max.elements: [] .		LOOP		cr	LOOP;: INIT.NEW-PIECE	init.new-whole-piece	init.new-sections	make.new-shapes	stuff.new-shapes	init.new-all-groups	print.new.manys	; init.new-piece		: TERM.NEW-WHOLE-PIECE	freeall: new-whole-piece	freeall: new-metric-list	free: new-whole-piece	free: new-metric-list	free: new-s-whole-piece	free: new-all-groups;if.forgotten term.new-whole-piece