\ make new melodies out of metric valuesanew task-c_create_new_melodies1 k: delta fvariable ab1.0 ab f!0.5 beta f!0.5 alpha f!v: idxv: section-#v: counterv: t-diff\ change these two variables to determine the # of tries that will either increment\ the acceptable window, or how often values will be printed...v: #-changev: #-print4000 #-change !1000 #-print !ob.shape c-data-array-1ob.shape c-data-array-2ob.shape c-data-array-3ob.shape c-data-array-4ob.shape c-data-array-5ob.objlist c-data-array: INIT.C-DATA-ARRAYS { | curr-array -- }	." Initializing data arrays " cr	5 new: c-data-array	c-data-array-1 add: c-data-array	c-data-array-2 add: c-data-array	c-data-array-3 add: c-data-array	c-data-array-4 add: c-data-array	c-data-array-5 add: c-data-array	5 0 DO		i at: c-data-array		-> curr-array		i at: new-whole-piece		many: []		13		curr-array		new: []		curr-array max.elements: [] 0 		DO			0 0 0 0 0 0 0 0 0 0 0 0 0 add: curr-array		LOOP		cr ." making names for dimensions now " cr		" alpha " 0 		curr-array put.dim.name: []			" beta " 1 			curr-array put.dim.name: []		" new-1 " 2			curr-array put.dim.name: []		" new-2 " 3			curr-array put.dim.name: []		" new-3 " 4			curr-array put.dim.name: []		" old-1 " 5			curr-array put.dim.name: []		" old-2 " 6			curr-array put.dim.name: []		" old-3 " 7			curr-array put.dim.name: []		" new average " 8	curr-array put.dim.name: []		" old average " 9 	curr-array put.dim.name: []		" final delta " 10 	curr-array put.dim.name: []		" #-reps " 11 		curr-array put.dim.name: []		" length " 12 		curr-array put.dim.name: []	LOOP;: ABCONSTANT		alpha f@ beta f@ f+ 		ab f!;	: A*B ( float float -- fix )	f+ ( float )	ab f@	f/ ( float/a+b)	1000.0 f* fix ;: MELODY.LOOP { |  curr-d-array last-note curr-m-list curr-section curr-mel temp-mel d-sum m-sum m-1 m-2 m-3 d-1 d-2 d-3 -- }number-do 0 DO			i section-# !		cr cr tab ." Section # " section-# @ . cr cr		section-# @ at: c-data-array -> curr-d-array		section-# @ at: new-whole-piece -> curr-section		section-# @ at: new-metric-list -> curr-m-list		curr-section  many: [] 1-  1 		DO			cr cr ." melody # " i . cr			i idx !			\ start out with  equal alpha and beta values for each melody			0.5 beta f!			0.5 alpha f!						\ first test against first melody...		idx @ curr-section at: [] -> curr-mel		idx @ 6 curr-m-list ed.at: [] -> m-1 \ ist avg		idx @ 7 curr-m-list ed.at: [] -> m-2 \ adj. avg		idx @ 8 curr-m-list ed.at: [] -> m-3 \ last avg\ create a new melody and test it to first...		0 counter !		0 t-diff !		BEGIN			counter @ 1+  counter !			counter @ 1000 mod 0= 			IF 				cr counter @ . 				\ much less frequently, change the alpha and beta values to give it a bit				\ of oompf if needed...				counter @ #-change @ 10 * mod 0= 				IF							1000 choose float 1000.0 f/ alpha f!					1000 choose float 1000.0 f/ beta f!					abconstant				THEN		THEN		0 -> last-note		curr-mel many: [] 0 		DO			i 0= idx @ 0=			and			IF 				idx @ 10 curr-m-list ed.at: []				idx @ 9 curr-m-list ed.at: []				wchoose			 	dup -> last-note			ELSE				BEGIN					idx @ 10 curr-m-list ed.at: []					idx @ 9 curr-m-list ed.at: []					wchoose ( note )					dup last-note = 						IF 							drop							false						ELSE							true						THEN				UNTIL			THEN			dup -> last-note				i 1 curr-mel ed.to: []		LOOP	\ now to first melody		curr-section first: [] -> temp-mel				curr-mel temp-mel ucd: []		alpha  f@ f* 		curr-mel temp-mel ucm: []		beta f@ f* 		a*b		-> d-1	\ now to adjacent  melody		idx @ 1- curr-section at: []  -> temp-mel				curr-mel temp-mel ucd: []		alpha  f@ f* 		curr-mel temp-mel ucm: []		beta f@ f* 		a*b 		-> d-2			\ now to last melody		curr-section last: []  -> temp-mel				curr-mel temp-mel ucd: []		alpha  f@ f* 		curr-mel temp-mel ucm: []		beta f@ f* 		a*b		-> d-3		\ when computing the differences in the averages, weight the first and last portions\ of the average such that melodies far from the first or the last are not given much\ weight...	\ now add them up. and do a city-block metric on them		d-1 float 			curr-section many: [] idx @ - float ( -- d-1 many )			curr-section many: [] float f/  ( -- d-1 many/many )			f*		d-2 float			d-3 float idx @ float curr-section many: [] 			float f/ f*			\ add up the three differences in axes, and divide by three to scale the metric		f+ f+ 3.0 f/ 		fix			-> d-sum					m-1 float curr-section many: [] idx @ - float 			curr-section many: [] float f/			f*			m-2 float			m-3 float idx @ float curr-section many: [] 			float f/ f*			\ add up the three differences in axes, and divide by three to scale the metric		f+ f+ 3.0 f/ 		fix			-> m-sum			m-sum d-sum - abs t-diff !			\ find their absolute value difference					counter @ #-print @ mod 0=		IF			 t-diff @ . cr		THEN		t-diff @ counter @ #-change @ /  1+ <		?terminal 		or	UNTIL			cr tab tab tab ." Melody # " idx @ . ." !!!!!!!!!!! " cr	alpha f@ 1000.0 f* fix	idx @ 0 curr-d-array ed.to: []	beta f@ 1000.0 f* fix 	idx @ 1 curr-d-array ed.to: []		d-1						idx @ 2 curr-d-array ed.to: []	d-2 					idx @ 3 curr-d-array ed.to: []	d-3 					idx @ 4 curr-d-array ed.to: []	m-1						idx @ 5 curr-d-array ed.to: []	m-2 					idx @ 6 curr-d-array ed.to: []	m-3 					idx @ 7 curr-d-array ed.to: []	d-sum					idx @ 8 curr-d-array ed.to: []		m-sum					idx @ 9 curr-d-array ed.to: []	t-diff @ 				idx @ 10 curr-d-array ed.to: []	counter	@		    	idx @ 11 curr-d-array ed.to: []	curr-mel many: [] 		idx @ 12 curr-d-array ed.to: []	cr cr	LOOPLOOP;init.c-data-arrays: TERM.C-DATA-ARRAY	freeall: c-data-array	free: c-data-array;if.forgotten term.c-data-array	