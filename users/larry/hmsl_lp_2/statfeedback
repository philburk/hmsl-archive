\ simple statistical feedback example\ 5/11/97anew task-statfeedbackob.shape source-probsob.shape adjusted-probsob.shape actual-statsv: #-choices100 #-choices !v: frame-length5000 frame-length !v: vel-value60 vel-value !v: tempo100 tempo !v: lo-offset40 lo-offset !2 k: no_feedback1 k: truncation_feedback0 k: levelling_feedbackv: curr-lengthv: feedback-typev: total-devv: average-devv: desired-statv: desired-curr-stat: FILL.ARRAYS	#-choices @ 1 new: source-probs	#-choices @  1 new: adjusted-probs	#-choices @  1 new: actual-stats		#-choices @  0 DO		1  add: source-probs		1 add: adjusted-probs		0 add: actual-stats	LOOP;: INIT.FEEDBACK	fill.arrays	truncation_feedback feedback-type !;: PLAY.NOTE { note-value -- }	lo-offset @ note-value 2/ + 	vel-value @ 	dup 20 100 */ choose dup 2/ swap - +	midi.noteon	tempo @ 	tempo @ 4 / choose	2 choose IF + ELSE - THEN	msec;: TAKE.DEVIATION { desired-value -- }	0 total-dev !	#-choices @ 0 DO		i 0 ed.at: actual-stats		desired-value - abs		total-dev +!	LOOP;: PRINT.STATS	frame-length @ #-choices @  / desired-stat !	desired-stat @ take.deviation	total-dev @ #-choices @  / average-dev !	cr cr ." STATS " cr	cr tab ." Frame length is: " frame-Length @ .	cr tab ." #_choices is: " #-choices @ .	cr tab ." sum of the deviations is: " total-dev ?	cr tab ." average: " average-dev ?	cr  tab ." dev. % is: " average-dev @ desired-stat @ 100 */ .	cr; : RUN.NO.FEEDBACK { | curr-choice -- }	frame-length @ 0 	DO		curr-length @ #-choices @ / 1+ desired-curr-stat !		\ pick a random value		#-choices @ choose 		-> curr-choice		curr-choice play.note		\ update stats		curr-choice 0 ed.at: actual-stats		1+ curr-choice 0 ed.to: actual-stats		1 curr-length  +!	LOOP;		: RUN.TRUNCATION.FEEDBACK { | curr-choice -- }	frame-length @ 0 	DO		curr-length @ #-choices @ / 1+ desired-curr-stat !		BEGIN			\ pick a random value			#-choices @ choose 			-> curr-choice			\ truncating....test to see if it's too big...			curr-choice 0 ed.at: actual-stats			desired-curr-stat @ > not 		UNTIL		curr-choice play.note		\ update stats		curr-choice 0 ed.at: actual-stats		1+ curr-choice 0 ed.to: actual-stats		1 curr-length  +!	LOOP;\ this is screwed up...: RUN.LEVELLING.FEEDBACK { | curr-index -- }	frame-length @ 0 	DO		\ find the minimum value		0 get.dim.min: actual-stats		indexof: actual-stats  		-> curr-index		curr-index play.note		\ update stats		curr-index 0 ed.at: actual-stats		1+  curr-index 0 ed.to: actual-stats	LOOP;: RUN.FEEDBACK	clear: actual-stats	0 total-dev !	0 curr-length !	0 desired-curr-stat !	feedback-type @		CASE		truncation_feedback of run.truncation.feedback endof		no_feedback of run.no.feedback endof		levelling_feedback of run.levelling.feedback endof	ENDCASE	print.stats	;: FT! ( feedback_type -- )	feedback-type !;	: TERM.FEEDBACK	free: source-probs	free: adjusted-probs	free: actual-stats;init.feedbackif.forgotten term.feedback