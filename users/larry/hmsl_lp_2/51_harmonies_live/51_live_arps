\ 51 harmonies live part\ arpeggio playeranew task-51_live_arps\ arp-player is defined in constantsob.instrument arp-instrumentv: arp-repeat-flagv: arp-first-note  \ first note of collection; 0 if it is first note, 1 if it's notv: arp-transpose-factorv: arp-drop-out-factorv: arp-prev-notev: arps-on?: ARP-PLAYER-START.FUNC { player | coll shape -- }	0 arp-first-note !	\ first set preset for this section	arp 1+ midi.channel!	arp #-presets choose 	ed.at: 51-presets midi.preset	\ now get the current collection, and add the shapes to this player	\ and also compute the total collection time	0 collection-time !	curr-section @ 	at: collection-list	-> coll	coll many: []	player set.many: []\	curr-section @ 0= not\	IF\		tab ." Times: "\	THEN	many: coll 0 	DO		i coll at: []		-> shape		\ add to collection-time		shape many: []  ( dup . ." " )		collection-time +! 		shape i player put: []	LOOP	cr	\ pick a random octave, and select a drop out factor	3 choose 1 - arp-transpose-factor ! 	triangle-value  arp-drop-out-factor ! ;: ARP-PLAYER-REPEAT.FUNC { player | coll -- }	0 arp-repeat-flag !	0 arp-first-note !	\ look for foot switch	next-section? @ 1 =	\ if it's supposed to go to the next section, just stop yourself	IF		\ if it's the last section, and you get a stop message		curr-section @ 50 =		IF			player stop: []			stop: 51-live-coll \ also stop the collection....		ELSE			player stop: [] \ the stop function should stop all the other voices			0 next-section? ! \ reset the switch		THEN	THEN;		\ the arps player is responsible for also stopping all of the other players\ though it doesn't really need to stop the chords-player, for instance: ARP-PLAYER-STOP.FUNC { player | coll -- }	stop: chord-player	stop: accent-player	stop: perc-player	stop: melody-1-job	stop: melody-2-job;	: ARP-PLAYER-DUR.FUNC 	2drop	arp-pulse ;: INIT.ARP-PLAYER	max-shapes new: arp-player	1 put.repeat: arp-player	arp-instrument put.instrument: arp-player	'c arp-player-dur.func put.dur.function: arp-player	'c arp-player-start.func put.start.function: arp-player	'c arp-player-repeat.func put.repeat.function: arp-player	'c arp-player-stop.func put.stop.function: arp-player;: ARP.VEL { el -- }	\ if arps is turned off, set all velocities to be zero	 arp at: voices-on? 	IF		el 0= arp-first-note @ 0= and		IF			127 110 wchoose		ELSE			el 0= 			IF				105 90 wchoose				ELSE			85 30 wchoose			THEN		THEN	ELSE		0	THEN	arp at: voice-loudness 100 */;: ARP-INSTRUMENT.FUNC {  el shape ins | curr-note -- }	ins get.channel: []  midi.channel!	midi.lastoff	\ first test to see if note is played, the greater the first number	\ the less likeley the drop out is	\ but never drop out the first note	el 0= arp-first-note @ 0= and not	300 choose arp-drop-out-factor @ <	and	IF		0 0 midi.noteon	ELSE		el shape at: [] 		arp-transpose-factor @ 12 * + 		 -> curr-note		\ a certain percentage of the time, straighten out the arpeggio		10 choose 3 < 		IF			curr-note arp-prev-note @ -			abs 6 >			IF				curr-note arp-prev-note @ >				IF					curr-note 12 + -> curr-note				ELSE					curr-note 12 - -> curr-note				THEN			THEN		THEN		curr-note el arp.vel  midi.noteon		\ is first note of collection, then play a note an octave above or below		el 0= arp-first-note @ 0= and		 IF			\ if so, add an octave above or below			4 choose 0 =			IF				curr-note 12 +			ELSE				curr-note 12 -			THEN			el arp.vel arp-pulse 5 1 wchoose * midi.noteon.for			1 arp-first-note !		THEN		curr-note  arp-prev-note !	THEN;	: INIT.ARP-INSTRUMENT	0 put.offset: arp-instrument	arp 1+ put.channel: arp-instrument	'c arp-instrument.func put.on.function: arp-instrument;: INIT.ARPS	init.arp-player	init.arp-instrument;: TERM.ARPS	free: arp-player	free: arp-instrument;if.forgotten term.arps