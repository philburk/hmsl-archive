anew task-piker_compute\ have to test to see if it's a melody note, and it should\ be higher if it's after a 2 beat note: COMPUTE.SILENCE {  p-count -- flag }	\ first compute duration probability for each note 	\ goes from 0 to 25%	p-count silence_scalar / silence-prob !		\ first see if the note before it was a melody note and has a 2 dur	\ if so multiply the probability of silence by 2 to bring out the short 	\ notes a bit at the end...	p-count melody_length mod 	1- 0 max melody_duration ed.at: p-shape	2 =	IF		silence-prob @ 2* silence-prob !	THEN	100 choose silence-prob @ < \ silence prob	p-count melody_length mod 	melody_note? ed.at: p-shape 1 = not \ and not a melody note	and ( -- flag )	IF		\ zero out pitch and velocity		0 i 1 ed.to: r-shape		0 i 2 ed.to: r-shape	THEN;	\ new version just uses melody notes all the way through...: COMPUTE.MELODY.NOTE {  p-counter | curr-note new-range -- }	p-counter melody_length mod melody_note? ed.at: p-shape	IF		p-counter melody_length mod melody_note ed.at: p-shape		-> curr-note		\ get range around melody notes, which shrinks...\		out_length p-counter - melody_range out_length */ -> new-range\		new-range 2/ curr-note + curr-note new-range 2/  - wchoose\		new-range 2/ curr-note + curr-note new-range 2/  - wchoose\		+ 2/		curr-note		 p-counter 1 ed.to: r-shape		\ make its volume louder as the piece progresses, goes from 60 to 100		p-counter 40 out_length */ 60 +		p-counter 2 ed.to: r-shape	THEN;\ gradually moves notes to low end of range or high end of range\ range is a moving five notes, starting around 73\ for two iterations, the range grows out to 5, then the 5 moves...: COMPUTE.NON-MELODY.NOTE { p-counter | curr-note new-range -- }	p-counter melody_length mod melody_note? ed.at: p-shape	not 	IF		\ if we're in the first half of the piece, expand outward to 		\ full range of random notes		p-counter out_length 2/ <		IF			p-counter high_note low_note -			out_length 2/ */			1+			 -> new-range 			new-range 2/ center_note + 1+ center_note new-range 2/  - 			wchoose			p-counter 1 ed.to: r-shape			\ make its volume softer			60 p-counter 30 out_length */ - 			p-counter 2 ed.to: r-shape		ELSE			\ gradually contract the range in the second half of the piece			\ to the bottom and top five notes (D -> D two octave range)			\ keeping these random notes "out of the way" of the			\ melody			2 choose  			IF				\ pick the low note				center_note 				p-counter out_length 2/ mod 				center_note low_note noise_band  + - 				out_length 2/ */ 				- 				low_note 				wchoose			ELSE				\ pick the high note				high_note 1+ ( -- high )				p-counter out_length 2/ mod ( -- p-count high )				high_note noise_band - center_note  -  ( -- center pcount range )				out_length 2/ */ 				center_note +				wchoose			THEN			 p-counter 1 ed.to: r-shape			\ make its volume softer as the piece progresses, goes from 60 to 100			60 p-counter 30 out_length */ - 		 	p-counter 2 ed.to: r-shape			THEN			THEN;: COMPUTE.PIKER { | p-counter -- }	out_length 0 DO		i compute.melody.note		i compute.non-melody.note		i compute.silence 	LOOP;: PIKER.CAPTURE	" piker:foomidi" $midifile0{	r-player hmsl.play	}midifile0;: TERM.P-SHAPES	free: p-shape	free: s-shape	free: r-shape	free: r-player;: INIT.PIKER	init.p-shapes	fill.s-shape	add.source.to.melody	init.r-player	." piker initialized " cr	compute.piker ." piker computed " cr;: TERM.PIKER	term.p-shapes;init.pikerif.forgotten term.piker