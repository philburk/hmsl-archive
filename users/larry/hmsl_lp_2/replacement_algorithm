\ replacement algorithm tests\ polansky\ 10/24/97\ begun at 10:58 p.m\ finished at 10:46 p.m\ this reorders a melody, randomly, without the possiblity of\ an element remaining (so is not a "shuffle")\ the algorithm is based on a random reordering to a distinct place\ until the last one, which seems to require a special case (particular if\ there are an odd number of elements)\ this came out of a discussion with matthew smith and sarah meyersanew task-replacement_algorithmob.shape source-melodyob.shape replacement-melodyob.player source-melody-playerob.player replacement-melody-player60 k: melody_length18 k: fundamental_pitch4 k: melody_durfalse hmsl-graphics !: INIT.MELODIES	melody_length 4 new: source-melody	melody_length 4 new: replacement-melody	melody_length 0 DO		melody_dur 3 2 */ melody_dur wchoose		fundamental_pitch i + 90 50 wchoose  0 add: source-melody		0 0 0 0 add: replacement-melody	LOOP	print: source-melody	print: replacement-melody	1 new: source-melody-player	1 new: replacement-melody-player	source-melody add: source-melody-player	replacement-melody add: replacement-melody-player	ins-midi-1 put.instrument: replacement-melody-player	ins-midi-1 put.instrument: source-melody-player	0 put.offset: ins-midi-1;: MOVE.A.NOTE { indx | new-indx -- }	BEGIN		melody_length choose 		-> new-indx 		new-indx		indx = not		new-indx 3 ed.at: replacement-melody		0=		and		?terminal or	UNTIL	indx get: source-melody	new-indx put: replacement-melody	true new-indx 3 ed.to: replacement-melody		;: MOVE.MOST.NOTES	melody_length 1- 0 DO		i move.a.note	LOOP;: MOVE.LAST.NOTE { | new-indx done? -- }	\ first go thru the replacement, and if something	\ other than the last one is open, just stick the last source	\ there	melody_length 1- 0 DO		i 3 ed.at: replacement-melody		0=		IF			melody_length 1- get: source-melody			i put: replacement-melody			true i 3 ed.to: replacement-melody			true -> done?		THEN	LOOP	done? not	\ if by some chance it was the last one that needed replacing, we have	\ to do the swapping trick	IF		\ plop the last one on the stack		melody_length 1- get: source-melody		\ get one at random from the replacemnt		melody_length choose 		-> new-indx		new-indx get: replacement-melody		\ put it in the last place		melody_length 1- put: replacement-melody		\ now put the last one in that holder		new-indx put: replacement-melody		true new-indx 3 ed.to: replacement-melody	THEN;: PS 	source-melody-player hmsl.play;: PR	replacement-melody-player hmsl.play;: DOIT	INIT.MELODIES	MOVE.MOST.NOTES	MOVE.LAST.NOTE	print: replacement-melody	20 midi.program;doitob.shape scramble-shape: SCRAMBLE.TEST	15 1 new: scramble-shape	15 0 DO		i add: scramble-shape	LOOP	0 14 0 scramble: scramble-shape	print: scramble-shape;: SCRAMBLE.TESTS { shape-length #-trials | #-bad -- }	0 -> #-bad	#-trials 0 DO		shape-length 1 new: scramble-shape		shape-length 0 DO			i add: scramble-shape		LOOP		0 shape-length 1- 0 scramble: scramble-shape		\ test to see if last one is still in same place		shape-length 1- 0 ed.at: scramble-shape		shape-length 1- = 		IF #-bad 1+ -> #-bad THEN	LOOP	#-bad . ."  bad " #-bad 100 #-trials  */ . ." % " cr		;: SCRAMBLE.ALL.TESTS { shape-length #-trials | #-bad -- }	0 -> #-bad	#-trials 0 DO		shape-length 1 new: scramble-shape		shape-length 0 DO			i add: scramble-shape		LOOP		0 shape-length 1- 0 scramble: scramble-shape		\ test to see if last one is still in same place		shape-length 0 DO			i 0 ed.at: scramble-shape						i  cr = 			IF #-bad 1+ -> #-bad THEN		LOOP	LOOP	#-bad . ."  bad " #-bad 100 #-trials  */ . ." % " cr		;	: TERM.MELODIES	free: source-melody	free: replacement-melody	free: source-melody-player	free: replacement-melody-player	free: scramble-shape;if.forgotten term.melodies				