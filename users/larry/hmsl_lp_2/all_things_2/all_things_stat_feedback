\ all_things_stat_feedbackanew task-all_things_stat_feedback\ go through adjusted array and find probabilistic value: FIND.ARRAY.VALUE {  rand-value | temp-sum -- last-value-lower }	0 -> temp-sum	0 \ put top value  of the array	  \ on the stack in case it slips through to the end	pitch_range 0 DO		i at: p-dist-adjusted		temp-sum + -> temp-sum		rand-value temp-sum <		IF drop i  LEAVE THEN	LOOP;\ if weighted add the duration, if not, just add one: UPDATE.STATS { t-index  duration -- }	t-index at: p-stats	weighted? @ IF		duration + t-index to: p-stats	ELSE		1+ t-index to: p-stats	THEN;: EXPONENTIAL.CROSSFADE { | section-length -- }	piece_length #_sections /	-> section-length	curr-time @ section-length mod ( -- how far in section )	100 section-length */ ( 0-100 )	float	100.0 f/ ( floating point 0-1 	fsqrt	100.0 f*	int	dist-fade !;	\ this version uses floating point for exponential\ find a new number 0-100 which determines probability dist. mix: LINEAR.CROSSFADE { | section-length -- }	piece_length #_sections /	-> section-length	curr-time @ section-length mod ( -- how far in section )	100 section-length */\	 dup . tab 	dist-fade !;\ a value of 1 to cross-fade type gives a linear crossfade, a value of 0 is exponential: UPDATE.CROSSFADE	crossfade-type @	IF		linear.crossfade	ELSE		exponential.crossfade	THEN;: GET.NORMALIZED.VALUE { t-index temp-array | temp-sum -- value }	0 -> temp-sum	pitch_range 0 DO		i temp-array at: []		temp-sum + -> temp-sum	LOOP	t-index temp-array at: []	1000 temp-sum 	1 max ( guard against first time through 0 divide )	*/;: UPDATE.CROSSFADE.ARRAY	pitch_range 0 DO		i source-dist @ at: []		100 dist-fade @ - 100 */		i target-dist @ at: []		dist-fade @ 100 */		+ \		dup .		i to: p-dist-adjusted	LOOP;\ make a new probablility array from stats and probs, and crossfade prob will creep\ towards stats: UPDATE.ADJUSTED.ARRAY	pitch_range 0 DO		i curr-dist @ get.normalized.value		i p-stats get.normalized.value		-		0 <		IF			i curr-dist @ at: []			1+  i to: p-dist-adjusted 		ELSE			i curr-dist @ at: []			1 - i to: p-dist-adjusted		THEN 	LOOP;\ locate the index from the current distribution function: PICK.INDEX ( -- index )				1000 choose			find.array.value	\	dup .;: PICK.PITCH  { t-index -- pitch }	t-index\	update.adjusted.array    lowest_pitch +\	dup .;	\ compute where you are in piece: PICK.DURATION ( -- duration)	\ first half of piece, durations increase	curr-time @ piece_length 2/ <	IF		number_durations curr-time @ 		piece_length 2/ */ ( 0-7 in piece_length/2 )		2 + ( 2 - 9 ) 1		wchoose	ELSE	\ second half, decrease		number_durations		number_durations 		curr-time @ piece_length 1+ 2/ /mod drop		piece_length 2/ */ ( 0-7 )		- 		1+		1 wchoose	THEN	dup .;\ composer alert, note is out of range: CHECK.NOTE.RANGE { note -- , error message }	note highest_pitch >	note lowest_pitch <	or	IF		." note out of range !!! cr "	THEN;: PICK.NOTE { t-index | t-pitch t-duration -- note duration }	t-index pick.pitch -> t-pitch	pick.duration -> t-duration	t-index t-duration update.stats	t-pitch t-duration	\ this just prints an error if its out of range for some reason	t-pitch check.note.range;v: prev-section v: curr-section: SWITCH.DISTRIBUTIONS? {  | section-length -- }	\ determine how long a section is, there are two of them	piece_length #_sections /	-> section-length	curr-time @ section-length /	curr-section !	\ don't update if we're in the final section	curr-section @ #_sections 1- > not	\ update if section has changed only		curr-section @ prev-section @ = not	and	IF		\ diagnostic printing		tab cr cr cr curr-section @ .			tab curr-time ? cr cr	\ now figure out what the source and target distributions are	\ store for next time		curr-section @ prev-section !		\ now change distributions		curr-section @ at: p-dist-array dup		curr-dist !		source-dist !		curr-section @ 1+ at: p-dist-array 		target-dist !			cr cr tab ." target is " target-dist @ name: []		cr tab ." source is " source-dist @ name: []		cr cr	THEN;: COMPUTE.SILENCE-PROB ( silence goes from max to zero )	max_silence_prob 	curr-time @ max_silence_prob piece_length */	-	silence-prob !;: IS.SILENCE? ( -- flag )	100 choose silence-prob @	<;: PICK.LOUDNESS	1000 choose	curr-time @ 1000 piece_length */	>	IF 		96	ELSE		64	THEN;	\ real probability equals prob-stat + prob (all normalized)\ if prob is bigger than stat, prob is increased\ if prob is smaller than stat, prob is decreased\ normalize current stats after every update	: MAKE.PIECE {  | t-duration t-pitch -- }	BEGIN		pick.index ( -- index )		pick.note ( -- pitch duration )		-> t-duration		-> t-pitch		t-duration 		is.silence? 		IF			0		ELSE			t-pitch 		THEN\ stuff the shape		pick.loudness		curr-time @		curr-section @		add: piece-shape\ update piece counters		1 curr-number-notes +!		t-duration curr-time +!		update.crossfade		update.crossfade.array\		19 at: p-dist-adjusted . 		switch.distributions?		compute.silence-prob		curr-time @ piece_length > 			?terminal or	UNTIL	0 calc.dim.stats: piece-shape	0 get.dim.sum: piece-shape	4 / 120 /mod	cr cr 	 . ." minutes " . ." seconds " cr;	