\ ek choosing parameters fileanew task-ek_choose\ whether or not to choose a new value for a parameter depends on two things:\ whether the player is on, and whether optimize-choose? is on\ Optimize-choose? on says: "only change if the player is on"\ this is meant to speed up the choosing for the new iteration if it bogs down...\ the default is off...\ it uses the following truth table:\ player-on    opt-choose    choose? (result)\ yes          yes           yes\ yes          no            yes\ no           yes           no\ no           no            yes: EK-CHOOSE.ON	choose-on? @ IF		#_ek_channels 0 DO			100 choose			i player-densities ed.at: ek-player-data			<			IF				1 i players-on? ed.to: ek-player-data				true i put.value: cg-players-on			ELSE				0 i players-on? ed.to: ek-player-data				false i put.value: cg-players-on			THEN		LOOP	THEN;: EK-CHOOSE.PRESET { | t-preset -- }	choose-presets? @ 	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				preset-limit @ choose				-> t-preset				t-preset i player-presets ed.to: ek-player-data				t-preset i put.value: cg-presets				t-preset i at: ek-instruments put.preset: []			THEN		LOOP	THEN		;: EK-CHOOSE.JITTER	choose-jitters? @ 	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				max-jitter @ choose choose dup				i player-jitters ed.to: ek-player-data				i put.value: cg-jitters			THEN		LOOP	THEN;: EK-CHOOSE.STACC { | t-stacc -- }	choose-staccs? @ 	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				100  choose -> t-stacc				t-stacc i player-staccs ed.to: ek-player-data				t-stacc i put.value: cg-staccs				t-stacc 100 i at: ek-player-list put.duty.cycle: []			THEN		LOOP	THEN;: SKIP.FROM.STEP ( step -- skip )			dup  2* over 4 * swap wchoose			2 max 			swap 			drop;: EK-CHOOSE.STEP { | t-step t-skip -- }	choose-steps? @ 	IF		#_ek_channels 0 		DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				12 choose choose 1 max 					-> t-step	\ player step value				t-step skip.from.step 				-> t-skip				t-step i player-steps ed.to: ek-player-data				t-step i put.value: cg-steps				t-skip i player-skips ed.to: ek-player-data\				t-skip i put.value: cg-skips			THEN		LOOP	THEN; \ 50 percent chance of chooseing skip-step, or step-skip: SKIP.OR.STEP.SHAPE?	100 choose skip/step-prob @	>		IF mel-shape 		ELSE mel.skip-shape		THEN;: EK-CHOOSE.SHAPE	#_ek_channels 0 	DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not		IF			i player-behaviors ed.at: ek-player-data			CASE				mel 		of	SKIP.OR.STEP.SHAPE?  0 i  at: ek-player-list put: [] endof				sustain		of	sus-shape 			 0 i at: ek-player-list put: [] endof				invert 		of	SKIP.OR.STEP.SHAPE?  0 i  at: ek-player-list put: [] endof				rhythm 		of	rhy-shape  			 0 i at: ek-player-list put: [] endof				highnote 	of	SKIP.OR.STEP.SHAPE?  0 i  at: ek-player-list put: [] endof				lownote 	of	SKIP.OR.STEP.SHAPE?  0 i at: ek-player-list put: [] endof				lowhigh 	of	SKIP.OR.STEP.SHAPE?  0 i at: ek-player-list put: [] endof				accenthigh 	of	SKIP.OR.STEP.SHAPE?  0 i at: ek-player-list put: [] endof				accentlow 	of	SKIP.OR.STEP.SHAPE?  0 i at: ek-player-list put: [] endof						accentlowhigh of SKIP.OR.STEP.SHAPE? 0 i at: ek-player-list put: [] endof				." illegal behavior for shape " dup .			ENDCASE		THEN	LOOP;\ bend: EK-CHOOSE.BEND { | t-bend hi-bend lo-bend -- }	choose-bends? @ 	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				100 choose 100 choose + 100 choose  + 3 /				dup				i player-bends ed.to: ek-player-data				i put.value: cg-bends				i player-bends ed.at: ek-player-data				-> t-bend				$ 4000 t-bend / t-bend * -> hi-bend				$ 4000 t-bend / t-bend 1- * -> lo-bend				hi-bend lo-bend wchoose i player-fund-bends ed.to: ek-player-data				hi-bend lo-bend wchoose i player-skip-bends ed.to: ek-player-data				hi-bend lo-bend wchoose i player-step-bends ed.to: ek-player-data				THEN			LOOP	THEN;\ loudness: EK-CHOOSE.LOUD	choose-loudnesses? @	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				20 choose 20 choose + 20 choose  + 3 /				dup				i player-loudnesses ed.to: ek-player-data				i put.value: cg-loudnesses			THEN		LOOP	THEN;: EK-CHOOSE.FUNDS { | t-fund -- }	choose-funds? @	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				i player-fundhis ed.at: ek-player-data				i player-fundlos ed.at: ek-player-data				wchoose				-> t-fund				t-fund i player-funds ed.to: ek-player-data				t-fund i put.value: cg-funds				t-fund i at: ek-instruments put.offset: []			THEN		LOOP	THEN;\ midi control value: EK-CHOOSE.CONTROLS	choose-controls? @	IF		#_ek_channels 0 DO		optimize-choose? @ true =		i players-on? ed.at: ek-player-data false =		and not			IF				127 choose 127 choose + 127 choose  + 3 /				dup				i player-controls ed.to: ek-player-data				i put.value: cg-controls			THEN		LOOP	THEN;\ behaviors: CG-BEHAVIORS-TEXT.FUNCTION { val  part --  }	1115 part 200 * 575 + scg.move 		val	CASE		0 of " mel " endof		1 of " inv " endof		2 of " sus " endof		3 of " rhy " endof		4 of " hi   " endof		5 of " lo   " endof		6 of " lh   " endof		7 of " >hi  " endof		8 of " >lo  " endof		9 of " >lh  " endof	ENDCASE	gr.text	;: (EK-CHOOSE.BEHAVIOR) { | curr-value behavior-ind -- behavior-ind }	0 -> behavior-ind	get.data: ek-behavior-histogram	choose -> curr-value 	many: ek-behavior-histogram 0 		DO			i 1 ed.at: ek-behavior-histogram 			curr-value 			>=			IF 				i 				LEAVE			THEN		LOOP;: EK-CHOOSE.BEHAVIOR { | behavior-ind -- }	choose-behaviors? @	IF		#_ek_channels 0 		DO			optimize-choose? @ true =			i players-on? ed.at: ek-player-data 			false =			and not			IF				(ek-choose.behavior)				-> behavior-ind				behavior-ind i player-behaviors ed.to: ek-player-data				behavior-ind i put.value: cg-behaviors				behavior-ind i cg-behaviors-text.function			THEN		LOOP	THEN;\ put the click player in, or leave the regular player in and\ everything else unchanged: EK-CHOOSE.MIDI-CLICK	midi-click-on? @	IF		ek-click-player 15 put: ek-collection		true 15 players-on? ed.to: ek-player-data \ turn the voice on\		true 15 put.value: cg-players-on \ turn the grid on		\ now force preset		midi-click-preset @ 15 player-presets ed.to: ek-player-data\		midi-click-preset @ 15 put.value: cg-presets		\ force note		midi-click-note @ 15 player-funds ed.to: ek-player-data\		midi-click-note @ 15 put.value: cg-funds	ELSE		15 at: ek-player-list		15 put: ek-collection	THEN;				