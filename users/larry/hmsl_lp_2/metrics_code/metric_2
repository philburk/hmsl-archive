\ Second of two files that defines the metric class\ definition for metric shapes\ This file begins with metrics, and includes printing. \ author: lp\ note: these methods are only valid, so far, for equal length metrics\ originally from 17 Simple Melodies ... , but revised, starting\ 1/18/89 Solo\ last change made 5/13/89, solo\ rev. 8/21/91: changed calc.linear-directions: to be the correct\ "orientation" (-1 means is less than..... )\ 2/10/92 added harmony.et metrics, investigated (a bit) OLM: and ULM:fvariable f-diff-countfvariable f-source-sumfvariable  f-target-sum	\ ============================================================\                        METRICS\ ============================================================:M ULAM: ( target-shape -- )	setup.target: self  \ store target shape address, same curr-dim	sync.target-index: self	curr-dim calc.dim.stats: self	curr-dim iv-target-shape calc.dim.stats: []	curr-dim get.dim.sum: self	many: self /	curr-dim iv-target-shape get.dim.sum: []	iv-target-shape many: [] /	- abs;m:M OLAM: ( target-shape -- value , metric-value scaled to length )    setup.target: self \ store target shape address, same curr-dim	sync.target-index: self	curr-dim calc.dim.stats: self	curr-dim iv-target-shape calc.dim.stats: []	0 \ seed sum    many: self   ( note that this will change will length generalizes )    0	DO      	i curr-dim ed.at: self		i curr-dim iv-target-shape ed.at: []         - abs		+    LOOP	 many: self /;m\ Ordered linear direction metric:m OLD: ( iv-target-shape -- , f-metric-value )			reset.metric: self		0.0 f-diff-count f!        min.length: self   ( note that this will change when length generalizes )		interval.start: self        		DO			i i iv-target-shape get.interval-index: [] 			iv-target-shape  direction.interval: []      		i i get.interval-index: self			direction.interval: self       		= not            IF 			\ if different, add weighted 1.0 into numerator				1.0 				i do.linear.weight.function: self				f* 				f-diff-count f@ f+ f-diff-count f!			ELSE				1.0 				i do.linear.weight.function: self				f*				fdrop	( just add into weight sum, don't increment numerator ) 			THEN      	LOOP        f-diff-count f@ 		linear get.metric.weight: self 		f/ ;m\ this works in current dimension:m CALC.LINEAR-DIRECTIONS: (  -- , put appropriate numbers in up, down, equal arrays )		reset.contour.vectors: self        many: self		interval.start: self		 DO			i get.interval-index: self ( -- j i )			i ( -- jth element )			direction.interval: self			dup 0= 			IF 				1+ curr-dim equal ed.to: lin-cont-vector				drop			ELSE -1 = 				IF  curr-dim up ed.at: lin-cont-vector 					1+ curr-dim up ed.to: lin-cont-vector               	ELSE curr-dim down ed.at: lin-cont-vector					1+ curr-dim down ed.to: lin-cont-vector               	THEN           	THEN        LOOP;m\ Unordered linear direction metric\ does not use weights!!!!!!!:m ULD: ( iv-target-shape -- metric )		reset.metric: self		iv-target-shape calc.linear-directions: []		calc.linear-directions: self 		curr-dim iv-target-shape get.linear.down-count: []  		curr-dim get.linear.down-count: self - abs 		curr-dim iv-target-shape get.linear.up-count: []  		curr-dim get.linear.up-count: self - abs 		curr-dim iv-target-shape get.linear.equal-count: []  		curr-dim get.linear.equal-count: self - abs ( -- down up equal )\ Note on the following calculation:\ The number of possible differences between the two sets of three\ counts is twice the number of possible intervals, since\ any interval that is different will "show up twice", once\ in, for example, the up column of the target, and the\ down of the source. So either the number of intervals (MANY)\ has to be multiplied by two, or the final result divided by two.\ I chose the former below for reasons of clarity, not speed or accuracy		+ + float		get.interval-length: self		2* float 		f/;m\ Ordered combinatorial direction metric:M OCD: ( iv-target-shape -- metric-value )	reset.metric: self	0.0 f-diff-count f!    ( outer loop --J--  goes from 1 to L-1)	min.length: self 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO				j i J + iv-target-shape  direction.interval: []				j i J +  direction.interval: self				= not				IF 					1.0					j 1+ do.row.weight.function: self					f* 					i do.column.weight.function: self					f*					f-diff-count f@ f+ f-diff-count f!					j 1+ i j + 					combinatorial.weight.running.sum: self				ELSE					j 1+ i j + 					combinatorial.weight.running.sum: self				THEN			LOOP	LOOP	f-diff-count f@	combinatorial get.metric.weight: self    f/ \ return metric;M:M CALC.COMBINATORIAL-DIRECTIONS: ( -- , place values in vector )	reset.contour.vectors: self	many: self 0 	DO	 ( inner loop: l )		 many: self I - 1 		 DO		 j j i + direction.interval: self		 dup 0= IF 				curr-dim equal ed.at: comb-cont-vector 				1+ curr-dim equal ed.to: comb-cont-vector 				drop			ELSE  			-1 = 				IF 					curr-dim up ed.at: comb-cont-vector 					1+ curr-dim up ed.to: comb-cont-vector				ELSE 					curr-dim down ed.at: comb-cont-vector 					1+ curr-dim down ed.to: comb-cont-vector				THEN			 THEN		 LOOP	LOOP ;M\ Unordered combinatorial direction metric\ doesn't use weights:M UCD: ( iv-target-shape --  )		reset.metric: self		calc.matrix-length: self		iv-target-shape calc.matrix-length: [] 		iv-target-shape calc.combinatorial-directions: []		calc.combinatorial-directions: self\ 		curr-dim iv-target-shape get.comb.down-count: []  float 		iv-target-shape get.matrix-length: [] float f/ 		curr-dim get.comb.down-count: self float 		matrix-length float f/ 		f- fabs \ 		curr-dim iv-target-shape get.comb.up-count: []  float 		iv-target-shape get.matrix-length: [] float f/ 		curr-dim get.comb.up-count: self float		matrix-length float f/		f- fabs \ 		curr-dim iv-target-shape get.comb.equal-count: [] float 		iv-target-shape get.matrix-length: [] float f/		curr-dim get.comb.equal-count: self float		matrix-length float f/		f- fabs			( -- down up equal )\		f+ f+ 2.0 f/;M\ *************************\ Unordered Magnitude Metrics\ *************************:M #.DIFF.LIN.SIGNED.MAG: ( iv-target-shape -- #-different )        reset.contour.vectors: self        setup.target: self \ store target shape address, same curr-dim		sync.target-index: self        many: self   ( note that this will change when length generalizes )		interval.start: self        		DO			i i iv-target-shape get.interval-index: [] 			iv-target-shape  signed.diff.interval: []      		i i get.interval-index: self			signed.diff.interval: self       		= not             IF 1 iv+> diff-count THEN      	LOOP        diff-count;M:M #.DIFF.LIN.ABS.MAG: ( iv-target-shape -- #-different )        reset.contour.vectors: self        setup.target: self \ store target shape address, same curr-dim		sync.target-index: self        many: self   ( note that this will change when length generalizes )		interval.start: self        		DO			i i iv-target-shape get.interval-index: [] 			iv-target-shape absolute.difference.interval: []      		i i get.interval-index: self			absolute.difference.interval: self       		= not             IF 1 iv+> diff-count THEN      	LOOP        diff-count;m\ ******************\ ULM\ ******************\ this can not be weighted!!!!!\ just because of the way it's coded...\ This can work for morphs of different lengths:M ULM.UNSCALED: ( target-shape -- , f-metric , unordered linear magnitude metric )	reset.metric: self	iv-target-shape fcalc.abs.dim-diff-mean: [] 	fcalc.abs.dim-diff-mean: self 	f- fabs ;m\ Absolute scaled ULM\ this cannot be weighted... just the way it's coded!!!\ This can work for morphs of different lengths:m ULM: ( target-shape -- , f-metric , unordered linear magnitude metric )	reset.metric: self	iv-target-shape fcalc.abs.dim-diff-mean: [] 	fcalc.abs.dim-diff-mean: self 	f- fabs 	curr-dim max.linear.int: self 	curr-dim iv-target-shape max.linear.int: [] 	max float	f/;m:M ULM.ABSOLUTE.SCALED: 	ulm: self;m\ Absolute scaled ULM\ this cannot be weighted... just the way it's coded!!\ This can work for morphs of different lengths:m ULM.RELATIVE.SCALED: ( target-shape -- value , unordered linear magnitude metric )	reset.metric: self	iv-target-shape fcalc.abs.dim-diff-mean: [] 	curr-dim iv-target-shape max.linear.int: [] float 	f/	fcalc.abs.dim-diff-mean: self 	curr-dim max.linear.int: self float 	f/	f- fabs ;m\ ******************\ UCM\ ******************\ checked\ Unordered combinatorial direction metric\ absolute scaled\ It would be nice to revise this so that it could be for morphs of different lengths!\ Need separate inner loops, separate matrix lengths...:M UCM: ( iv-target-shape -- metric-value )	reset.metric: self	0.0 f-target-sum f!	0.0 f-source-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO				j i J + iv-target-shape abs.diff.interval: []				float				j 1+ iv-target-shape do.row.weight.function: []				f* 				i iv-target-shape do.column.weight.function: []				f*					f-target-sum f@ f+ f-target-sum f!\				j 1+ i j + iv-target-shape combinatorial.weight.running.sum: []\				j i J +  abs.diff.interval: self				float				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*								       			f-source-sum f@ f+ f-source-sum f!\				j 1+ i j + combinatorial.weight.running.sum: self			LOOP	LOOP	f-target-sum f@ ( -- sum )	combinatorial iv-target-shape get.metric.weight: []		f/\	f-source-sum f@ 	combinatorial get.metric.weight: self	f/	( -- mean1 mean2 )\	f-	fabs\	curr-dim max.combinatorial.int: self	curr-dim iv-target-shape max.combinatorial.int: [] 	max float	f/;M:M UCM.ABSOLUTE.SCALED: 	Ucm: self;M\ Unordered combinatorial direction metric\ relative scaled:M UCM.RELATIVE.SCALED: ( iv-target-shape -- metric-value )	reset.metric: self	0.0 f-target-sum f!	0.0 f-source-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )	min.length: self I - 1 			DO				j i J + iv-target-shape  abs.diff.interval: []				float				j 1+ iv-target-shape do.row.weight.function: []				f* 				i iv-target-shape do.column.weight.function: []				f*					f-target-sum f@ f+ f-target-sum f!				j 1+ i j + iv-target-shape combinatorial.weight.running.sum: []				\				j i J +  abs.diff.interval: self  				float				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*					f-source-sum f@ f+ f-source-sum f!				j 1+ i j + 				combinatorial.weight.running.sum: self			LOOP	LOOP	f-target-sum f@ ( -- sum )	combinatorial iv-target-shape get.metric.weight: []		f/	curr-dim iv-target-shape max.combinatorial.int: [] float 	f/\	f-source-sum f@ 	combinatorial get.metric.weight: self	f/	curr-dim max.combinatorial.int: self float 	f/\	f-   fabs ;M:M UCM.UNSCALED: ( iv-target-shape -- metric-value )	reset.metric: self	0.0 f-target-sum f!	0.0 f-source-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )	min.length: self I - 1 			DO				j i J + iv-target-shape  abs.diff.interval: []				float				j 1+ iv-target-shape do.row.weight.function: []				f* 				i iv-target-shape do.column.weight.function: []				f*					f-target-sum f@ f+ f-target-sum f!				j 1+ i j + iv-target-shape combinatorial.weight.running.sum: []\				j i J +  abs.diff.interval: self  				float				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*					f-source-sum f@ f+ f-source-sum f!				j 1+ i j + combinatorial.weight.running.sum: self			LOOP	LOOP	f-target-sum f@ ( -- sum )	combinatorial iv-target-shape get.metric.weight: []		f/\	f-source-sum f@ 	combinatorial get.metric.weight: self	f/\	f-  fabs ;M\ *************************\ Ordered Magnitude Metrics\ *************************\ ************\ OLM \ ************\ Unscaled... just the sum divided by the length*weights:M OLM.UNSCALED: ( target-shape -- value, ordered linear magnitude metric )	reset.metric: self	use.abs.diff.interval: self	iv-target-shape use.abs.diff.interval: []	0.0 frunning-sum f! \ seed sum    min.length: self   ( note that this will change will length generalizes )    interval.start: self	DO        i i iv-target-shape get.interval-index: []		interval-target: self         i i get.interval-index: self		interval: self         - abs float 		i do.linear.weight.function: self		f* 		frunning-sum f@ f+ frunning-sum f!    LOOP	frunning-sum f@ \ -- sum of differences 	linear get.metric.weight: self 	f/;m\ Unscaled... just the sum divided by the length*weights\ inner interval is the sqaure root of the difference of the squares:M OLM.UNSCALED.SQUARED: ( target-shape -- value, ordered linear magnitude metric )	reset.metric: self	use.abs.diff.interval: self	iv-target-shape use.abs.diff.interval: []	0.0 frunning-sum f! \ seed sum    min.length: self   ( note that this will change will length generalizes )    interval.start: self	DO        i i iv-target-shape get.interval-index: []		interval-target: self 		dup *        i i get.interval-index: self		interval: self 		dup *        - float 		fabs fsqrt		i do.linear.weight.function: self		f* 		frunning-sum f@ f+ frunning-sum f!    LOOP	frunning-sum f@ \ -- sum of differences 	linear get.metric.weight: self 	f/;m\ checked\ scaled version of the unscaled olm,\ by the  maximium interval of two shapes\ this is the absolute scaled OLM:M OLM: ( target-shape -- , f-metric-value scaled to length )		olm.unscaled: self	( -- funscaled ) 		curr-dim iv-target-shape max.linear.int: []		curr-dim max.linear.int: self		max 	    float		f/ \ return metric	;m:M OLM.SQUARED: ( target-shape -- , f-metric-value scaled to length )		olm.unscaled.squared: self	( -- funscaled ) 		curr-dim iv-target-shape max.linear.int: []		curr-dim max.linear.int: self		max 	    float		f/ \ return metric	;m\ checked:M OLM.ABSOLUTE.SCALED:	OLM: self;m:M OLM.RELATIVE.SCALED: ( iv-target-shape -- , f-metric-value )	reset.metric: self	use.abs.diff.interval: self	iv-target-shape use.abs.diff.interval: []	0.0 frunning-sum f! \ seed sum    min.length: self   ( note that this will change will length generalizes )    interval.start: self	 DO        i i iv-target-shape get.interval-index: []		interval-target: self 		float		curr-dim iv-target-shape max.linear.int: []		float f/         i i get.interval-index: self		interval: self 		float		curr-dim  max.linear.int: self		float f/          f- fabs 		i do.linear.weight.function: self		f* 		frunning-sum f@ f+ frunning-sum f!    LOOP	frunning-sum f@ \ -- sum of differences 	linear get.metric.weight: self	f/;m	\ ************\ OCM \ ************\ checked\ Ordered combinatorial direction metric\ absolute scaled:M OCM: ( iv-target-shape -- , f-metric-value )	reset.metric: self	0.0  frunning-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO             	  j i J + iv-target-shape  abs.diff.interval: []              	 j i J +  abs.diff.interval: self        	  	 - abs float 				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*			   frunning-sum f@ f+ frunning-sum f!				j 1+ i j + 				combinatorial.weight.running.sum: self			LOOP	LOOP	frunning-sum f@ \ running sum/weightsum*maxint	curr-dim iv-target-shape max.combinatorial.int: [] 	curr-dim max.combinatorial.int: self	max  float 	combinatorial get.metric.weight: self	f* 	f/ \ return metric;M:M OCM.ABSOLUTE.SCALED: 	ocm: self;M:M OCM.SQUARED: ( iv-target-shape -- , f-metric-value )	reset.metric: self	0.0  frunning-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO				j i J + iv-target-shape  abs.diff.interval: []				dup *				j i J +  abs.diff.interval: self				dup *				-  float 				fabs fsqrt				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*				frunning-sum f@ f+ frunning-sum f!				j 1+ i j + 				combinatorial.weight.running.sum: self			LOOP	LOOP	frunning-sum f@ \ running sum/weightsum*maxint	curr-dim iv-target-shape max.combinatorial.int: [] 	curr-dim max.combinatorial.int: self	max  float 	combinatorial get.metric.weight: self	f* 	f/ \ return metric;M\ Ordered combinatorial direction metric\ relative scaled, scaled by max of each morph inside loop:M OCM.RELATIVE.SCALED: ( iv-target-shape -- , f-metric-value )	reset.metric: self	0.0 frunning-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO               	j i J + iv-target-shape  abs.diff.interval: []			 	float				curr-dim iv-target-shape max.combinatorial.int: []				float 				f/ 				j i J +  abs.diff.interval: self				float				curr-dim max.combinatorial.int: self				float 				f/ 				f- fabs  ( -- int )				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*				( -- fint*weights )				frunning-sum f@ f+ frunning-sum f!				j 1+ i j + combinatorial.weight.running.sum: self		LOOP	LOOP	frunning-sum f@ 	combinatorial get.metric.weight: self    f/ \ return metric;M\ checked:M OCM.UNSCALED: ( iv-target-shape -- , f-metric-value )	reset.metric: self	0.0 frunning-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO				j i J + iv-target-shape  abs.diff.interval: []				j i J +  abs.diff.interval: self				- abs float				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*			   frunning-sum f@ f+ frunning-sum f!				j 1+ i j + combinatorial.weight.running.sum: self			LOOP	LOOP	frunning-sum f@ 	combinatorial get.metric.weight: self    f/ \ return metric;M\ checked:M OCM.UNSCALED.SQUARED: ( iv-target-shape -- , f-metric-value )	reset.metric: self	0.0 frunning-sum f!    calc.matrix-length: self	( outer loop --J--  goes from 1 to L-1)	min.length: self 1- 0	DO	( inner loop --I-- goes from L-J )		min.length: self I - 1 			DO				j i J + iv-target-shape  abs.diff.interval: []				dup *				j i J +  abs.diff.interval: self				dup *				-   float 				fabs fsqrt				j 1+ do.row.weight.function: self				f* 				i do.column.weight.function: self				f*			   frunning-sum f@ f+ frunning-sum f!				j 1+ i j + combinatorial.weight.running.sum: self			LOOP	LOOP	frunning-sum f@ 	combinatorial get.metric.weight: self    f/ \ return metric;M\ *************************\ Harmony Metrics\ *************************\ Harmony ET versions of the above....\ This metric uses the mean of absolute values of harmonic intervals, and returns the difference \ between the average harmonic intervals of the two morphs.:m ULH.ET: ( target-shape -- value , unordered linear magnitude metric )	reset.metric: self	calc.harmony.et.dim-diff-mean: [] cr ." Source mean " dup . 	calc.harmony.et.dim-diff-mean: self ." Target mean " dup .	- abs ( these are already scaled. in the mean calculation to 0-1000... );m\ Completely unscaled ! Just a straight summation.:M OLH.ET: ( target-shape -- value, ordered linear magnitude metric )	reset.metric: self		iv-target-shape use.harmony.interval.et: []		use.harmony.interval.et: self		0 \ seed sum        min.length: self   ( note that this will change will length generalizes )        interval.start: self	 DO        i i iv-target-shape get.interval-index: [] 		interval-target: self         i i get.interval-index: self		interval: self         - abs  		+ ( -- sum ) 	LOOP	( -- sum ) \ now divide that sum by the number of intervals, and scale that to 0-1000	get.interval-length: self ( -- sum #-intervals ) 	/ ( -- average interval ) 	1000 11 */ ( see above... ) ;M\ =======================================================\ 		         PRINTING		\ =======================================================:M PRINT.CONTOUR.VECTORS:	cr cr  ." Linear" tab tab ." Combinatorial" cr 	." [goesdown|equal|up] " cr	dimension: self 0 	DO		i put.curr-dim: self		calc.linear-directions: self		." ["  down curr-dim ed.at: lin-cont-vector  .		equal curr-dim ed.at: lin-cont-vector  . up curr-dim ed.at: lin-cont-vector  . ." ]" tab		calc.combinatorial-directions: self		." ["  curr-dim down ed.at: comb-cont-vector  .		 curr-dim equal ed.at: comb-cont-vector  . curr-dim up ed.at: comb-cont-vector  . ." ]" tab	LOOP	cr;M	\ New and rather over-robust print: .:M PRINT:    print: super	cr tab ." Hit any key for more statistics ... " cr	tab tab ." (Q or esc to quit) " cr	key dup 27 = swap 113 = or not 	IF        	calc.matrix-length: self        	." Matrix length= " matrix-length .        	cr ." Current dimension= " curr-dim .			cr cr ." Dim# " tab tab			dimension: self 0 	DO				i . tab	LOOP	cr		cr ." ====================================== " cr\ save curr-dim		curr-dim		 ." |Diff. mns.| "  tab		dimension: self 0		DO 					i put.curr-dim: self			calc.abs.dim-diff-mean: self . tab 		LOOP		cr ." +- Diff. mns. "  tab		dimension: self 0		DO 			i put.curr-dim: self			calc.signed.dim-diff-mean: self . tab 				LOOP				cr ." Dim. Weights "  tab		dimension: self 0		DO i at: dim-weights . tab LOOP		cr ." |Diff. min.| "  tab		dimension: self 0		DO 			i put.curr-dim: self			calc.abs.diff.min: self . tab 				LOOP						cr ." |Diff. max.| "  tab		dimension: self 0		DO 			i put.curr-dim: self			calc.abs.diff.max: self . tab 				LOOP		cr\ restore curr-dim		put.curr-dim: self cr		." Weighting Functions " cr		tab ." Linear weighting function= " iv-linear.weight.function cfa. cr		tab ." Row weighting function= " iv-row.weight.function cfa. cr		tab ." Column weighting function= " iv-column.weight.function cfa. cr		print.interval.type: self cr cr		iv-fund-index   ." Src. mut. fund-index. = "  . cr				iv-adjacent? 		IF			." Adjaceny intervals, offset = "			iv-adjacency-offset . cr		ELSE				iv-fundamental?			IF				." External fund. intervals " cr			ELSE			." Fundamental index intervals " cr			THEN		THEN		iv-target-synched? 		IF			." Target shape index synched " cr		THEN		cr ." Harmony interval table (12-ET): " cr		." Harmonic Value " tab tab ." Interval (in #-half-steps)" cr		12 0 DO 				i . tab tab tab i at: harmony-et-table . cr		LOOP	THEN;m	 ;class	ob.m.shape m-shape-1ob.m.shape m-shape-2: TEST.M-SHAPES	6 3 new: m-shape-1	6 3 new: m-shape-2	6 0 DO			30 15 wchoose ( duration )			i 3 * 30 +  ( pitch )			96 64 wchoose ( volume )			add: m-shape-1 			45 25 wchoose ( duration )			100 i 2 * 30 +  - ( pitch )			68 64 wchoose ( volume )			add: m-shape-2	LOOP;