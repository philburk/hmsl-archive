\ Polansky extended shape class \ Contains various new utilities for developing metric and mutator classes\ Begun: 1/18/89, Solo\ Last changes, 5/13/89\ last changes 5/18/90 removed:\ 5/26/90 in transfer to mac removed a lot of little used stuff for\ ease of transfer....\ 7/4/90 added lo, hi and band pass filters to mac version only\ REV: 8/15/91, started to bring up to date to current ideas\ changing all iv-longs to iv-shorts\ Rev: 8/20 added put and get fundamental, clone:\ removed shape+:, shape-:, shape*:, etc.\ added: mean->fundamental:\ 8/24 added iv-source-shape\ 9/1 added index< and index> to aid orchestrating mutations\ 9/4/ added many=: and same: to compare two dimensions of shapes...\ 9/22 added abbreviated method put.sourceanew task-new_shape\ print dimension, but horizontally method print.horizontal:method print.vertical:method ph:method pv:\  arithmetic comparisons for two shapes.method dim>:method dim<:method dim=: method many>: method many<: method many=:method same:\ method for filtering shapesmethod lo-pass:method hi-pass:method band-pass:method band-reject:method deglitch:method index>:method index<:method compand:method mean->fundamental:method search.and.match:method get.target-shape:method put.target-shape:method get.source-shape:method put.source-shape:method min.length:\ shortened names ...method get.target:method put.target:method get.source:method put.source:\ these are all the same!!!!!\ that is, just a bunch of aliasesmethod put.fundamental:method get.fundamental:method put.fund:method get.fund:method put.fund-value:method get.fund-value:method calc.non-zero.dim.stats: method n.remove:method rel.shape->FINALE:\ more statistics\ fill arrays of absolute value differencesmethod dim.fmean:method fill.linear.abs-diffs: method fill.comb.abs-diffs: method get.linear.abs-diffs: method get.comb.abs-diffs: \ calculate max and meansmethod calc.max.linear.int: method calc.max.comb.int:method calc.min.linear.int: method calc.min.comb.int:method calc.mean.linear.int:method calc.mean.comb.int:method calc.matrix-length:method get.matrix-length:method get.max.linear.int:method get.max.comb.int:method get.min.linear.int:method get.min.comb.int:method get.mean.comb.int:method get.mean.linear.int:method calc.extended.stats: \ use these to combine calc and fetch in one wordmethod max.combinatorial.int: method min.combinatorial.int:method max.linear.int: method min.linear.int: method max.linear.interval: ( just an alias )method mean.combinatorial.int: method mean.comb.int: method mean.linear.int:\ variance, sdmethod calc.dim.variance:method get.dim.variance:method calc.dim.sd:method get.dim.sd:\ some higher level interval statistics, based on those in new-shapemethod calc.dim.variance':method get.dim.variance':method calc.dim.sd':method get.dim.sd':\ combinatorial sdmethod calc.dim.comb-variance':method get.dim.comb-variance':method calc.dim.comb-sd':method get.dim.comb-sd':\ statistical comparisonsmethod covariance: method correlation:method covariance': method correlation':method combinatorial.covariance':method combinatorial.correlation':\ some variablesv: temp-dimv: temp-elementv: lower-bpv: higher-bp\ =============================================================\ CLASS DEFINITION AND UTILITIES\ =============================================================:CLASS OB.NEW-SHAPE  <super ob.shape	iv.long iv-target-shape	iv.long iv-source-shape	ob.array fundamentals	ob.array indx-array	ob.array max-linear-ints	ob.array max-comb-ints	ob.array min-linear-ints	ob.array min-comb-ints	ob.array mean-linear-ints	ob.array mean-comb-ints	ob.array variances	ob.array standard-deviations	ob.array comb-variances'	ob.array comb-standard-deviations'	ob.array variances'	ob.array standard-deviations'	ob.shape linear.abs-diffs	ob.shape comb.abs-diffs	iv.long matrix-length \ number of redundant cells in matrix                        \ New version of NEW: sets length of array for "fundamentals":\ external values that can be used for each dimension, by \ things like metrics.:m INIT:	init: super	0 iv=> iv-source-shape	0 iv=> iv-target-shape;m:m NEW: { el dim -- }	el dim new: super	el 1 - dim new: linear.abs-diffs	el el * el - 2/ dim new: comb.abs-diffs	dimension: self new: fundamentals 	dimension: self new: max-linear-ints	dimension: self new: min-linear-ints	dimension: self new: mean-linear-ints		dimension: self new: max-comb-ints	dimension: self new: min-comb-ints	dimension: self new: mean-comb-ints	dimension: self new: variances	dimension: self new: standard-deviations	dimension: self new: variances'	dimension: self new: standard-deviations'	dimension: self new: comb-variances'	dimension: self new: comb-standard-deviations';m:M FREE:	free: fundamentals	free: linear.abs-diffs	free: comb.abs-diffs	free: indx-array	free: max-linear-ints	free: min-linear-ints	free: max-comb-ints	free: min-comb-ints	free: mean-linear-ints	free: mean-comb-ints	free: variances	free: standard-deviations	free: variances'	free: standard-deviations'	free: comb-variances'	free: comb-standard-deviations';m\ simple utility for searching for the next occurrence of a given value\ leaves a -1 if no match is found...\ example: 3 5 search.and.match: foo, starts at value 3 in dimension 5...:M SEARCH.AND.MATCH: { t-ind t-dim | t-val -- new-index }	t-ind t-dim ed.at: self -> t-val	-1	many: self t-ind 1+ DO		i t-dim ed.at: self		t-val = 		IF 			drop i LEAVE 		THEN	LOOP;m			\ ********************************\ SOURCE AND TARGET SHAPE STUFF\ ********************************:M PUT.TARGET-SHAPE: ( shape -- )	iv=> iv-target-shape;m:M GET.TARGET-SHAPE: ( -- shape )	iv-target-shape;m:M PUT.SOURCE-SHAPE: ( shape -- )	iv=> iv-source-shape;m:M GET.SOURCE-SHAPE: ( -- shape )	iv-source-shape;m\ just some shortened names for easier typing:M PUT.TARGET: ( shape -- ) put.target-shape: self ;m:M GET.TARGET: ( -- shape ) get.target-shape: self ;m:M PUT.SOURCE: ( shape -- )	put.source-shape: self ;m:M GET.SOURCE: ( -- shape )	get.source-shape: self ;m	\ basic technigue for metrics on different length morphs\ truncates metric to the shorter morph...:M MIN.LENGTH: 	iv-target-shape 0= not	IF		iv-target-shape many: []		many: self		min	ELSE		0	THEN;m\ ***********************\ UPDATED ED.AT and ED.TO\ ***********************\ New versions of ED.AT: and ED.TO: which have a place for\ a fundamental at the -1 element index. These are a bit dangerous,\ because now, there can be no -1 checking in these words....:m ED.AT: ( el dim -- value )	swap dup ( -- dim el el )		-1 = IF			drop at: fundamentals		ELSE			swap ed.at: super		THEN ;m:m ED.TO: ( n el dim -- )	swap dup	-1 = 	IF		drop to: fundamentals	ELSE		swap ed.to: super	THEN ;m\ ******************\ FUNDAMENTALS\ ******************:M PUT.FUNDAMENTAL: ( fund dim -- )	-1 swap ed.to: self;m:M GET.FUNDAMENTAL: ( dim -- fund )	 -1 swap ed.at: self;m\ alternate names:m PUT.FUND: 	put.fundamental: self;m:M PUT.FUND-VALUE: 	put.fundamental: self;m:m GET.FUND: 	get.fundamental: self;m:M GET.FUND-VALUE: 	get.fundamental: self;m\ a dimension of -1 specifies do it to all dimensions...:M MEAN->FUNDAMENTAL: { dim -- , sets fundamental to mean of that dimension }	dim -1 = 	IF		dimension: self 0		DO			i calc.dim.stats: self			i get.dim.mean: self			i put.fundamental: self		LOOP	ELSE		dim calc.dim.stats: self		dim get.dim.mean: self		dim put.fundamental: self	THEN;M\ ****************************************\ COMBINATORIAL and INTERVAL CALCULATIONS\ ****************************************fvariable f-meanfvariable f-sum\ this is just a version of the dimension mean, but floating point, with more\ accuracy:M DIM.FMEAN: { dim -- , fmean }	0.0 f-sum f!	dim calc.dim.stats: self	dim get.dim.sum: self	float	many: self	float f/;m	\ Calculates the binomial coefficient, or the number\ of values in the "half-matrix minus the diagonal"\ for a given shape. this is the famous number\ "(n-squared - n) divided by 2":M CALC.MATRIX-LENGTH: ( -- , sets instance variable )        many: self\ following calculation is borrowed from Phil Burk, same as NUM.INTERVALS		dup dup * swap - 2/        iv=> matrix-length;m:M GET.MATRIX-LENGTH: ( -- lm )	matrix-length;m\ fill arrays with combinatorial and linear absolute differences:M FILL.LINEAR.ABS-DIFFS: { dim -- }	many: self 1- set.many: linear.abs-diffs	many: self 1	DO		i dim ed.at: self		i 1 - dim ed.at: self		- abs 		i 1- dim ed.to: linear.abs-diffs	LOOP;M:M FILL.COMB.ABS-DIFFS: { dim -- }	calc.matrix-length: self 	matrix-length	set.many: comb.abs-diffs	many: self 1- 0	DO	( inner loop --I-- goes from L-J )		many: self I - 1 			DO				j dim ed.at: self				i J + dim ed.at: self         	   	- abs           	LOOP	LOOP	\ just leave em all on the stack!!!!	many: comb.abs-diffs  0	DO		many: comb.abs-diffs i -  		1- 		dim ed.to: comb.abs-diffs	LOOP;M:M GET.LINEAR.ABS-DIFFS: { el dim -- }	el many: linear.abs-diffs 1- >	IF		." Element # too large in linear difference array " cr		abort	ELSE		el dim ed.at: linear.abs-diffs	THEN;M:M GET.COMB.ABS-DIFFS: { el dim -- }	calc.matrix-length: self	el matrix-length >	IF		." Element # too large in  combinatorial difference array " cr		abort	ELSE	el dim ed.at: comb.abs-diffs	THEN;m\ some statistics for scaling shapes\ calculates absolute magnitude maximum linear interval for a given dimensions:m CALC.MAX.LINEAR.INT: { dim | curr-max -- }	dim fill.linear.abs-diffs: self	0 -> curr-max	many: linear.abs-diffs   0 	DO		i dim ed.at: linear.abs-diffs		dup		curr-max >		IF			-> curr-max		ELSE			drop		THEN		curr-max  dim to: max-linear-ints	LOOP;m:m CALC.MIN.LINEAR.INT: { dim | curr-min -- }	dim fill.linear.abs-diffs: self	1000000 -> curr-min	many: linear.abs-diffs 0 	DO		i dim ed.at: linear.abs-diffs		dup		curr-min <		IF			-> curr-min		ELSE			drop		THEN		curr-min  dim to: min-linear-ints	LOOP;m\ means... there's a version of this in metric as well, but this is\ in the standard 100000. * fixed point format... used by SD' and Variance':m CALC.MEAN.LINEAR.INT: { dim | curr-mean -- }	dim fill.linear.abs-diffs: self	0 -> curr-mean	many: linear.abs-diffs 0	DO		i dim ed.at: linear.abs-diffs		curr-mean + -> curr-mean	LOOP	curr-mean float many: linear.abs-diffs float f/	100000. f* f>i 	dim to: mean-linear-ints;m\ calculates absolute magnitude maximum comb. interval for a given dimensions:m CALC.MAX.COMB.INT: { dim | curr-max -- }	dim fill.comb.abs-diffs: self	0 -> curr-max	many: comb.abs-diffs 0	DO			i dim ed.at: comb.abs-diffs			dup			curr-max >                IF				-> curr-max			ELSE				drop			THEN	LOOP	curr-max dim to: max-comb-ints;m\ calculates absolute magnitude minimum comb. interval for a given dimensions:m CALC.MIN.COMB.INT: { dim | curr-min -- }	dim fill.comb.abs-diffs: self	1000000  -> curr-min	many: comb.abs-diffs 0	DO			i dim ed.at: comb.abs-diffs			dup			curr-min <                IF				-> curr-min			ELSE				drop			THEN	LOOP	curr-min dim to: min-comb-ints;m\ calculates absolute magnitude mean comb. interval for a given dimensions:m CALC.MEAN.COMB.INT: { dim | curr-mean -- }	dim fill.comb.abs-diffs: self	0 -> curr-mean	many: comb.abs-diffs 0	DO		i dim ed.at: comb.abs-diffs		curr-mean + -> curr-mean	LOOP	curr-mean float 	many: comb.abs-diffs	float f/	100000. f* f>i	dim to: mean-comb-ints;m:M GET.MAX.LINEAR.INT: ( dim -- n )	at: max-linear-ints;m:M GET.MIN.LINEAR.INT: ( dim -- n )	at: min-linear-ints;m:M GET.MEAN.LINEAR.INT: ( dim -- , f-mean)	at: mean-linear-ints	float 100000. f/;m:M GET.MAX.COMB.INT: ( dim -- n )	at: max-comb-ints;m:M GET.MIN.COMB.INT: ( dim -- n )	at: min-comb-ints;m:M GET.MEAN.COMB.INT: ( dim -- , f-mean)	at: mean-comb-ints	float 100000. f/;m\ calculates and fetches in one shot:M MAX.COMBINATORIAL.INT: { dim -- n }	dim calc.max.comb.int: self	dim get.max.comb.int: self;m:M MAX.LINEAR.INT: { dim -- n }	dim calc.max.linear.int: self	dim get.max.linear.int: self;m:M MIN.COMBINATORIAL.INT: { dim -- n }	dim calc.min.comb.int: self	dim get.min.comb.int: self;m:M MIN.LINEAR.INT: { dim -- n }	dim calc.min.linear.int: self	dim get.min.linear.int: self;m:M MEAN.COMBINATORIAL.INT: { dim -- , f-mean }	dim calc.mean.comb.int: self	dim get.mean.comb.int: self;m:M MEAN.COMB.INT: { dim -- , f-mean }	dim mean.combinatorial.int: self;M:M MEAN.LINEAR.INT: { dim -- , f-mean }	dim calc.mean.linear.int: self	dim get.mean.linear.int: self;m:M CALC.EXTENDED.STATS: { dim --  }	dim fill.linear.abs-diffs: self	dim fill.comb.abs-diffs: self	dim calc.mean.linear.int: self	dim calc.mean.comb.int: self	dim calc.max.linear.int: self	dim calc.max.comb.int: self	dim calc.min.linear.int: self	dim calc.min.comb.int: self;M\ ******\ CLONE\ ******\ new clone:, also clones target shape and fundamental array...:m CLONE: { new-shape -- , copy contents to target }	new-shape clone: super	iv-target-shape new-shape put.target-shape: []	dimension: self 	0 DO			i get.fundamental: self			i new-shape put.fundamental: []	LOOP;m\ ===================== \      MORE UTILITIES \ =====================\ Simple, brainless activity for printing simply one short dimension \ would be nice to add some spiffier formatting, but \ this was mainly written to quickly look at some output in\ note files:m PRINT.HORIZONTAL:  { dim -- }	cr	many: self 0 DO			i dim  ed.at: self .			i 20 mod 19 = IF cr THEN		LOOP		;m\ shorter name for above:m PH: 	print.horizontal: self;m\ useful for columnar needs, like going to excel for a graph...:m PRINT.VERTICAL:  { dim -- }	cr	many: self 	0 DO		i dim  ed.at: self .		cr	LOOP;m\ shorter name for above:m PV: 	print.vertical: self;m\ ====================\ Logical Comparisons \ ====================\ The following methods are simple comparisons between a\ target shape and a source shape. The syntax is always \ the same: target-shape method: source-shape \ and a flag is left on the stack.:m DIM>: ( target-shape -- flag, true if source #dim. greater than target? )	dimension: []	dimension: self	< ;m:m DIM<: ( target-shape -- flag, true if source #dim. less than target? )	dimension: []	dimension: self	> ;m:m DIM=: ( target-shape -- flag, true if source #dim. equal to target? )	dimension: []	dimension: self	= ;m:m MANY>: ( target-shape -- flag, true if src. #elmts. grter. than target? )	many: []	many: self	> ;m:m MANY<: ( target-shape -- flag, true if src. #elmts. less than target? )	many: []	many: self	<;m	:m MANY=: ( target-shape -- flag, true if equal )	many: []	many: self	=;m\ True: all corresponding values in dim are equal in source and target\ False: not:M SAME: { dim target-shape | yes? -- flag }	0 -> yes?	target-shape many=: self	not	IF ." shapes are unequal length " cr	ELSE		many: self 0 		DO			i dim ed.at: self			i dim target-shape ed.at: []			= not			IF -1 -> yes? THEN		LOOP	yes? IF 			." Shapes NOT the same in dimension " dim . cr		ELSE			." Shapes ARE the same in dimension " dim . cr		THEN	THEN;m						: DIRECTION? ( m n -- 1|0|-1 m<n => -1, m>n => 1 )	 - ( m - n )	dup	0= not	IF dup abs / THEN ;: DIRECTION+-? ( m n -- 1|-1 , 1 if m > n,n=m or -1 if m<n )	direction?	dup 0= 	IF drop 1 THEN;\ *************************\ SHAPE FILTERING ROUTINES\ *************************\ some shape filters: they all remove the filtered values and shorten the shape\ filter usage: value(s) start end dimension -- \ removes values higher than the filter:m LO-PASS: { val start end dimension | indx -- }	start -> indx	end 1+ many: self min	start DO			indx dimension ed.at: self			val >				IF indx remove: self				ELSE indx 1+ -> indx				THEN			LOOP;m:m HI-PASS:  { val start end dimension | indx -- }	start -> indx	end 1+ many: self min	start DO			indx dimension ed.at: self			val <				IF indx remove: self				ELSE indx 1+ -> indx				THEN			LOOP;m\ removes any values that are outside the band, shortens shape:m BAND-PASS: { lo-value hi-value start end dimension | indx -- }	start -> indx	end 1+ many: self 	min	start DO			indx dimension ed.at: self 			lo-value hi-value within? 			NOT				IF indx remove: self				ELSE indx 1+ -> indx				THEN			LOOP;m\ removes any values that are inside the band, shortens shape:m BAND-REJECT: { lo-value hi-value start end dimension | indx -- }	start -> indx	end 1+ many: self min	start DO			indx dimension ed.at: self 			lo-value			hi-value within?				IF indx remove: self				ELSE indx 1+ -> indx				THEN			LOOP;m\ returns indices that are greater than index:M INDEX>: { val start end dimension   -- , leaves results in indx-array }	0 new: indx-array	end 1+ many: self min	start DO		i dimension ed.at: self 		val >			IF 				many: indx-array 				0= IF					1 new: indx-array				ELSE					1 extend: indx-array				THEN				i many: indx-array 1- to: indx-array			THEN		LOOP	many: indx-array ." There are " . ." indices too big " cr	print: indx-array;M\ same as above, but less than:M INDEX<: { val start end dimension   -- , leaves results in indx-array }	0 new: indx-array	end 1+ many: self min	start DO		i dimension ed.at: self 		val <		IF 			many: indx-array 			0= IF				1 new: indx-array			ELSE				1 extend: indx-array			THEN			i many: indx-array 1- to: indx-array		THEN	LOOP	many: indx-array ." There are " . ." indices too small " cr	print: indx-array;m\ removes value if too short.... that shortness set by value on stack:m DEGLITCH:  { val | indx ontime -- }\ Assume compressed\ Assume dim 0 = absolute time, dim 1 = pitch , dim 2 = vel , dim 3 = ontime	0 -> indx	many: self 0\ check to see if ontime < val	DO indx 3 ed.at: self dup -> ontime val <		IF  ( too small, must be a glitch )			( see if next note is immediately following )			( but first make sure there is a next note )			indx 1+ many: self <			IF	indx 0 ed.at: self ontime +				3 +  ( allow at most two ticks from glitch to note )				indx 1+ 0 ed.at: self >				IF ( this is a glitch at the beginning of the note  )					indx 0 ed.at: self					indx remove: self					indx 0 ed.to: self   ( use attack time from glitch )					indx 3 ed.at: self ontime +					indx 3 ed.to: self   ( sum ontimes )				ELSE indx remove: self  ( just an off glitch )				THEN			ELSE indx remove: self  ( just an off glitch )			THEN		ELSE indx 1+ -> indx		THEN	LOOP;m\ this compresses/expands a shape into the range min-value max-value:M COMPAND: { min-value max-value dim | d-max d-min multiplier -- }	max-value min-value <=	IF		." max value too small, set to min + 1 " cr		min-value 1 + -> max-value	THEN	dim calc.dim.stats: self	dim get.dim.max: self -> d-max	dim get.dim.min: self -> d-min\ in the pathological case, the shape only has one value...\ if the max is equal to the min, then you'll be scaling by zero, so scale by 1\ that means that a shape with all equal values will assume the input max value	d-max d-min -	0= 	IF			max-value d-max - 0 many: self 1- 0 transpose: self	ELSE\ first transpose the shape down to 0		d-min -1 * 0 many: self 1- dim transpose: self\ next scale the values in the shape		max-value min-value - ( -- new-range )		d-max d-min -         ( -- new-range old-range )		0 many: self 1- dim scale: self\ now  transpose them back up to the new min		min-value 		0 many: self 1- dim transpose: self	THEN;M\ this word calculates stats as usual, but doesn't allow minima or maxima of zero:M CALC.NON-ZERO.DIM.STATS:  { dim | smin smax ssum -- , calculate dimension stats }    ho_max_int -> smin  ( set up)    ho_min_int -> smax    0 -> ssum    many: self 0    DO  i dim ed.at: self   ( get value )		dup		0= not		IF        	dup smin min -> smin        	dup smax max -> smax        	ssum + -> ssum		ELSE			drop		THEN    LOOP    smin dim shape_min  put.dim.attr: self    smax dim shape_max  put.dim.attr: self    ssum dim shape_sum  put.dim.attr: self;M\ ******************************\ Some statistics: variance, sd\ ******************************\ Variance is computed as the sum of the squares of the differences\ between individual members and the mean, all divided by length of the morph \ or the number of intervals:M CALC.DIM.VARIANCE: { dim  -- }	0.0 f-mean f!	0.0 f-sum f!	dim dim.fmean: self	f-mean f!	many: self 0	DO		i dim ed.at: self		float		f-mean f@ f-		fdup f*		f-sum f@ f+ f-sum f!	LOOP	f-sum f@ many: self float f/	100000.0 f* f>i 	dim to: variances;M:M GET.DIM.VARIANCE: { dim --  , f-variance }	dim calc.dim.variance: self	dim at: variances	float 100000.0 f/;M\ Standard deviation is stored * 100000 in fixed point...:M CALC.DIM.SD: { dim -- }	dim calc.dim.variance: self	dim get.dim.variance: self fsqrt 	100000.0 f* f>i 	dim to: standard-deviations;M	\ divide is done here...:M GET.DIM.SD: { dim -- , fsd }	dim calc.dim.sd: self	dim at: standard-deviations	float 100000.0 f/;M	\ first order linear difference function versions:M CALC.DIM.VARIANCE': { dim  -- }	0.0 f-sum f!	dim calc.extended.stats: self	dim get.mean.linear.int: self	f-mean f!	many: linear.abs-diffs 0	DO		i dim ed.at: linear.abs-diffs		float		f-mean f@ f-		fdup f*		f-sum f@ f+  f-sum f!	LOOP	f-sum f@ many: linear.abs-diffs float f/	100000. f* f>i dim to: variances';M	:M GET.DIM.VARIANCE': { dim -- , f-variance' }	dim calc.dim.variance': self	dim at: variances'	float 100000. f/;M\ Standard deviation is stored * 100000 in fixed point, to get rid\ of scientific notation:M CALC.DIM.SD': { dim -- }	dim calc.dim.variance': self 	dim get.dim.variance': self 	fsqrt 	100000.0 f* f>i 	dim to: standard-deviations';M\ don't need to divide by 100000. when using this one, already does it..:M GET.DIM.SD': { dim -- fsd }	dim calc.dim.sd': self	dim at: standard-deviations'	float 100000. f/;M	\ first order comb difference function versions:M CALC.DIM.COMB-VARIANCE': { dim  -- }	0.0 f-sum f!	dim calc.extended.stats: self	dim get.mean.comb.int: self	f-mean f!	many: comb.abs-diffs 0	DO		i dim ed.at: comb.abs-diffs		float		f-mean f@ f-		fdup f*		f-sum f@ f+  f-sum f!	LOOP	f-sum f@ many: comb.abs-diffs float f/	100000. f* f>i dim to: comb-variances';M	:M GET.DIM.COMB-VARIANCE': { dim -- , f-variance' }	dim calc.dim.comb-variance': self	dim at: comb-variances'	float 100000. f/;M\ Standard deviation is stored * 100000 in fixed point...:M CALC.DIM.COMB-SD': { dim -- }	dim calc.dim.comb-variance': self 	dim get.dim.comb-variance': self 	fsqrt 	100000.0 f* f>i 	dim to: comb-standard-deviations';M	:M GET.DIM.COMB-SD': { dim -- fsd }	dim calc.dim.comb-sd': self	dim at: comb-standard-deviations'	float 100000. f/;M	\ *********************************************************\ Covariance and correlation of a shape with a target shape\ *********************************************************\ These are similar to metrics, but are simpler in operation...fvariable s-meanfvariable t-mean\ One small, "bug" is that if the denominator is zero, that is, if one of the\ standard deviations is zero... then this shows an infinite result.... how to account for\ this in standard statistics??????????:M COVARIANCE: { dim  target-shape -- , f-cov }	target-shape put.target-shape: self	0.0 t-mean f!	0.0 s-mean f!	0.0 f-sum f!	dim calc.dim.stats: self	dim iv-target-shape calc.dim.stats: []	dim dim.fmean: self s-mean f!	dim iv-target-shape dim.fmean: []  t-mean f!	many: self 0 DO			i dim ed.at: self float			s-mean f@ f-			i dim iv-target-shape ed.at: [] float			t-mean f@ f-			f*			f-sum f@ f+ f-sum f!	LOOP	f-sum f@ many: self float f/;m:M CORRELATION: { dim target-shape -- , f-corr }	target-shape put.target-shape: self	dim calc.extended.stats: self	dim iv-target-shape calc.extended.stats: []	dim iv-target-shape covariance: self	dim get.dim.sd: self 	dim iv-target-shape get.dim.sd: []	f* f/;M:M COVARIANCE': {  dim target-shape -- , f-cov' }	target-shape put.target-shape: self	0.0 t-mean f!	0.0 s-mean f!	0.0 f-sum f!	dim calc.extended.stats: self	dim iv-target-shape calc.extended.stats: []	dim get.mean.linear.int: self 	s-mean f!	dim iv-target-shape get.mean.linear.int: []  	t-mean f!	many: linear.abs-diffs 0 DO			i dim ed.at: linear.abs-diffs float			s-mean f@ f-			i dim iv-target-shape get.linear.abs-diffs: [] float			t-mean f@ f-			f*			f-sum f@ f+ f-sum f!	LOOP	f-sum f@ many: linear.abs-diffs float f/;m:M CORRELATION': { dim target-shape -- , fcorr' }	target-shape put.target-shape: self	dim calc.extended.stats: self	dim iv-target-shape calc.extended.stats: []	dim iv-target-shape covariance': self	dim get.dim.sd': self 	dim iv-target-shape get.dim.sd': []	f* 	f/;M:M COMBINATORIAL.COVARIANCE': { dim target-shape -- , fcorr' }	target-shape put.target-shape: self	0.0 t-mean f!	0.0 s-mean f!	0.0 f-sum f!	dim calc.extended.stats: self	dim iv-target-shape calc.extended.stats: []	dim get.mean.comb.int: self 	s-mean f!	dim iv-target-shape get.mean.comb.int: []  	t-mean f!	many: comb.abs-diffs 0 DO			i dim ed.at: comb.abs-diffs float			s-mean f@ f-			i dim iv-target-shape get.comb.abs-diffs: [] float			t-mean f@ f-			f*			f-sum f@ f+ f-sum f!	LOOP	f-sum f@ many: comb.abs-diffs float f/;m:M COMBINATORIAL.CORRELATION': { dim target-shape  -- , fcorr' }	target-shape put.target-shape: self	dim calc.extended.stats: self	dim iv-target-shape calc.extended.stats: []	dim iv-target-shape combinatorial.covariance': self	dim get.dim.comb-sd': self 	dim iv-target-shape get.dim.comb-sd': []	f* f/;M\ FINALE Utility routines\ ************************\ This routine takes a value and dimension, and removes all elements\ of the shape which have that value in the specified dimension\ For example, if you wanted to remove all zero pitch values,\ you could do 0 1 n.remove: my-shape:M N.REMOVE:  { val dim | indx -- }	0 -> indx	BEGIN		indx  many: self		< 	WHILE		indx dim ed.at: self		val =		IF			indx remove: self		ELSE			1 +-> indx		THEN	REPEAT;m\ This method "prepares" a relative shape for sending\ to FINALE with rests. 0 pitch values will be read as rests by\ FINALE. \ The input to this word is a relative shape with\ ontimes, possibility of chords, and 0 pitch values \ representing rests.\ The output of this word is a compressed, absolute shape.\ What you want to send to finale is an expanded, absolute\ shape\ After this word, use, where shape.comp is the shape you've\ got and shape.exp is the shape you want\ 		 SHAPE.comp SHAPE.exp SH.EXPAND.NOTES\ 		 SHAPE.EXP SAVE.ABS.SHAPE MYMIDIFILE.MF\:M REL.SHAPE->FINALE: { -- }	0 integrate: self ( integrate dimension 0 )	drop	0 1 n.remove: self;M\ *******************\ PRINTING\ *******************:m PRINT:	print: super	cr	tab tab tab dimension: self 	0 DO i . tab tab LOOP cr	." Fundamentals: " tab tab	dimension: self 0 DO i at: fundamentals . tab tab LOOP	cr cr	iv-source-shape 0= NOT	IF ." Source shape: " iv-source-shape name: [] cr THEN	iv-target-shape 0= not	IF ." Target shape: " iv-target-shape name: [] cr THEN	dimension: self 0 DO i calc.extended.stats: self LOOP	cr tab ." Hit any key for more statistics ... " cr	tab tab ." (Q or esc to quit) " cr	key dup 27 = swap 113 = or not 	IF		." Dimension means (floating point): " tab 			dimension: self 0 DO 			i dim.fmean: self f. tab		LOOP		cr		." Linear interval means: " tab 			dimension: self 0 DO 		i get.mean.linear.int: self f. tab		LOOP		cr		." Combinatorial interval means: " tab		dimension: self 0 DO 		i get.mean.comb.int: self f. tab		LOOP			cr			." Linear interval maxima: " tab			dimension: self 0 DO 		i get.max.linear.int: self . tab		LOOP		cr		." Combinatorial interval maxima: "tab		dimension: self 0 DO 		i get.max.comb.int: self . tab		LOOP		cr		." Linear interval minima: " tab			dimension: self 0 DO 		i get.min.linear.int: self . tab		LOOP		cr		." Combinatorial interval minima: "tab		dimension: self 0 DO 		i get.min.comb.int: self . tab		LOOP		cr		." Standard Deviations of morph values: " 	cr tab		dimension: self 0 DO 			i calc.dim.sd: self			i get.dim.sd: self f.			tab		LOOP		cr		." Standard Deviations of first order difference function: " cr tab		dimension: self 0 DO 			i calc.dim.sd': self			i get.dim.sd': self f.			tab		LOOP		cr		." Standard Deviations of first order combinatorial difference function: " cr tab		dimension: self 0 DO 			i calc.dim.comb-sd': self			i get.dim.comb-sd': self f.			tab		LOOP		cr cr		iv-target-shape 0= not		IF			." Target shape comparisons : " cr			tab ." Correlation,  Correlation', Covariance, Covariance', Comb-Corr', Comb-Covar'" cr 	 		dimension: self 0 			DO 				tab	i iv-target-shape correlation: self f. 				tab	i iv-target-shape correlation': self f.				tab	i iv-target-shape covariance: self f. 				tab	i iv-target-shape covariance': self f. 				tab	i iv-target-shape combinatorial.correlation': self f. 				tab	i iv-target-shape combinatorial.covariance': self f. 			LOOP cr		THEN		cr cr	THEN;m;CLASSOB.NEW-SHAPE NEW-SH2OB.NEW-SHAPE NEW-SH3ob.new-shape new-sh1.expOB.NEW-SHAPE NEW-SH1.compob.NEW-SHAPE BIG-SHAPEob.new-shape scale-shape: TEST.NEW-SHAPE ( -- ) \   15 3 NEW: NEW-SH1.exp	15 4 NEW: NEW-SH1.comp    stuff{		1024 0  64  1024 	  1024	50	64  512	 1024	0	64  512 ( on glitch )		0	60  64	1024	  1024	62	64  1024  ( off glitch )	  256  0 	64  256	  1024	0  	64 	1024	  2048  64	64  512	}stuff: NEW-sh1.comp	10 1 new: scale-shape	stuff{ -5 10 30 -1 29 17 2 15 20 0 }stuff: scale-shape\	300 4 new: big-shape\	300 0 DO\			10 4 choose 60 10 add: big-shape\	LOOP\	1024 ticks/beat !\	4 ticks/beat @ * tpw!;: T2	 32 4 NEW: NEW-SH3    stuff{	   0   30   64  10	  20   22   64   2   ( on glitch )	  22   11   64   8	  40   10   64  10	  50   61   64   1   ( off glitch )	  60   3   64  10	  80   55   64   1   ( double on glitch )	  82   59   64   2	  84   14   64   8	}stuff: new-sh3	 32 4 NEW: NEW-SH2    stuff{	   0   50   64  10	  20   60   64   2   ( on glitch )	  22   57   64   8	  40   100   64  10	  50   61   64   1   ( off glitch )	  60   53   64  10	  80   55   64   1   ( double on glitch )	  82   55   64   2	  84   57   64   8	}stuff: new-sh2;ob.new-shape s-1ob.new-shape s-2: T3	5 1 NEW: s-1    stuff{	 51 19 3 1 1	}stuff: s-1	5 1 NEW: s-2    stuff{	2 3 9 11 71	}stuff: s-2	0 ph: s-1	0 ph: s-2	s-1 put.target-shape: s-2;: TERM.T3	free: s-1	free: s-2;: STAT.TEST	t3	cr	." Correlations " cr	0 s-1 correlation: s-2 f.	cr	0 s-1 correlation': s-2 f.	cr	." Covariances " cr	0 s-1 covariance: s-2 f. cr	cr	0 s-1 covariance': s-2 f.	;if.forgotten term.t3