\ Class definition for metric shapes\ One of two files, actual metrics are in second file\ author: lp\ note: these methods are only valid, so far, for equal length metrics\ originally from 17 Simple Melodies ... , but revised, starting\ 1/18/89 Solo\ last change made 5/13/89, solo\ rev: 8/20 changed fundamental to fund\ optimized */.roundup\ 8/21  changed down, up and equal counts to arrays: 1 for each dimension\ 8/23/91 added #.difference.linear.contour:\ This file includes definitions, utilities, intervals, etc.\ These shapes are now a subclass of NEW-SHAPE, which incorporates\ some new utilities.ANEW TASK-METRIC \ store and retrieve index of shape to mutate around or take intervals tomethod put.fund-index:method get.fund-index:method put.fundamental-index:method get.fundamental-index:\ methods for deciding what index to mutate around or take intervals tomethod put.adjacency-offset:method get.adjacency-offset:method use.adjacent:method use.fund-index:method use.fundamental-index: ( just for safety )\ the following four methods are the samemethod use.fund:method use.fundamental: ( just for safety )method use.fund-value: ( just for safety )method use.fundamental-value: ( just for safety )method get.interval-index:method sync.target-index:method interval.start:method get.interval-length:\ INTERNAL INTERVALS AND CALCULATIONSmethod abs.magnitude:method calc.signed.dim-diff-mean:method fcalc.signed.dim-diff-mean: \ floating point versionmethod use.signed.diff.interval:method abs.diff.interval:method absolute.difference.interval: \ same as above...method use.abs.diff.interval:method calc.abs.dim-diff-mean:method fcalc.abs.dim-diff-mean: \ floating point versionmethod ratio.interval:method harmony.interval.et:method octave#:method signed.diff.interval:method signed.difference.interval: \ same as abovemethod use.ratio.interval:method use.harmony.interval.et:method calc.harmony.et.dim-diff-mean:method direction.interval:method direction+-.interval:method use.direction.interval:method use.direction+-.interval:\ some utilities for calculating direction metricsmethod calc.linear-directions: method calc.combinatorial-directions:method get.linear.up-count:method get.linear.down-count:method get.linear.equal-count:method get.comb.up-count:method get.comb.down-count:method get.comb.equal-count:method interval:method interval-target:\ UTILITIES AND INTERNAL CALCULATIONSmethod setup.target:method get.curr-dim:method put.curr-dim:method reset.contour.vectors:method put.harmony-et-table:method get.harmony-et-table:method put.dim-weight:method get.dim-weight:method put.temp-distance:method get.temp-distance:method calc.abs.diff.min:method calc.abs.diff.max:method print.interval.type:\ COMPARISONS OF TWO MORPHOLOGIESmethod #.diff.lin.cont:method #.diff.lin.abs.mag:method #.diff.lin.signed.mag:\ INTERVAL WEIGHTING FUNCTION UTILITIESmethod get.linear.weight.function:method put.linear.weight.function:method get.row.weight.function:method put.row.weight.function:method get.column.weight.function:method put.column.weight.function:method do.column.weight.function:method do.linear.weight.function:method do.row.weight.function:method put.metric.weight:method get.metric.weight:method combinatorial.weight.running.sum:method reset.metric.weights:\ METRICSmethod ULAM:method OLAM:method OLD:method ULD:method OCD:method UCD:method ULM.UNSCALED:method ULM.RELATIVE.SCALED:method ULM.ABSOLUTE.SCALED:method ULM:method UCM:method UCM.ABSOLUTE.SCALED:method UCM.RELATIVE.SCALED:method UCM.UNSCALED:method OLM.UNSCALED:method OLM.UNSCALED.SQUARED:method OLM.RELATIVE.SCALED:method OLM.ABSOLUTE.SCALED:method OLM:method OLM.SQUARED:method OCM:method OCM.SQUARED:method OCM.ABSOLUTE.SCALED:method OCM.RELATIVE.SCALED:method OCM.UNSCALED:method OCM.UNSCALED.SQUARED:method OLH.ET:method ULH.ET:\ setting upmethod reset.metric:\ printingmethod PRINT.CONTOUR.VECTORS:\ CONSTANTS FOR DIFFERENT INTERVALS IN USE0 k: direction_interval1 k: abs_diff_interval2 k: signed_diff_interval3 k: ratio_interval4 k: direction+-_interval5 k: harmony_interval_et\ constants for positions in contour vectors0 k: down1 k: equal2 k: up\ constants for figuring out which weights in use0 k: linear1 k: combinatorial\ floating point running sums for weightsfvariable f-weight-sumfvariable f-linear-weight-sumfvariable f-combinatorial-weight-sumfvariable frunning-sumv: running-sum\ constants, assigned with each metric function for weighting0 k: olm1 k: ocm2 k: old3 k: ocd4 k: ulm5 k: ucm6 k: uld7 k: ucd\ ============================================\ The following utility  works exactly like */, but\ without the double precision, but rounds up if\ the product is on the "=" side of 500, instead\ of the usual forth truncation.\ this is important to use in mutators, which\ should go to the new value if they are closer\ this should be rewritten some day to make it\ faster and double precision, but this\ simple version suffices for the metric stuff.\ it should more properly \ be in a utility file somewhere, not here in metrics...v: temp-mult: */.ROUNDUP { n mult div -- rounded-dividend }	 mult n * ( --  mult*n )	div /mod	swap div 2/ 1+ >= 	IF 1+ THEN;\ ====================================================================\                          UTILITIES\ ====================================================================\ Note: long instance variables used because iv+> only works on that!!!:CLASS  OB.M.SHAPE        <super ob.new-shape                iv.long max-length \ maximum length of target and source shapes        iv.long curr-dim        iv.long diff-count \ count of different intervals between two shapes        iv.long temp-m-shape \ used for storing temp-shape addresses        iv.long temp-distance		iv.long iv-interval		iv.long iv-fund-index \ index for source of intervals		iv.long iv-adjacency-offset			iv.long iv-adjacent?		iv.long iv-fundamental?		iv.long iv-target-synched?\		iv.long iv-linear.weight.function		iv.long iv-row.weight.function		iv.long iv-column.weight.function		iv.long iv-linear.weight		iv.long iv-combinatorial.weight\		ob.array dim-weights \ to store weights for each dimension		ob.array up-count \ direction counts   		ob.array down-count   		ob.array equal-count		ob.array harmony-et-table\		ob.shape lin-cont-vector		ob.shape comb-cont-vector	:m INIT:	init: super	0 iv=> iv-interval	0 iv=> iv-fund-index	0 iv=> iv-fundamental?\ use adjacent to begin with, with 1 offset	1 iv=> iv-adjacency-offset	-1 iv=> iv-adjacent?	'c mw.unity iv=> iv-linear.weight.function	'c mw.unity iv=> iv-row.weight.function	'c mw.unity iv=> iv-column.weight.function;m:m NEW: { el dim -- }    el dim new: super	dim new: dim-weights\ 0 = unison, 1 = p5th,  2 = maj3, 3 = min3, 4= maj6, 5 = min6 6 = p4,\  7 = min7th, 8 = maj2, 9 = tt, 10 = maj7, 11 = min2	12 new: harmony-et-table	1 11 6 2 10 5 8 9 3 4 7 0 12 stuff: harmony-et-table	3 dim new: lin-cont-vector	3 dim new: comb-cont-vector;m :m FREE:	free: dim-weights	free: up-count	free: down-count	free: equal-count	free: harmony-et-table	free: lin-cont-vector	free: comb-cont-vector    free: super;m\ ====================================\  		Index of intervals\ ====================================\ FUND-INDEX is used to set some value in a shape as an index\ for interval taking. This is different than the fundamental,\ which is always an index of -1 ...:M PUT.FUND-INDEX: ( index -- )	0 many: self 1- clipto	iv=> iv-fund-index;m:M GET.FUND-INDEX:	iv-fund-index;m\ some alternate names:M GET.FUNDAMENTAL-INDEX:	get.fund-index: self;m:M PUT.FUNDAMENTAL-INDEX: 	put.fund-index: self;m\ =========================================================\ 	Adjacency Or Not, Fundamental, Or Fundamental Index\ =========================================================\ The following routines are used to decide what to take\ intervals to: fundamental (-1 index), fund-index, or\ adjacency (with a specified offset):m PUT.ADJACENCY-OFFSET:	iv=> iv-adjacency-offset;m:m GET.ADJACENCY-OFFSET:	iv-adjacency-offset;m:m USE.ADJACENT:	-1 iv=> iv-adjacent?;m\ use a specified value in shape for all intervals:m USE.FUND-INDEX:	0 iv=> iv-adjacent?	0 iv=> iv-fundamental?;m:m USE.FUND:	0 iv=> iv-adjacent?	-1 iv=> iv-fundamental?;m:M USE.FUNDAMENTAL:	use.fund: self;m:M USE.FUNDAMENTAL-VALUE:	use.fund: self;m:M USE.FUND-VALUE:	use.fund: self;m\ Takes i, usually from a loop through a shape, and\ returns an index which is i- an-offset, or the fundamental to\ be taken distances to. If the index is -1, that means\ that means that future ed.at:'s will get the fundamental\ for curr-dim. :m GET.INTERVAL-INDEX:  ( i -- n, returns i-offset, or fund )	iv-adjacent? 	IF	\ this is buggy, because it's not checking if it goes back further	\ than the beginning of the shape....!!!!!!!!!!	\ if adjacent, then get offset and use current - offset		iv-adjacency-offset - 	\ if it's not adjacent, it's either fundamental or	\ fundamental-index	ELSE 		iv-fundamental?  \ uses external fundamental?		IF drop -1  \ leave a -1 as the index for interval calc.			\ else, use index from shape itself		ELSE drop iv-fund-index		THEN	THEN;m\ Makes target the same as source, used in usual case, where\ interval calculation in the target is to the same index\ as the source, or adjacent in the same way....\ if wants to be different, don't use this!!!!!\ Many of the mutators now use this (5/17/89)\ 8/20/92 added check to make sure morph has a target:m SYNC.TARGET-INDEX: 	iv-target-shape 0= not \ if the target is zero, don't do anything.	IF		true iv=> iv-target-synched?	\ first sync type of interval taking, and where to take it to		iv-adjacent? 		IF			iv-target-shape use.adjacent: []			get.adjacency-offset: self			iv-target-shape put.adjacency-offset: []		ELSE			iv-fundamental?			IF 				iv-target-shape use.fund: []				\ make fundamental the same for curr-dim				-1 curr-dim ed.at: self				-1 curr-dim iv-target-shape ed.to: []			ELSE				iv-target-shape	use.fund-index: []				get.fund-index: self				iv-target-shape put.fund-index: []				THEN		THEN	ELSE		." Can't sync target because no target shape " cr	THEN;m\ If this is ADJACENT, all interval calculations have to start\ at least offset into the shape! If FUNDAMENTAL, then starts\ at 0!!!!!\ BUT HAVE TO PUT IN SKIPPING ROUTINE!!\ Compute, on the basis of what type of interval taking,\ where to start looping through a shape:m INTERVAL.START:	iv-adjacent?	IF\ if adjacent, start at the offet into the shape (length= n-offset)		iv-adjacency-offset	ELSE\ all else, do every value in the shape (n, rather than n-offset	0	THEN;m\ The following calculates various types of interval lengths for\ shapes, based on the type of interval calculation. If adjacent,\ the interval length is n-adjacency-offset, if fundamental, n=1\ Need to expand this to include notion of combinatorial length,\ in fact this same calculation repeated can generate n(n-1)/2!!!!\ should check this later to see if for external fundamentals,\ many -1 is the correct length (2/11/92 It's not, changed it.... ):m GET.INTERVAL-LENGTH: ( -- L , return proper length for calculation )	iv-adjacent?	IF			many: self iv-adjacency-offset -	ELSE	\ fundamental		many: self 		( 2/11/92 changed this from many: self -1 to simply many: self )		( if using a fundamental, you take the index to all values in the morph )	THEN;m\ ====================================\  INTERVAL	WEIGHTING FUNCTIONS\ ====================================\ All of these weighting functions take one argument, and return a floating point number\ to be used as a scalar. in addition, each must update the \ appropriate ones of the three floating point\ running sums, which are stored in fixed point as instance variables, separately for \ source and target.: FLOAT.WEIGHTS.TO.FIX ( f-weight -- int-weight )	100000.0 f* f>i;: FIX.WEIGHTS.TO.FLOAT ( int-weight -- float-weight )	float 100000.0 f/;:M PUT.METRIC.WEIGHT: ( f-weight 0/1 -- , put in fixed version of weight )	CASE		linear of float.weights.to.fix iv=> iv-linear.weight endof		combinatorial  of float.weights.to.fix iv=> iv-combinatorial.weight endof		dup 1 > ?OF ." Not row, column, or linear weight " cr endof		." illegal value passed to weight storage = " dup . cr	ENDCASE;M:M GET.METRIC.WEIGHT: (  0/1/2 -- , return fixed version of weight )	CASE		linear of iv-linear.weight fix.weights.to.float endof		combinatorial of iv-combinatorial.weight fix.weights.to.float endof		dup 2 > ?OF ." Not row, column, or linear weight " cr endof		." illegal value passed to weight storage = " dup . cr	ENDCASE;M\ row, column and linear weight functions:M PUT.LINEAR.WEIGHT.FUNCTION:	  iv=> iv-linear.weight.function;M:M GET.LINEAR.WEIGHT.FUNCTION:	iv-linear.weight.function;M:M DO.LINEAR.WEIGHT.FUNCTION: ( i -- ind*function )	( i gets passed to weight function )	dup 0= IF cr ." Caution: Passing a zero index to linear weight function " cr THEN	get.interval-length: self ( must pass length to function )	get.linear.weight.function: self	execute 	fdup 	linear get.metric.weight: self f+ linear put.metric.weight: self;M:M PUT.ROW.WEIGHT.FUNCTION:	 iv=> iv-row.weight.function;M:M GET.ROW.WEIGHT.FUNCTION:	iv-row.weight.function;M:M DO.ROW.WEIGHT.FUNCTION: ( i -- ind*function )	( i gets passed to weight function )	dup 0= IF cr ." Caution: Passing a zero index to row weight function " cr THEN	many: self ( pass length to function )	get.row.weight.function: self	execute ;M:M PUT.COLUMN.WEIGHT.FUNCTION:	  iv=> iv-column.weight.function;M:M GET.COLUMN.WEIGHT.FUNCTION:	iv-column.weight.function;M:M DO.COLUMN.WEIGHT.FUNCTION: ( i -- ind*function )	( i gets passed to weight function )	dup 0= IF cr ." Caution: Passing a zero index to column weight function " cr THEN	many: self ( pass length to function )	get.column.weight.function: self	execute ;M\ this must be passed two indices, row column...\ do this once for each interval calculation:M COMBINATORIAL.WEIGHT.RUNNING.SUM: { i-ind j-ind -- }	i-ind do.row.weight.function: self	j-ind do.column.weight.function: self	f*	combinatorial get.metric.weight: self f+ combinatorial put.metric.weight: self;M:M RESET.METRIC.WEIGHTS:	0.0 f-weight-sum f!	0.0 f-linear-weight-sum f!	0.0 f-combinatorial-weight-sum f!	0.0 combinatorial put.metric.weight: self	0.0 linear put.metric.weight: self	0.0 linear iv-target-shape put.metric.weight: []	0.0 combinatorial iv-target-shape put.metric.weight: [];M\ ====================================\ 	MORE UTILITIES\ ====================================:M PUT.HARMONY-ET-TABLE:  ( value dim -- )        to: harmony-et-table ;M :m GET.HARMONY-ET-TABLE:  ( dim -- value )        at: harmony-et-table ;M:M PUT.DIM-WEIGHT:  ( value dim -- )        to: dim-weights ;M :m GET.DIM-WEIGHT:  ( dim -- value )        at: dim-weights ;m:m GET.LINEAR.UP-COUNT: ( dim -- #ups )	 up ed.at: lin-cont-vector;m:m GET.LINEAR.DOWN-COUNT: ( dim -- #downs )	down ed.at: lin-cont-vector;m:m GET.LINEAR.EQUAL-COUNT: ( dim -- #equal )	equal ed.at: lin-cont-vector;m :m GET.COMB.UP-COUNT: ( dim -- #ups )	 up ed.at: comb-cont-vector;m:m GET.COMB.DOWN-COUNT: ( dim -- #downs )	down ed.at: comb-cont-vector;m:m GET.COMB.EQUAL-COUNT: ( dim -- #equal )	equal ed.at: comb-cont-vector;m:m PUT.TEMP-DISTANCE: ( val -- )        iv=> temp-distance;m :m GET.TEMP-DISTANCE: ( -- val )        temp-distance;m \ **************\ Curr-dim set\ **************\ curr-dim is used by many methods, for example\ to determine which dimension to take a single\ dimensional metric in. Note that mutators use\ it as well, to do single dimension mutations.:m PUT.CURR-DIM: ( n -- )        iv=> curr-dim;m :m GET.CURR-DIM: ( -- n )        curr-dim;m\ ***************\ Contour Vectors\ ***************:m RESET.CONTOUR.VECTORS: ( -- , zero relevant counters to combinatorial direction )        0 iv=> diff-count        dimension: self 0 		DO			0 i down ed.to: lin-cont-vector			0 i equal ed.to: lin-cont-vector	 		0 i up ed.to: lin-cont-vector			0 i down ed.to: comb-cont-vector			0 i equal ed.to: comb-cont-vector	 		0 i up ed.to: comb-cont-vector		LOOP;m\ Simple utility for assuring same dimension in target and source:m SETUP.TARGET:  ( target-shape -- , set dimension same; store in inst. var. )	dup iv=> iv-target-shape	dup reset.contour.vectors: []	get.curr-dim: self ( -- target dim )	swap put.curr-dim: [];m \ ===========================================================\                    INTERVALS\ ===========================================================\ Note that all intervals are in current dimensions. To take a\ valid metric, most often the current dimensions for each shape\ should be the same!!\ These routines all get "fed" two indexes, which should be generated\ elsewhere, depending on the type of indexed-interval calculation\ used. Note that even the "non-interval" abs.magnitude: is fed these\ two indices, just so that everything is consisten:M ABS.MAGNITUDE: ( i j -- , returns the value at i )	drop ( get rid of j value , this is not even computing an interval )	curr-dim ed.at: self ( simply returns ith value );m\ This routine returns a positive value if the ith value is\ greater than the jth value, a negative value if the jth value\ is greater than the ith value:M SIGNED.DIFF.INTERVAL: ( i j -- ei-ej, in current dimension )	curr-dim ed.at: self \  -- i jth-value	swap \ -- jth-value i	curr-dim ed.at: self \ -- jth-value ith-value	swap -;m:M SIGNED.DIFFERENCE.INTERVAL: ( i j -- ei-ej, same as above, different name )	signed.diff.interval: self;m:m USE.SIGNED.DIFF.INTERVAL: ( -- )	signed_diff_interval iv=> iv-interval;m:M ABS.DIFF.INTERVAL: ( i j -- |ei-ej|, in current dimension )	signed.diff.interval: self	abs;m:M ABSOLUTE.DIFFERENCE.INTERVAL: ( i j -- , same as above )	abs.diff.interval: self;m:M CALC.ABS.DIFF.MIN: ( -- min, in current dimension )	0 \ seed comparison	many: self 1 DO			i 			i get.interval-index: self 			abs.diff.interval: self			2dup > IF swap drop ELSE drop THEN		LOOP;m:M CALC.ABS.DIFF.MAX: ( -- max, in current dimension )	0 \ seed comparison	many: self interval.start: self  	DO			i 			i get.interval-index: self 			abs.diff.interval: self			2dup < IF swap drop ELSE drop THEN		LOOP;M:m USE.ABS.DIFF.INTERVAL: ( -- )	abs_diff_interval iv=> iv-interval;m:m CALC.ABS.DIM-DIFF-MEAN: ( -- mean , get mean of abs. val. of diffs )	0 \ seed mean calculation	many: self interval.start: self 	DO		i 		i get.interval-index: self		abs.diff.interval: self		+	LOOP	get.interval-length: self  /;m:m FCALC.ABS.DIM-DIFF-MEAN: ( -- fmean , get mean of abs. val. of diffs )	0.0 \ seed mean calculation	many: self interval.start: self 	DO		i 		i get.interval-index: self		abs.diff.interval: self float		f+ 	LOOP	get.interval-length: self float f/;m				:m CALC.SIGNED.DIM-DIFF-MEAN: ( -- n , get mean of abs. val. of diff. )	0 \ seed mean calculation	many: self interval.start: self	DO		i 		i get.interval-index: self		signed.diff.interval: self		+ 	LOOP	get.interval-length: self /;m:m FCALC.SIGNED.DIM-DIFF-MEAN: ( -- fmean , get mean of abs. val. of diff. )	0.0 \ seed mean calculation	many: self interval.start: self	DO		i 		i get.interval-index: self 		signed.diff.interval: self float		f+ 	LOOP	get.interval-length: self float f/;m\ The following routine may be overly complicated, and could probably be simplified with\ some though. However, it seems to work.... (2/10/92)\ e.g 30 25 = 7, 30 40 = 10, 30 18 = 0 (F# F# = unison), \ 30 11 = 5 (F# B = Tritone ): PITCHES->INTERVAL ( fund other-pitch -- n, where n is the number of half steps )					( in the octave adjusted interval to the fundamental )		tuck \  -- fund pitch fund 		- 12 mod \  -- fund (pitch-fund)mod12 		12 swap - \  -- fund 12-(pitch-fund)mod12) 		12 mod 		nip;\ *****************************************			\ the following interval returns a value from 0-11 in the following way\ 0 = unison, 1 = p5th, 2 = p4, 3 = maj3, 4 = min3, 5 = maj6, 6 = min6\ 7 = maj2, 8 = min7th, 9 = tt, 10 = maj7, 11 = min2\ This table corresponds more or less to the harmonic series intervals\ which approximate this et intervals, but it could certainly be changed for \ the "harmonic" requirements of a particular piece.... just rearrange the value \ of the table...\ Note that this collapses octave (see PITCHES->INTERVAL. Think of this as "chroma" and the octave\ interval as "height". It is always just a positive number...\ This assumes that the first value is the fundamental!!!! (i-ind)\ This is quite important since it's an assymetrical relation.:M HARMONY.INTERVAL.ET: { i-ind j-ind -- 0-11, in current dimension }        i-ind curr-dim  ed.at: self ( -- ei )  		j-ind curr-dim  ed.at: self ( --  ei ej ) 		 \  proper order for next routine, ei is the fundamental		pitches->interval		( now find it's "harmonic distance" )		indexof: harmony-et-table ( index true, or false )		not IF				." Invalid index to harmony ET table !!!! " cr		THEN;M:M USE.HARMONY.INTERVAL.ET: ( -- )	harmony_interval_et iv=> iv-interval;M\ This allows mutants and metrics to keep track, when using something like the Harmony\ interval, what octave  something is (harmony interval collapses that!) \ O means they're in the same octave....\ #-oct = 0 means # from 1-11.:M OCTAVE#: { i-ind j-ind -- abs#-oct, indicating what oct }        i-ind curr-dim  ed.at: self 		12 /mod drop ( --  rem )		j-ind curr-dim ed.at: self		swap - 		12 /mod ( -- rem # )		swap drop;M\ The order of values given to harmony.interval.et: is very important: it is an\ assymetrical relation. The "fundamental" must be first...:M CALC.HARMONY.ET.DIM-DIFF-MEAN: ( -- mean , get mean of abs. val. of harmonic intervals )	0 \ seed mean calculation	many: self interval.start: self 	DO		i 		i get.interval-index: self		swap ( -- fund pitch )		harmony.interval.et: self		+	LOOP	\ scale these values to 0-1000 to retain accuracy in metrics	1000 	get.interval-length: self 11 *	 */;M:M RATIO.INTERVAL: ( i j -- i/j*1000, in current dimension )\ e.g 2000 means the ith is twice the jth\ 500 means the ith is half the jth        curr-dim  ed.at: self ( --  ej )        swap curr-dim  ed.at: self ( -- ej ei )        1000 * \ to gain three decimal place accuracy        swap /;M:M USE.RATIO.INTERVAL: ( -- )	ratio_interval iv=> iv-interval;M\ Think of the 1, -1 here as the relation between i and j. So -1 means "is less than"\ If the interval ascends, it's a -1, so often, to get the "sign" of\ the interval, in the mutator calculations, you have to multiply the results\ of this method by a -1:M DIRECTION.INTERVAL: ( i j -- -1|0|1, in current dimension )\ 1 means the jth is lower than the ith ( i "is greater than" j )\ -1 means the jth is higher than the ith ( i "is less than" j )\ 0 means they're equal     	curr-dim  ed.at: self ( -- i ej )        swap ( -- ej i )		curr-dim  ed.at: self ( -- ej ei )		swap		direction? ( -- 1|0|-1 ) ;m:m USE.DIRECTION.INTERVAL: ( -- )	 direction_interval iv=> iv-interval;m:M DIRECTION+-.INTERVAL: ( i j -- -1|0|1, in current dimension )\ -1 means the jth is lower than the ith\ 1 means the jth is higher than the ith\ 0 means they're equal       	curr-dim  ed.at: self ( -- i ej )        swap ( -- ej i )		curr-dim  ed.at: self ( -- ej ei )		swap		direction+-? ( -- 1|0|-1 ) ;m:m USE.DIRECTION+-.INTERVAL: ( -- )	 direction+-_interval iv=> iv-interval;m\ ====================================================\                     INTERVAL CHOOSING ROUTINES\ ====================================================\ 4/16  NOTE to LP from LP ask phil if there is a slicker way to \ do this sort of  vectored late-binding method usage!!!:M INTERVAL-TARGET: ( i j -- value, use current interval on target )	iv-interval	CASE		direction_interval of iv-target-shape direction.interval: []			endof		abs_diff_interval  of iv-target-shape abs.diff.interval: []			endof		signed_diff_interval of iv-target-shape abs.diff.interval: []			endof		ratio_interval of iv-target-shape ratio.interval: []			endof		harmony_interval_et of iv-target-shape harmony.interval.et: []			endof		." INVALID INTERVAL TYPE !!!! " cr	ENDCASE;m\ Print current interval calculation type for shape:M PRINT.INTERVAL.TYPE:	iv-interval	CASE		 direction_interval of ." Direction interval " endof		 abs_diff_interval  of ." Abs. diff. interval " endof		 signed_diff_interval of ." Signed diff. interval " endof		 ratio_interval  of ." Ratio interval " endof		 direction+-_interval of ." Direction+- interval " endof		 harmony_interval_et of ." Harmony (ET) interval " endof		." INVALID INTERVAL TYPE !!!! "	ENDCASE;m\  "Vectored" interval calculation for source shape:M INTERVAL:	( i j -- value, use current interval on source )	iv-interval	CASE		direction_interval of direction.interval: self endof		direction+-_interval of direction+-.interval: self endof		abs_diff_interval of abs.diff.interval: self endof		signed_diff_interval of abs.diff.interval: self endof		ratio_interval of  ratio.interval: self endof		harmony_interval_et of harmony.interval.et: self endof		." INVALID INTERVAL TYPE !!!! " cr	ENDCASE;m\  ===========================\      New enhanced clone \  ===========================\ This new version of clone also makes external fundamentals the same:m CLONE: ( target -- )	dup 	iv=> iv-target-shape	clone: super	iv-adjacent? 	IF		iv-target-shape	use.adjacent: []		get.adjacency-offset: self		iv-target-shape put.adjacency-offset: []	ELSE		iv-fundamental?		IF			iv-target-shape use.fund: []		ELSE			iv-target-shape use.fund-index: []			get.fund-index: self			iv-target-shape put.fund-index: []		THEN	THEN	;m:M RESET.METRIC: ( target-shape -- )		setup.target: self		sync.target-index: self		reset.metric.weights: self        reset.contour.vectors: self;M			include metrics:metric_2