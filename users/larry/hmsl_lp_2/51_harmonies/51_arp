\ 51 Harmonies\ arpeggios\ author lpanew task-51_arpob.objlist arp-listob.shape arp-dataob.array arp-fundsob.shape arp-distances0 value tolerancev: #-arpsv: test-counter1000 value tolerance-update6 value fund-dim: INIT.ARP-DATA { | curr-arp  -- }	51 new: arp-list	51 7 new: arp-data \ room for five arps,  #-of arps, fundamental	51 0 DO	\ now pick number of arpeggios, and length of each one...		25 		25 i - abs - \ gets higher towards the middle, and lower to the end		4 / choose 		\ occasionally add two, but not in the first and last place...		3 choose 0=		i 50 = not		i 0 = not		and		and		IF			2 + 		ELSE			1+		THEN		0 0 0 0 0 0  add: arp-data	LOOP	" #-arps " 0 put.dim.name: arp-data	" Har. 1 " 1 put.dim.name: arp-data	" Har. 2 " 2 put.dim.name: arp-data	" Har. 3 " 3 put.dim.name: arp-data	" Har. 4 " 4 put.dim.name: arp-data	" Har. 5 " 5 put.dim.name: arp-data		" fund " fund-dim put.dim.name: arp-data;: INIT.ARP-DISTANCES { | curr-distance max-tonic max-dominant -- }	tonic-distance 500 > 	IF			tonic-distance -> max-tonic 	ELSE		1000 tonic-distance -> max-tonic	THEN	dom-distance 500 > 	IF			dom-distance -> max-dominant	ELSE		1000 dom-distance -> max-dominant	THEN		51 2 new: arp-distances	51 set.many: arp-distances	-1 0 fill.dim: arp-distances	-1 1 fill.dim: arp-distances	\ first fill tonic part...	36 0 DO		0 0 35 max-tonic set.interp		i interp -> curr-distance		curr-distance i 0 ed.to: arp-distances	LOOP  	51 16 DO		0 max-dominant 35 0  set.interp		i 20 - interp -> curr-distance		curr-distance i  1 ed.to: arp-distances	LOOP	" Tonic distances " 0 put.dim.name: arp-distances	" Dominant distances " 1 put.dim.name: arp-distances;: INIT.ARP-FUNDS	11 new: arp-funds	stuff{		60 \ c		67  \ g		62  \ d		57  \ a		64  \ e		56  \ Ab		63  \ eb		58	\ Bb		65	\ f		59    \ b		66  \ f#		61 \ c# 		56  \ ab		62  \ d		67  \ g		60  \ c		53	\ f	}stuff: arp-funds;	: FILL.ARP-DATA { | #-aps temp -- }	51 0 DO	\ first pick the length of each arpeggio		i 0 ed.at: arp-data  		-> #-aps		#-aps  1+		1		DO			25 			25 j - abs -			6 / 1 + choose 6 + 			j i ed.to: arp-data		LOOP		\ now pick the fundamental, which has a slightly random offset		i 3 / at: arp-funds		100 choose 		25 25 i - abs - dup -> temp		3 *		<		IF			2 choose			IF				-1 temp 7 / 1+ choose * 			ELSE				1 temp 7 / 1+ choose * 			THEN			+		THEN		i fund-dim ed.to: arp-data	\ now stuff the first and last place with c and f		60 0 fund-dim ed.to: arp-data		53 50 fund-dim ed.to: arp-data	LOOP;\ the big arp list holds 51 other object lists, each one a certain number of\ arpeggios long...: MAKE.ARPS { | curr-arp curr-list curr-shape temp idx idx2 -- }	\ first instantiate the smaller lists of arps	51 0 DO		instantiate ob.objlist -> curr-arp		curr-arp add: arp-list		i 0 ed.at: arp-data 		curr-arp new: []	LOOP	\ now new the shapes in those lists	51 0 DO		i -> idx		idx at: arp-list		-> curr-list		idx 0 ed.at: arp-data 1+ 1 DO			i -> idx2			instantiate ob.shape -> curr-shape			curr-shape add: curr-list			idx idx2 ed.at: arp-data -> temp			temp 3 curr-shape new: []			\ stuff all the shapes with fundamentals...			\ and add velocity for playback purposes			temp 0 DO				0				idx fund-dim ed.at: arp-data				\ accent first note of each shape				i 0= 				IF					90				ELSE					60				THEN				curr-shape  add: []			LOOP			LOOP	LOOP;: GET.SHAPE { indx shape-# -- }	shape-#	indx at: arp-list	at: [];\ pass it number of harmony, and index into that harmonic based list of arps: INSPECT.SHAPE { indx shape-# -- }	indx shape-# get.shape	print: [];\ this also calculates total number of arps for use by player and other things: #.ARPS?	0 #-arps !	51 0 DO		i 0 ed.at: arp-data 		#-arps +!	LOOP;: LOOK.UP.PITCH { pitch -- }	pitch 12 mod	case 		0 of ." C " endof		1 of ." C# " endof		2 of ." D " endof		3 of ." Eb " endof		4 of ." E " endof		5 of ." F " endof		6 of ." F# " endof		7 of ." G " endof		8 of ." Ab " endof		9 of ." A " endof		10 of ." Bb " endof		11 of ." B " endof	endcase;	: PRINT.ONE.ARP { indx shape-# | curr-shape -- }	cr indx . shape-# . tab tab 	shape-#	indx at: arp-list	at: [] -> curr-shape	curr-shape many: [] 0 DO		i 1 curr-shape ed.at: []		look.up.pitch tab	LOOP	cr;\ pass it number of harmony, and index into that harmonic based list of arps\ this algorithm doesn't allow for repeated notes in the arp...: MAKE.A.RANDOM.ARP  { indx shape-# | idx curr-shape curr-note curr-flag -- }	shape-# indx at: arp-list at: [] -> curr-shape	false -> curr-flag 	curr-shape many: [] 1 DO		BEGIN			0 1 curr-shape ed.at:  []			12 choose +			-> curr-note			false -> curr-flag			i -> idx			idx 0 DO				i 1 curr-shape ed.at: []				curr-note = 				IF					true -> curr-flag 				THEN			LOOP			curr-flag not			?terminal or		UNTIL		curr-note		i 1 curr-shape ed.to: []	LOOP;: LEAVE.FLAG ( distance -- flag )		tolerance <		IF			true		ELSE			false		THEN;: TEST.ARP { indx shape-# | curr-shape td dd curr-td curr-dd -- flag }	shape-# indx at: arp-list at: [] -> curr-shape	curr-shape distance.to.tonic -> td	curr-shape distance.to.dom -> dd	indx 0 ed.at: arp-distances -> curr-td	indx 1 ed.at: arp-distances -> curr-dd	curr-td -1 =	curr-dd -1 =	or	\ if neither ton. or dom is equal to -1, which means it's not a relevant distance	\ do the distance that's not equal to -1	IF		curr-td -1 =		IF			curr-dd dd - abs			leave.flag		ELSE			curr-td td - abs			leave.flag		THEN	ELSE	\ if they're both not equal to -1	\ use the minimum distance, and test that against tolerance...			curr-td td - abs			curr-dd dd - abs			min			leave.flag	THEN;: DO.ONE.ARP { indx shape-# | curr-shape -- }	0 -> tolerance	shape-# indx at: arp-list at: [] -> curr-shape	BEGIN		1 test-counter +!		test-counter @ tolerance-update mod 0= IF tolerance 1 + -> tolerance ." . " THEN		test-counter @ tolerance-update 10 * mod 0= IF curr-shape get.distance.shape . THEN		indx shape-# make.a.random.arp		indx shape-# test.arp		?terminal or	UNTIL	cr tab ." Harmony # : " indx . shape-# . tab	." ¶ " tolerance . cr	tolerance curr-shape put.data: [];: DO.ALL.ARPS { | curr-list curr-shape idx -- }	cr cr	50 1 DO		i -> idx 		cr ." INDEX = " idx . 		idx at: arp-list -> curr-list		curr-list many: [] 0 DO			idx i do.one.arp		LOOP	LOOP; : STUFF.T&D	cr ." Stuffing tonic and dominant " cr	tonic-shape 0	0 at: arp-list		to: []\	dom-shape 0	many: arp-list 1-	at: arp-list	to: []	;					: INIT.ARPS	init.arp-data	init.arp-distances	init.arp-funds	fill.arp-data	make.arps	stuff.t&d	#.arps?;init.arps: TERM.ARPS	freeall: arp-list	free: arp-list	free: arp-data	free: arp-distances;if.forgotten term.arps		