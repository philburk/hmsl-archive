\ tracker jobanew task-tracker_job\ first set up stuff for simple divider.v: divider-counter \ how many beats, then stop it...v: divider-down/up? \ this does a decres. or cresc.: DIVIDER-JOB.START.FUNCTION { job -- }	\ pick a note	75 30 wchoose divider-note !	\ pick a basic starting duration	get.duration: tracker-job	divider-number @ / 	job put.duration: []	\ counter	0 divider-counter !	2 choose divider-down/up? !	;	: DIVIDER-JOB.FUNCTION { job -- }	\ 30 percent possible random deviation	get.duration: tracker-job	divider-number @ / \ basic duration	dup \ -- dur dur	30 choose 100 */ \ deviation from duration	+ job put.duration: []	\ check to see if stopped	1 divider-counter +!	divider-counter @ divider-number @ > 	IF		job stop: []	THEN	100 choose 7 > IF \ occasionally leave one out...		\ print out note		divider-note @ 		divider-loudness @ divider-number @ / \ loudness increment		divider-counter @ * \ current loundess		divider-down/up? @ IF divider-loudness @ swap - THEN \ goes down or up?		0 max 		drum_channel midi.channel!		midi.noteon	THEN;: INIT.DIVIDER-JOB	1 new: divider-job	'c divider-job.start.function put.start.function: divider-job	'c divider-job.function add: divider-job;	\ before and after spans are already adjusted to the job duration when you change \ either the job duration or the spans...\ pass this routine the before or after shape, and a flag which is 0\ for before, 1 for after, and it scales the durations to between\ 0 and the span of the flammer: SCALE.FLAMMER.DURATIONS { f-shape flammer-flag | sum adjusted-pulse -- }	0 f-shape calc.dim.stats: []	0 f-shape get.dim.sum: [] -> sum	\ adjusted pulse = (span * pulse) /100	flammer-flag 0=		IF f-before-span @ ELSE f-after-span @ THEN		get.duration: tracker-job	100 */ -> adjusted-pulse	\ now before and after only occur in first or second halves...	adjusted-pulse 2/ -> adjusted-pulse	\ new dur value = (oldval * adj-pulse/2) / sum	f-shape many: [] 0 	DO		i 0 f-shape ed.at: []		adjusted-pulse 		( -- duration new-span )		sum  */ 		i 0 f-shape ed.to: []	LOOP;: SCALE.BEFORE.LOUDNESS ( loudness -- new-loudness )	f-before-loudness @ 100 */	;: SCALE.AFTER.LOUDNESS ( loudness -- new-loudness )	f-after-loudness @ 100 */;	\ flammer archetypes\ always fill durations first, then amplitudes\ 0 is random; 1 is ascending; 2 descending: COMPUTE.BEFORE.FLAMMER { | f-d-archetype f-a-archetype -- }	d-arch-range @ choose -> f-d-archetype 	a-arch-range @ choose -> f-a-archetype 	f-#-notes-before @ 3 new: flammer-before-shape	f-d-archetype 	CASE		0 OF			f-#-notes-before @ 0 			DO				\ psuedo-gaussian random number				100 choose 100 choose 100 choose + + 3 / 				flammer-before-note @ 60 add: flammer-before-shape			LOOP		ENDOF		\ ascending durations...		1 OF			f-#-notes-before @ 0 			DO				\ ascending				i 1+ 20 * dup 2/ wchoose				flammer-before-note @ 60 add: flammer-before-shape			LOOP		ENDOF		\ descending durations...		2 OF			f-#-notes-before @ 0 			DO				\ descending				f-#-notes-before @ 20 *  i 1+ 20 * - dup 2/ wchoose				flammer-before-note @ 60 add: flammer-before-shape			LOOP		ENDOF	ENDCASE	\ scale the durations	flammer-before-shape 0 scale.flammer.durations	\ now set velocities	f-a-archetype 	CASE	\ gaussian amplitudes		0 OF			f-#-notes-before @ 0 			DO				\ psuedo-gaussian random number				128 choose 128 choose 128 choose + + 3 / 				scale.before.loudness				i 2 ed.to: flammer-before-shape			LOOP		ENDOF		\ ascending velocities	1 OF		f-#-notes-before @ 0 		DO			\ ascending			i 1+ 128 f-#-notes-before @ / * dup 2/ wchoose			scale.before.loudness			i 2 ed.to: flammer-before-shape		LOOP	ENDOF	2 OF		f-#-notes-before @ 0 		DO			\ descending			128 128 f-#-notes-before @ / 1 * -		    dup 2/ wchoose			scale.before.loudness			i 2 ed.to: flammer-before-shape		LOOP	ENDOF	ENDCASE;: COMPUTE.AFTER.FLAMMER { | f-d-archetype f-a-archetype -- }	d-arch-range @ choose -> f-d-archetype 	a-arch-range @ choose -> f-a-archetype 	f-#-notes-after @ 3 new: flammer-after-shape	f-d-archetype 	CASE		0 OF			f-#-notes-after @ 0 			DO				\ psuedo-gaussian random number				100 choose 100 choose 100 choose + + 3 / 				flammer-after-note @ 60 add: flammer-after-shape			LOOP		ENDOF		\ ascending durations...		1 OF			f-#-notes-after @ 0 			DO				\ ascending				i 1+ 20 * dup 2/ wchoose				flammer-after-note @ 60 add: flammer-after-shape			LOOP		ENDOF		\ descending durations...		2 OF			f-#-notes-after @ 0 			DO				\ descending				f-#-notes-after @ 20 *  i 1+ 20 * - dup 2/ wchoose				flammer-after-note @ 60 add: flammer-after-shape			LOOP		ENDOF	ENDCASE	\ scale the durations	flammer-after-shape 1 scale.flammer.durations	\ now set velocities	f-a-archetype 	CASE	\ gaussian amplitudes		0 OF			f-#-notes-after @ 0 			DO				\ psuedo-gaussian random number				128 choose 128 choose 128 choose + + 3 / 				scale.after.loudness				i 2 ed.to: flammer-after-shape			LOOP		ENDOF		\ ascending velocities	1 OF		f-#-notes-after @ 0 		DO			\ ascending			i 1+ 128 f-#-notes-after @ / * dup 2/ wchoose			scale.after.loudness			i 2 ed.to: flammer-after-shape		LOOP	ENDOF	2 OF		f-#-notes-after @ 0 		DO			\ descending			128 128 f-#-notes-after @ / 1 * -		    dup 2/ wchoose			scale.after.loudness			i 2 ed.to: flammer-after-shape		LOOP	ENDOF	ENDCASE;: COMPUTE.T-JOB.LOUDNESS { loudness -- new-loudness }	loudness	loudness 4 5 */	wchoose;: FLAMMER-JOB.FUNCTION { job -- }	100 choose flammer-prob @ < 	 IF		f-before @ 		IF			compute.before.flammer			\ the before player has a delay the duration minus the before span			job get.duration: [] 			f-before-span @ 2/ 			job get.duration: [] 100 */			- 			put.start.delay: flammer-before-player			start: flammer-before-player		THEN	THEN	100 choose flammer-prob @ < 	IF			f-after @ 		IF			compute.after.flammer			0 0 ed.at: flammer-after-shape			dup . 			put.start.delay: flammer-after-player			start: flammer-after-player		THEN	THEN;: TRACKER-JOB.FUNCTION { job -- }	piece-running? @ true = 	IF		\ first do all of job stuff		\ first put new duration adjusted by deviation 		t-job-pulse @ 		dup t-job-deviation @ choose		100 */ 		1 choose 0= IF + ELSE - THEN		job put.duration: []		drum_channel midi-channel !		t-job-note-1 @ 		t-job-loudness @ compute.t-job.loudness 		midi.noteon		t-job-note-2 @ 		t-job-loudness @ compute.t-job.loudness 		midi.noteon		display.time	THEN	divider-on? @ 	100 choose divider-prob @ <	and	IF		start: divider-job	THEN;: INIT.TRACKER-JOB	2 new: tracker-job	'c tracker-job.function add: tracker-job	'c flammer-job.function add: tracker-job;: CG-TRACKER-JOB.START.FUNCTION 	tracker-job start: [];: CG-TRACKER-JOB.STOP.FUNCTION 	tracker-job stop: []	divider-job stop: []	;: CG-TRACKER.JOB.FUNCTION { val part -- }	part 0=	IF		cg-tracker-job.start.function	THEN	part 1 = 	IF		cg-tracker-job.stop.function	THEN	display.time;: BUILD.CG-TRACKER-JOB	2 1  new: CG-TRACKER-job	350 300 put.wh: CG-TRACKER-JOB	9 put.text.size: cg-tracker-job	" Pulse " put.title: cg-tracker-job	stuff{ " START " " STOP " }stuff.text: CG-TRACKER-JOB	false 0 put.value: CG-TRACKER-job	'c cg-tracker.job.function put.down.function: CG-TRACKER-job;: CG-TRACKER.JOB.PARAMS.FUNCTION { val part -- }	part 0 = 	IF		val t-job-pulse !	THEN	part 1 = 	IF		val t-job-note-1 !	THEN	part 2 = 	IF		val t-job-note-2 !	THEN	part 3 = 	IF		val t-job-deviation !	THEN	part 4 = 	IF		val  t-job-loudness !	THEN	part 5 = 	IF		val  divider-prob !	THEN	part 6 = 	IF		val  divider-loudness !	THEN	part 7 = 	IF		val  divider-number !	THEN;: BUILD.CG-TRACKER-JOB-PARAMS 	1 8 new: CG-TRACKER-JOB-PARAMS	250 250 put.wh: CG-TRACKER-JOB-PARAMS	9 put.text.size: CG-TRACKER-JOB-PARAMS	'c cg-tracker.job.params.function put.down.function: cg-tracker-job-params	" Pulse " put.title: CG-TRACKER-JOB-PARAMS	20 0 put.min:  CG-TRACKER-JOB-PARAMS	1 1 put.min:  CG-TRACKER-JOB-PARAMS	1 2 put.min:  CG-TRACKER-JOB-PARAMS	1 3 put.min:  CG-TRACKER-JOB-PARAMS	0 4 put.min:  CG-TRACKER-JOB-PARAMS	0 5 put.min:  CG-TRACKER-JOB-PARAMS		20 6 put.min:  CG-TRACKER-JOB-PARAMS	2 7 put.min:  CG-TRACKER-JOB-PARAMS		\		1000 0 put.max:  CG-TRACKER-JOB-PARAMS	128 1 put.max:  CG-TRACKER-JOB-PARAMS	128 2 put.max:  CG-TRACKER-JOB-PARAMS	100 3 put.max:  CG-TRACKER-JOB-PARAMS	128 4 put.max:  CG-TRACKER-JOB-PARAMS	100 5 put.max:  CG-TRACKER-JOB-PARAMS	128 6 put.max:  CG-TRACKER-JOB-PARAMS		20 7 put.max:  CG-TRACKER-JOB-PARAMS			t-job-pulse @ 0 put.value: cg-tracker-job-params	t-job-note-1 @ 1 put.value: cg-tracker-job-params	t-job-note-2 @ 2 put.value: cg-tracker-job-params	t-job-deviation @ 3 put.value: cg-tracker-job-params	t-job-loudness @ 4 put.value: cg-tracker-job-params	divider-prob @ 5 put.value: cg-tracker-job-params	divider-loudness @ 6 put.value: cg-tracker-job-params	divider-number @ 7 put.value: cg-tracker-job-params		stuff{ " pulse " " note-1 " " note-2 " " dev. " " loud. "	" div-prob " " div-loud " " div-# "	 }stuff.text: cg-tracker-job-params;: TERM.TRACKER-JOB	free: tracker-job;