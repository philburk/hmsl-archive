\ drum-followanew task-tracker_drum-followob.job drum-follow-jobv: drum-follow-job-counterv: drum-follow-job-lengthv: drum-follow-notev: drum-follow-loudness: DRUM-FOLLOW-JOB.START.FUNCTION { job -- }	0 drum-follow-job-counter !	76 30 wchoose job put.data: []	rtc.rate@ 4 / rtc.rate@ 30 / wchoose	job	put.duration: []	drum-follow-#-repeats @ choose drum-follow-job-length !;: DRUM-FOLLOW-JOB.FUNCTION { job -- }	\ gradual decrescendo for each note	drum_channel midi.channel!	job get.data: []	drum-follow-loudness @ dup \ max max	drum-follow-job-length @ / \ max inc	drum-follow-job-counter @ * - \ max - inc*count = velocity	midi.noteon	1 drum-follow-job-counter +!	drum-follow-job-counter @ drum-follow-job-length @ >	IF		job stop: []	ELSE		rtc.rate@ 4 / rtc.rate@ 30 / wchoose		job	put.duration: []	THEN		;: INIT.DRUM-FOLLOW-JOB	1 new: DRUM-FOLLOW-JOB	'c DRUM-FOLLOW-JOB.function add: DRUM-FOLLOW-JOB	'c DRUM-FOLLOW-JOB.start.function put.start.function: DRUM-FOLLOW-JOB	;: MIDI->DRUM-FOLLOW { note vel -- }	note drum-follow-note !	vel drum-follow-loudness !	\ put the function in here, using threshold	vel drum-follow-threshold @ >	IF		drum_channel midi.channel!		drum-follow-job get.data: [] vel midi.noteon		hex 4000 decimal		note 54 - \ 0-22, trumpet range		/ midi.bend		start: drum-follow-job	THEN;\ when on, fill midi parser with it: CG-DRUM-FOLLOW-ON.FUNCTION	true drum-follow-on? !	'c midi->drum-follow mp-on-vector !	midi.parser.on;: CG-DRUM-FOLLOW-OFF.FUNCTION	false drum-follow-on? !	mp.reset;\ grid has range, #-notes, #-repeats, threshold : CG-DRUM-FOLLOW.FUNCTION { val part -- }	val true =	IF		CG-DRUM-FOLLOW-ON.FUNCTION	ELSE		CG-DRUM-FOLLOW-OFF.FUNCTION	THEN ;: BUILD.CG-DRUM-FOLLOW	1 1 new: CG-DRUM-FOLLOW	400 375 put.wh: CG-DRUM-FOLLOW	9 put.text.size: CG-DRUM-FOLLOW	'c CG-DRUM-FOLLOW.FUNCTION  put.down.function: CG-DRUM-FOLLOW	stuff{ " d-f-on? " }stuff.text: CG-DRUM-FOLLOW	" drum follow " put.title: CG-DRUM-FOLLOW;: CG-DRUM-FOLLOW-PARAMS-FUNCTION { val part -- }	part CASE		0 OF val drum-follow-#-notes  ! ENDOF		1 OF val drum-follow-#-notes ! ENDOF		2 OF val drum-follow-threshold ! ENDOF	ENDCASE;	: BUILD.CG-DRUM-FOLLOW-PARAMS	1 3 new: CG-DRUM-FOLLOW-PARAMS	250 300 put.wh: CG-DRUM-FOLLOW-PARAMS	9 put.text.size: CG-DRUM-FOLLOW-PARAMS	'c CG-DRUM-FOLLOW-PARAMS-FUNCTION put.down.function: CG-DRUM-FOLLOW-PARAMS	" D-f-params " put.title: CG-DRUM-FOLLOW-PARAMS	0 0 put.min:   CG-DRUM-FOLLOW-PARAMS	0 1 put.min:   CG-DRUM-FOLLOW-PARAMS	20 2 put.min:  CG-DRUM-FOLLOW-PARAMS\		8 0 put.max:  CG-DRUM-FOLLOW-PARAMS	10 1 put.max:  CG-DRUM-FOLLOW-PARAMS	128 2 put.max: CG-DRUM-FOLLOW-PARAMS\	drum-follow-#-notes @ 0 put.value: CG-DRUM-FOLLOW-PARAMS	drum-follow-#-repeats @ 1 put.value: CG-DRUM-FOLLOW-PARAMS	drum-follow-threshold @ 2 put.value: CG-DRUM-FOLLOW-PARAMS\		stuff{ " #-notes " " #-repeats " " v-threshold " 	}stuff.text: CG-DRUM-FOLLOW-PARAMS;: INIT.DRUM-FOLLOW	init.drum-follow-job;