\ compute least common multipleanew task-lcm: FIND.LCM { factora factorb | product lcm --  lcm }	factora factorb *	-> product	product -> lcm	product  	factora factorb max	DO		i factora mod 0=		i factorb mod 0= and		IF			\ i .			i -> lcm			LEAVE		THEN	LOOP	lcm	;\ ****************************\ find prime factors of a numberob.array primes-arrayob.array #-factors7 k: #_primes: INIT.PRIMES	#_primes new: primes-array	#_primes new: #-factors	stuff{  2 3 5 7 11 13 17 }stuff: primes-array	stuff{  0 0 0 0 0   0  0 }stuff: #-factors;v: divides?false divides? !: FIND.PRIME.FACTORS { test-number |  curr-prime modulus  dividend -- } 	false divides? !	init.primes	#_primes 0 DO		i at: primes-array -> curr-prime		test-number	curr-prime /mod 		-> dividend 		-> modulus 		BEGIN			test-number	curr-prime /mod 			-> dividend 			-> modulus 			modulus 0=			IF				true divides? !				i at: #-factors 				1+ i to: #-factors				dividend -> test-number				ELSE				false divides? !			THEN			?terminal 			divides? @ not			or		UNTIL		LOOP\	print: #-factors;: FIND.#-FACTORS { test-number -- number of total factors }	test-number find.prime.factors	0	#_primes 0 DO		i at: #-factors		+	LOOP;\ the gs of a number is the sum of the primes * their exponents \ minus one less than the number of factors...\ the gs of a number not having any of these prime factors will be 1\ by the nature of the gs function, which is floored at 1\ i.e gs (35) = 5 + 7 - (2-1) = 11: GS { test-number | iv-#-factors gs-sum -- euler gs function }	test-number find.prime.factors	0	#_primes 0 DO		i at: #-factors		i at: primes-array		* 		+	LOOP	-> gs-sum	\ gs-sum .	test-number find.#-factors -> iv-#-factors	\ iv-#-factors .	gs-sum iv-#-factors 1- -;\ finds the gs of a ratio, which is the gs of the lcm: GS.RATIO { num denom -- gs }	num denom find.lcm	gs;		