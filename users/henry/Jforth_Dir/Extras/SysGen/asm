\ 00001 25-sep-91 mdh     fixed TYPE13 & TYPE8 size warnings, SIZEM for LEA
\ 00002 01-jun-92 mdh     fixed ;CODE (added [compile])

ANEW TASK-ASM

max-inline @   6 max-inline ! 
(  68K forth style ASSEMBLER  )
FORTH DEFINITIONS

.NEED ASSEMBLER
   VOCABULARY ASSEMBLER
.THEN 
SEARCH-CURRENT ON
ALSO FORTH
ASSEMBLER DEFINITIONS

\ variable #REL
\ variable REL-SIZE

INCLUDE? RESOLVE-RELS jf:ASM.REF

ASSEMBLER DEFINITIONS

variable #REGISTERS
variable REGISTER-PENDING
variable JUST-REPORT

FORTH DEFINITIONS
: @REG  ( -- , set so that the name can be executed without registering )
  [ also assembler ]  just-report on  [ previous ]  ;

ASSEMBLER DEFINITIONS

\ these 5 words support printing of the Forward-ASM error message...

variable ASMFBLK
variable ASMLINENUM
variable ASMFNAME
variable LINETEXT 80 allot

: FASM.WHERE  ( -- )
  ASMFBLK @
  IF
     >newline cr  ." Line " ASMLINENUM @ .   FILEHEADERS @
     IF
        ." of file " ascii " emit
        ASMFNAME @    \ dup 10 dump 
        dup 5 +  swap c@  ( -- nfa+5 nfac@ )
        $ 1f and 4 - type   ascii " emit
     THEN
     cr cr
     LINETEXT count type cr
  THEN
;




: GET-REG   ( pfa -- regv )  @
  Just-Report @  0=
  IF   1 #REGISTERS +!  TRUE REGISTER-PENDING !
  THEN Just-Report OFF  ;

HEX
: AREG  CREATE ( reg#---)  ,       DOES>  ( <pfa> -- areg )  GET-REG ;

: DREG  CREATE ( reg#---)  10 OR , DOES>  ( <pfa> -- dreg )  GET-REG ;

HEX
0 CONSTANT DN-CODE
8 CONSTANT AN-CODE
10 CONSTANT A@-CODE
18 CONSTANT A@+-CODE
20 CONSTANT -A@-CODE
28 CONSTANT AN+W-CODE
30 CONSTANT AN+R+B-CODE
38 CONSTANT ABS.W@-CODE
39 CONSTANT ABS.L@-CODE
3A CONSTANT PC+W-CODE
3B CONSTANT PC+R+B-CODE
3C CONSTANT #-CODE

HEX
variable SIZE
variable SIZE-SET?

variable QUICK   ( for move default to moveq )

variable Size1   variable Size2

: SET-SIZE  ( SIZE-CODE---)
     SIZE  !  SIZE-SET? ON
;


 0 CONSTANT BYTE-SIZE
40  CONSTANT WORD-SIZE  ( 1 6 ROTATE-LEFT )
80 CONSTANT LONG-SIZE  ( 10 6 ROTATE-LEFT  )

: BYTE BYTE-SIZE SET-SIZE  ;

: WORD WORD-SIZE SET-SIZE  ;

: LONG LONG-SIZE SET-SIZE  ;

( 68K   OP-MODE CODES  )
0           CONSTANT <EA>DN->DN-CODE
0 8 SET-BIT CONSTANT DN<EA>-><EA>-CODE

DECIMAL
variable FATAL?
: FATAL   FATAL? @ IF    [ FORTH ] FORTH DEFINITIONS QUIT
                   THEN     ;

: ACR  cr  ( >newline )  ;

\ : WHERE  aCR  ; 

: WHERE
  ASMFBLK @
  IF
     FASM.WHERE
  ELSE
     WHERE
  THEN
  ?pause
;


   5 ARRAY SOURCE-ARRAY
   5 ARRAY DESTINATION-ARRAY

variable SOURCE-STATE
variable DESTINATION-STATE

: INIT-ASM ( --- )
     Just-Report off
     0          #REGISTERS           !
     0          REGISTER-PENDING     !
     LONG-SIZE  SIZE                 !
     0          SIZE-SET?            !
     0          QUICK                !
     0          SOURCE-STATE         !
     0          DESTINATION-STATE    !
     0 0 0 0 0  0 SOURCE-ARRAY      5 X!
     0 0 0 0 0  0 DESTINATION-ARRAY 5 X!   ;

also assembler

: <ERROR>   acr HERE COUNT SAFETYPE  ."  ? ASSEMBLER error"
  CLINESTART @  CPREVSTART @  CLINENUM @
  WHERE  ( ONLY FORTH DEFINITIONS )
  CLINENUM !  CPREVSTART !  CLINESTART !  ;

: starterr  >newline ." ----------------" cr ;

: ERROR  ( MSG#-- )  
  starterr DROP  INIT-ASM   <ERROR>  ;

: $ERROR  ( $ -- )
  starterr  $type cr INIT-ASM   <ERROR>  ;

: "ILLEGAL 
  starterr $type   ."  ILLEGAL: " cr <ERROR> ;

previous

: HAVE-SOURCE? ( --F )  SOURCE-STATE @ ;
: HAVE-DESTINATION? ( --F )  DESTINATION-STATE @ ;

: HAVE-SOURCE    1 SOURCE-STATE ! ;
: HAVE-DESTINATION 1 DESTINATION-STATE ! ;

: CLR-SOURCE   0 SOURCE-STATE !  0 SOURCE-ARRAY 10 0 FILL ;
: CLR-DESTINATION 0 DESTINATION-STATE !
   0 DESTINATION-ARRAY 10 0 FILL ;

: GET-SOURCE-EA      ( --EA ) 0 SOURCE-ARRAY      @ ;
: GET-DESTINATION-EA ( --EA ) 0 DESTINATION-ARRAY @ ;

: ADDRESS-ARRAY ( N ARRAY-OFFSET---)  HAVE-SOURCE?
      IF   DESTINATION-ARRAY
      ELSE  SOURCE-ARRAY
      THEN  ;

: ADDRESS-ARRAY!  ( N ARRAY-OFFSET --- )  ADDRESS-ARRAY ! ;

: ADDRESS-ARRAY@  ( ARRAY-OFFSET --- WORD )  ADDRESS-ARRAY @ ;

BINARY
: GET-MODE  ( 0-ARRAY-@ -- *-CODE )
        DUP 111000 AND 111000 =
          IF   111111 AND
          ELSE 111000 AND
          THEN     ;

: GET-SOURCE-MODE   ( -- *-CODE )
     GET-SOURCE-EA GET-MODE ;

: GET-DESTINATION-MODE  ( -- *-CODE )
      GET-DESTINATION-EA GET-MODE ;

BINARY
: REGISTER#-ONLY  ( STRIP OFF MODE )    111  AND   ;
: GET-SOURCE-REGISTER ( --REG# )
         GET-SOURCE-EA   REGISTER#-ONLY  ;
: GET-DESTINATION-REGISTER  ( --REG# )
         GET-DESTINATION-EA   REGISTER#-ONLY  ;

DECIMAL  
: EXTENDED? ( MODE+REG---FLAG) ( IF BINARY 111XXX )
   [ BINARY ]   111000 AND   111000 = [ DECIMAL ] ;

: SWAP-SOURCE-DEST  ( SWAP SOURCE AND DESTINATION ARRAY VALUES )
       5 0 DO  I SOURCE-ARRAY @  I DESTINATION-ARRAY @
               I SOURCE-ARRAY !  I DESTINATION-ARRAY !
           LOOP  ;

: R+B-REGISTER-TYPE ( [EXT] ADDR---[EXT]' ADDR )
   DUP CELL+ @ [ HEX ] 10 AND  ( 0 ARRAY-ADDR MODE ---)
       IF  ( DREG )
       ELSE ( AREG )  SWAP [ DECIMAL ] 15 SET-BIT SWAP
       THEN       ;

: R+B-REGISTER  ( [EXT] ADDR---[EXT]' ADDR )
    DUP CELL+ @ [ BINARY ] 111 AND [ DECIMAL ] 12 +SHIFT
    ( [EXT] ARRAY-ADDR REG-BITS---)  ROT OR SWAP   ;

: R+B-OFFSET  ( [EXT] ADDR---[EXT]' ADDR )  [ HEX ]
 DUP >R   2 CELLS +  @ 00FF AND ( OFFSET ) OR  R>  ; DECIMAL

: R+B-SIZE  ( [EXT] ARRAY-ADDR --- [EXT]' ADDR )
      DUP 4 CELLS + @  DUP -1 =
      IF    DROP  LONG-SIZE  ( SIZE @ )
      THEN
  CASE  ( [EXT] ADDR MODE-SIZE --- )
   BYTE-SIZE   OF  " BYTE +R+B EXTENTION"  "ILLEGAL  ENDOF
   WORD-SIZE   OF                                       ENDOF
   LONG-SIZE   OF SWAP [ DECIMAL ] 11 SET-BIT  SWAP     ENDOF
      drop " R+B-SIZE: SIZE" "ILLEGAL
  ENDCASE        ;

: DO-R+B  ( ARRAY-ADDR---)   0 ( INIT [EXT] )  SWAP
  ( [EXT] ARRAY-ADDR---)
  R+B-REGISTER-TYPE
  R+B-REGISTER
  R+B-SIZE
  R+B-OFFSET
  DROP    W,(T)   ;

: DO-#   ( ARRAY-ADDR---)  SIZE @
  CASE
      BYTE-SIZE   OF  CELL+ @  [ HEX ] 0FF AND  ABSOLUTE ENDOF
      WORD-SIZE   OF  CELL+ @   ABSOLUTE                 ENDOF
      LONG-SIZE   OF (  DUP 2 CELLS + @ W,<T> )
                     CELL+ @ D-ABSOLUTE                  ENDOF
        DROP " DO-#: SIZE"  "ILLEGAL  
  ENDCASE  ;

BINARY
: ADD-EXTENDED-[EXT]  ( ARRAY-ADDR---)  DUP @   111111 AND
   CASE
      ABS.W@-CODE  OF   CELL+ @ ABSOLUTE     ENDOF
      ABS.L@-CODE  OF  CELL+ @ D-ABSOLUTE    ENDOF
      PC+W-CODE    OF  CELL+   @ W,(T)       ENDOF
      PC+R+B-CODE  OF  DO-R+B                ENDOF
      #-CODE       OF  DO-#                  ENDOF
       DROP  " MODE REQUIRING EXTENSION" "ILLEGAL 
   ENDCASE   ;

: ADD-REGULAR-[EXT]  ( ARRAY-ADDR---)  DUP @ 111000 AND
   CASE
      AN+W-CODE    OF  CELL+ @  W,(T)    ENDOF
      AN+R+B-CODE  OF  DO-R+B            ENDOF
     DROP  ( IF NOT [EXT] AT ALL )
   ENDCASE         ; 

BINARY
: ADD-[EXT]  ( ARRAY-ADDR---)  DUP @   EXTENDED?
   IF    ADD-EXTENDED-[EXT]
   ELSE  ADD-REGULAR-[EXT]
   THEN ;

DECIMAL
: [EXT]  ( ---) ( ADD EXTENTIONS IF ANY )
   0 SOURCE-ARRAY        ADD-[EXT]
   0 DESTINATION-ARRAY   ADD-[EXT]    ;


: A-FINIS  [EXT]  INIT-ASM  ;

variable ASMWasQuit
variable ASMWasHeadTail

: CLEANUPASSEM  ( -- , cause module to get hidden )
  only forth
[ EXISTS? ASSEM .IF ]
    ' ASSEM  (hidemod)
[ .THEN ]
   ASMWasHeadTail @ HeadTail !
   asmwasquit @ dup is quit  execute
;

FORTH DEFINITIONS

: <RES-CODE> ( --- ) ( name --in-- )    ?EXEC   (CREATE) 
   ALSO ASSEMBLER   !CSP  [  ASSEMBLER ] #rel off INIT-ASM
   HeadTail @ ASMWasHeadTail !
   HeadTail off
   what's quit ASMWasQuit !
      " CLEANUPASSEM" find
   IF   is quit
   ELSE
       " <RES-CODE>: Dictionary Error" [ also forth ] $error [ previous ]
   THEN
   -1 dpl !  ( fix in case 1,2,3 # used which don't set dpl )
;

EXISTS? ASSEM .IF
  : CODE  <RES-CODE>  ;
.THEN

: <RES-;CODE>  ( --- )  ?CSP  !CSP
   ALSO ASSEMBLER      [ ASSEMBLER ] INIT-ASM
   [] [  ; IMMEDIATE

EXISTS? ASSEM .IF
  : ;CODE  [compile] <RES-;CODE>  ;  IMMEDIATE   \ 00002
.THEN


ASSEMBLER DEFINITIONS
: <RES-END-CODE>   (  --- )  RESOLVE-RELS  ?EXEC \ UNSMUDGE
  PREVIOUS    INIT-ASM  CSP @ SP@ CELL+ - \ -DUP
  IF
     \ acr " CODE stack error while assembling " LATEST  ID.
     \ ASCII , EMIT   SPACE   CELL/ . ." cell(s) " .S
       " Stack error while assembling "  pad $move
       LATEST c@ $ 1f and  LATEST 1+ swap  pad $append  pad  $error
  ELSE
     here 2- w@ $ 4e75 =
     IF   -2 dp +!
     THEN  ( FixHash; )  1 state !  [compile] ;
  THEN
  ASMWasHeadTail @ HeadTail !
  ASMWasQuit @ is quit
;

FORTH DEFINITIONS

EXISTS? ASSEM .IF
  : END-CODE  [ ASSEMBLER ]  <RES-END-CODE>  ;
.THEN


.NEED ASSEM
: RESIDENT-ASM  ( --- )   [  ASSEMBLER ]
 
  '  <RES-BYTE-RELATIVE>     IS    BYTE-RELATIVE    
  '  <RES-WORD-RELATIVE>     IS    WORD-RELATIVE    
  '  <RES-ABSOLUTE>          IS    ABSOLUTE         
  '  <RES-D-ABSOLUTE>        IS    D-ABSOLUTE       
  '  <RES-W,(T)>             IS    W,(T)            
  '  <RES-MARK>              IS    MARK             
  '  <RES-CODE>              IS    CODE             
  '  <RES-;CODE>             IS    ;CODE            
  '  <RES-END-CODE>          IS    END-CODE

;
.ELSE

: RESIDENT-ASM ;

.THEN

RESIDENT-ASM


ASSEMBLER DEFINITIONS
DECIMAL
here   variable MASKS  masks !   ( ADDRESS OF CURRENT MASK PFA )
: CREATE-MASK   ( OFFSET --- offset' ) 
      CREATE DUP ,  CELL+
      DOES>  ( ---ADDRESS )     @ MASKS @ +  ;

0 ( START OF MASKS )
CREATE-MASK OPCODEM
CREATE-MASK SIZEM
CREATE-MASK SOURCEM
CREATE-MASK DESTINATIONM
CREATE-MASK EXCEPTIONM
   CONSTANT MASK-SPACE  ( USE UP OFFSET FOR SIZE )

: ALLOT-SPACE  HERE MASKS !   MASK-SPACE CELL/   0
       DO  0 ,    LOOP  ;

DECIMAL
: OPCODE,  ( OPCODE--)  OPCODEM ! ;

: SIZEM,   ( SIZEM--)   SIZEM ! ;

: SOURCEM, ( SOURCEM--) SOURCEM ! ;

: DESTM,   ( DESTM--)   DESTINATIONM ! ;

: EXC,  ( EXCEPTIONM---)  EXCEPTIONM !  ;

: CHECK-SIZE  ( XXX-SIZE MASK---)
        AND NOT IF  ( NOT ALLOWED )   SIZE @
  CASE BYTE-SIZE OF " BYTE "   ENDOF
       WORD-SIZE OF " WORD "   ENDOF
       LONG-SIZE OF " LONG "   ENDOF
               " CHECK-SIZE: SIZE"
  ENDCASE  "ILLEGAL  THEN ;

: SIZE? ( --- ) SIZEM @  ( GET SIZE ) SIZE @
  CASE  ( SIZEM SIZE--) [ BINARY ]
           BYTE-SIZE OF  100  CHECK-SIZE  ENDOF
           WORD-SIZE OF  010  CHECK-SIZE  ENDOF
           LONG-SIZE OF  001  CHECK-SIZE  ENDOF
    " SIZE?: SIZE" "ILLEGAL
  ENDCASE   ;   

BINARY
: PRINT-SIZE-FROM-BIT  ( SIZE-BIT--)
        CASE  100 OF ." BYTE "  ENDOF
              010 OF ." WORD "  ENDOF
              001 OF ." LONG "  ENDOF  
        ENDCASE  ;

: SIZEM->SIZE  ( sizem -- size )
  CASE  [ BINARY ]
       100  OF  BYTE-SIZE   ENDOF
       010  OF  WORD-SIZE   ENDOF
       001  OF  LONG-SIZE   ENDOF
    " SIZEM->SIZE: SIZE" "ILLEGAL  0 swap
  ENDCASE 
;

: SIZE->SIZEM  ( ??-size -- sizem )
  CASE  ( SIZE--) [ BINARY ]
       BYTE-SIZE OF  100  ENDOF
       WORD-SIZE OF  010  ENDOF
       LONG-SIZE OF  001  ENDOF
    " SIZE->SIZEM: SIZE" "ILLEGAL  0 swap
  ENDCASE 
;

: SIZE-OK?  ( SIZE-BIT---) SIZEM @ SWAP  OVER AND NOT
  IF  ( NOT OK ) acr   SIZE @
       CASE BYTE-SIZE OF ." BYTE "   ENDOF
            WORD-SIZE OF ." WORD "   ENDOF
            LONG-SIZE OF ." LONG "   ENDOF
       ENDCASE ." IGNORED, " PRINT-SIZE-FROM-BIT ." USED: "  TYPE-HERE acr
  ELSE drop
  THEN   ;

BINARY
: SIZE-WARNING? ( --- ) SIZE-SET? @ 
  IF ( CHECK MASK ) ( SIZEM @ -- removed mdh 02/02/86 )
     ( GET SIZE ) SIZE @
      CASE  ( SIZEM SIZE--) [ BINARY ]
           BYTE-SIZE OF  100  SIZE-OK?  ENDOF
           WORD-SIZE OF  010  SIZE-OK?  ENDOF
           LONG-SIZE OF  001  SIZE-OK?  ENDOF
        " SIZE-WARNING?: SIZE" "ILLEGAL
      ENDCASE 
  THEN   ;   

: ENFORCE-MY-SIZE  ( -- )
  size-set? @
  IF
     size @ size->sizem size-ok?
  THEN
  sizem @ sizem->size size !
;

.NEED BIT-CLR?
 : BIT-CLR?  ( N #BIT --- FLAG ) BIT-SET? NOT ;
.THEN 

DECIMAL
: CHECK-REGULAR-MODES  ( MODE-MASK MODE---)  [ HEX ] 38 AND [ DECIMAL ]  
 CASE
     DN-CODE   OF 11 BIT-CLR? IF " DN"     "ILLEGAL THEN ENDOF
     AN-CODE   OF 10 BIT-CLR? IF " AN"     "ILLEGAL THEN ENDOF
     A@-CODE   OF 9  BIT-CLR? IF " A@"     "ILLEGAL THEN ENDOF
    A@+-CODE   OF 8  BIT-CLR? IF " A@+"    "ILLEGAL THEN ENDOF
    -A@-CODE   OF 7  BIT-CLR? IF " -A@"    "ILLEGAL THEN ENDOF
   AN+W-CODE   OF 6  BIT-CLR? IF " AN+W"   "ILLEGAL THEN ENDOF
   AN+R+B-CODE OF 5  BIT-CLR? IF " AN+R+B" "ILLEGAL THEN ENDOF
        " MODE" "ILLEGAL 
 ENDCASE      ;

DECIMAL
: CHECK-EXTENDED-MODES  ( MODE-MASK MODE---)   63 AND  
  CASE
    ABS.W@-CODE OF 4 BIT-CLR? IF " ABS.W@"  "ILLEGAL THEN ENDOF
    ABS.L@-CODE OF 3 BIT-CLR? IF " ABS.L@"  "ILLEGAL THEN ENDOF
    PC+W-CODE   OF 2 BIT-CLR? IF " PC+W"    "ILLEGAL THEN ENDOF
    PC+R+B-CODE OF 1 BIT-CLR? IF " PC+R+B"  "ILLEGAL THEN ENDOF
    #-CODE      OF 0 BIT-CLR? IF " #"       "ILLEGAL THEN ENDOF
       " MODE" "ILLEGAL 
  ENDCASE   ;   

: CHECK-ADDRESS-MODE  ( MODE-MASK MODE---)  DUP 56 AND  ABS.W@-CODE = 
    IF   CHECK-EXTENDED-MODES
    ELSE CHECK-REGULAR-MODES
    THEN  ;

: SOURCE? ( --- ) SOURCEM @ GET-SOURCE-EA
          CHECK-ADDRESS-MODE  ;

: DESTINATION? ( --- )  DESTINATIONM @ GET-DESTINATION-EA
          CHECK-ADDRESS-MODE  ;

: SOURCE-NOT-DN-OK?  ( --- )
     EXCEPTIONM @  1 BIT-SET?
        IF " SOURCE OTHER THAN DN " "ILLEGAL   THEN  ;

: DEST-NOT-DN-OK?  ( --- )
     EXCEPTIONM @  0 BIT-SET?
        IF " DESTINATION OTHER THAN DN " "ILLEGAL THEN  ;

FALSE .IF
  68k assembler  explaination of masks: 
  sizem, compiles size mask in binary a mask is  3 bits. 
  byte,word,long, sourcem, compiles source mask in 12 bits binary 
  the bits are as the modes are listed in the motorola 68000 user's manual  
  destm,  is as sourcem, for the destination mask 
.THEN

BINARY
: ?AN/BYTE/SOURCE  ( --- ) ( ERROR IF BYTE AND AN )
    SIZE @ BYTE-SIZE =
     IF      GET-SOURCE-MODE   AN-CODE =
             IF " SOURCE AN WITH BYTE" "ILLEGAL  THEN
     THEN  ;

: ?AN/BYTE/DESTINATION  ( --- )
  SIZE @ BYTE-SIZE =
  IF    GET-DESTINATION-MODE   AN-CODE =
        IF    " DESTINATION AN WITH BYTE" "ILLEGAL  THEN
  THEN    ;

DECIMAL
: ?AN/BYTE  ( --- )   EXCEPTIONM @
       DUP 2 BIT-SET?
       IF    ?AN/BYTE/SOURCE  DROP
       ELSE    4 BIT-SET?
               IF     ?AN/BYTE/DESTINATION
               THEN
       THEN           ;

BINARY
: TYPE1   CREATE  ALLOT-SPACE  OPCODE,
          DOES>      @ W,(T)  INIT-ASM         ;

: TYPE2   CREATE  ALLOT-SPACE   OPCODE,  010 SIZEM,  1 SOURCEM,
          DOES>    MASKS !  WORD-SIZE SIZE !  SIZE-WARNING?  SOURCE?
                   OPCODEM @ W,(T) 0 SOURCE-ARRAY DO-#
                   INIT-ASM  ;

: TYPE3  CREATE  ALLOT-SPACE  OPCODE,  100 SIZEM, 1 SOURCEM,
         DOES>    MASKS !   BYTE-SIZE SIZE !  SIZE-WARNING?   SOURCE?
                  OPCODEM @ W,(T) 0 SOURCE-ARRAY DO-#
                  INIT-ASM     ;

: TYPE4 ( SIZEM SOURCEM OPCODE-- )
        CREATE   ALLOT-SPACE   OPCODE,  101111111000 SOURCEM,
                      111 SIZEM,
         DOES>   MASKS !    SIZE?    SOURCE?  OPCODEM @
                  SIZE @ OR GET-SOURCE-EA OR  W,(T)  A-FINIS ;

: TYPE5 ( SIZEM SOURCEM OPCODE-- )
  CREATE   ALLOT-SPACE  OPCODE,  101111111000 DESTM,  1 SOURCEM,
                111 SIZEM,
   DOES>    MASKS ! SIZE? DESTINATION? SOURCE? OPCODEM @
            SIZE @ OR GET-DESTINATION-EA OR  W,(T)   A-FINIS  ;

DECIMAL
: ALT/MOVE/SIZE   ( SIZE-MASK---ALT/MOVE-SIZE-MASK  )
 CASE
     BYTE-SIZE  OF  [ BINARY 1 DECIMAL 12 +SHIFT  ] LITERAL  ENDOF
     WORD-SIZE  OF  [ BINARY 11 DECIMAL 12 +SHIFT ] LITERAL  ENDOF
     LONG-SIZE  OF  [ BINARY 10 DECIMAL 12 +SHIFT ] LITERAL  ENDOF
 ENDCASE    ;

: TO-MOVE/DESTINATION   ( SOURCE<EA>---DESTINATION<EA> )
    DUP [ BINARY ]  111    [ DECIMAL ] AND 9 +SHIFT
   SWAP [ BINARY ]  111000 [ DECIMAL ] AND 3 +SHIFT OR  ;

BINARY
: TYPE7-AN  ( OPCODE--OPCODE' )  SIZE @
    CASE    WORD-SIZE   OF   011000000    ENDOF
            LONG-SIZE   OF   111000000    ENDOF
            " BYTE WITH AN DESTINATION" "ILLEGAL
    ENDCASE    OR    ;

HEX
: EOR-OR-CMP   ( --OPCODE )   SOURCEM @  7FF AND
  [ BINARY ]   IF   1100
               ELSE 1010
               THEN   ;
DECIMAL
: CONVERT-OPCODE ( OPCODE--OPCODE' )
      12 -SHIFT  [ BINARY ]
      CASE  1000 ( OR  )  OF  0000  ENDOF
            1001 ( SUB )  OF  0100  ENDOF
            1100 ( AND )  OF  0010  ENDOF
            1101 ( ADD )  OF  0110  ENDOF
            1011 ( ??? )  OF  EOR-OR-CMP  ENDOF
       " TYPE7-#, NON-CONVERTABLE OPCODE: "  $ERROR 
      ENDCASE    [ DECIMAL ]   8 +SHIFT    ;

BINARY
: TYPE7-#   ( OPCODE--OPCODE' )
        DROP
        101111111000  GET-DESTINATION-EA  CHECK-ADDRESS-MODE
        OPCODEM @ CONVERT-OPCODE
        GET-DESTINATION-EA   OR
        SIZE @ OR    ;

DECIMAL 
: TYPE7-SRC-DN   ( TRUE-IF-SRC-DN --- )
            DESTINATION?  0=   ( DEST-NOT-DN? )
            EXCEPTIONM @ 1 BIT-SET?  ( IS IT EOR? )   OR
            IF DN<EA>-><EA>-CODE OR
               SWAP-SOURCE-DEST
            THEN      ;

: TYPE7-OP-MODE  ( OPCODE --- OPCODE+OPMODE F  )
  GET-DESTINATION-MODE AN-CODE = EXCEPTIONM @ 3 BIT-SET? AND
  IF TYPE7-AN
  ELSE GET-DESTINATION-MODE DN-CODE = GET-SOURCE-MODE DN-CODE =
     2DUP 0= IF SOURCE-NOT-DN-OK? THEN
          0= IF DEST-NOT-DN-OK? THEN
        IF TYPE7-SRC-DN
        ELSE IF <EA>DN->DN-CODE OR
             ELSE  " <EA>,DN <EA>,AN #,<EA> ONLY: "  $ERROR
             THEN
        THEN
     SIZE @ OR
  THEN    ;

DECIMAL
: TYPE7 ( EXC DESTM SOURCEM OPCODE-- )
        CREATE   ALLOT-SPACE
                  OPCODE,  SOURCEM,  DESTM,  EXC,
         DOES>   MASKS !  OPCODEM @
             GET-SOURCE-MODE #-CODE =
             GET-DESTINATION-MODE AN-CODE = NOT  AND
               IF TYPE7-#
               ELSE   TYPE7-OP-MODE
                  GET-SOURCE-EA   OR
                  GET-DESTINATION-REGISTER
                  9 +SHIFT  OR   ?AN/BYTE
               THEN   W,(T) A-FINIS   ;

DECIMAL
: TYPE8 ( SOURCEM DESTM SIZEM OPCODE-- )
  CREATE
     ALLOT-SPACE
     OPCODE,  SIZEM,  DESTM,  SOURCEM,
  DOES>
     MASKS !  ENFORCE-MY-SIZE
     SOURCE?  DESTINATION?  OPCODEM @
     GET-SOURCE-EA   OR
     GET-DESTINATION-REGISTER
     9 +SHIFT  OR  W,(T)   A-FINIS   ;

BINARY       (  <DATA> #   <EA>   <SIZE>   <FUNCT>Q     )
: TYPE9 ( SIZEM SOURCEM OPCODE-- )
   CREATE   ALLOT-SPACE
             OPCODE,  SIZEM,  DESTM,   1 SOURCEM,
    DOES>    MASKS ! SIZE? SOURCE? DESTINATION? OPCODEM @
             SIZE @ OR GET-DESTINATION-EA OR
             1 SOURCE-ARRAY @
             111 AND [ DECIMAL ] 9 +SHIFT OR
             ?AN/BYTE/SOURCE   W,(T) CLR-SOURCE  A-FINIS  ;

DECIMAL
: ALT/SIZE  ( SIZE-MASK---ALT-SIZE-MASK )
     CASE
    BYTE-SIZE  OF  0                 ENDOF
    WORD-SIZE  OF  [  BINARY 10 DECIMAL 6 +SHIFT ]
                      LITERAL        ENDOF
    LONG-SIZE  OF  [ BINARY 11 DECIMAL 6 +SHIFT ]
                      LITERAL        ENDOF
      ENDCASE  ;

: ALT/SIZE?  ( SIZE---SIZE1 )  ( ALT/SIZE IF EXC MASK SET )
   EXCEPTIONM @  3 BIT-CLR?
     IF
     ELSE  ALT/SIZE
     THEN   ;

\ TYPE10: SWAP UNLK  EXT  MOVE-FROM-USP  MOVE-TO-USP 
: TYPE10    ( EXC SOURCEM SIZEM OPCODE---)
        CREATE   ALLOT-SPACE  OPCODE,  SIZEM, SOURCEM,
        DOES>   MASKS !   SOURCE?  SIZE-WARNING?
                OPCODEM @   GET-SOURCE-REGISTER  OR
                W,(T) A-FINIS   ;

: TYPE10.5    (  SOURCEM SIZEM OPCODE---)
        CREATE   ALLOT-SPACE  OPCODE,  SIZEM, SOURCEM,
        DOES>   MASKS !   SOURCE?  SIZE?
                OPCODEM @  SIZE @   ALT/SIZE  OR
                GET-SOURCE-REGISTER  OR
                W,(T) A-FINIS   ;

\  TYPE11:    JMP JSR TAS PEA NBCD MOVE-TO-'S 
DECIMAL
: TYPE11 ( SIZEM SOURCEM OPCODE-- )
        CREATE   ALLOT-SPACE
                  OPCODE,  SIZEM,  SOURCEM,
         DOES>    MASKS ! SOURCE?  SIZE-WARNING?  OPCODEM @
                  GET-SOURCE-EA   OR  W,(T)
                  A-FINIS   ;

DECIMAL
: DO-EXG/OPMODE   ( OPCODE---OPCODE' )
       GET-SOURCE-MODE  GET-DESTINATION-MODE
       DN-CODE = abs  SWAP DN-CODE = abs 2*   OR
[ BINARY ] CASE ( <SOURCE-DN?-FLAG*2--OR--DESTINATION-DN?> --)
11 OF [ BINARY 01000 HEX 3 +SHIFT BINARY ] LITERAL  ENDOF
00 OF [ BINARY 01001 HEX 3 +SHIFT BINARY ] LITERAL  ENDOF
01 OF [ BINARY 10001 HEX 3 +SHIFT BINARY ] LITERAL  ENDOF
10 OF SWAP-SOURCE-DEST
      [ BINARY 10001 HEX 3 +SHIFT BINARY ] LITERAL  ENDOF
         ENDCASE   OR  ;
HEX
: DO-RX-RY  ( OPCODE---OPCODE' )
  GET-SOURCE-REGISTER      OR
  GET-DESTINATION-REGISTER  9 +SHIFT OR  ;

\ TYPE12:  EXG
BINARY
: TYPE12
        CREATE   ALLOT-SPACE
      110000000000 SOURCEM,  110000000000 DESTM,
      001 SIZEM,  1100000100000000  OPCODE,
         DOES>  MASKS !  SOURCE? DESTINATION?  SIZE-WARNING?
                OPCODEM @
                DO-EXG/OPMODE  DO-RX-RY  W,(T)  A-FINIS ;
BINARY
: DO-#SHIFT ( ---OPCODE' )    DESTINATION?
         1 SOURCE-ARRAY @ 111 AND [ DECIMAL ]   9 +SHIFT ;
DECIMAL
: DO-DN-SHIFT ( ---OPCODE' )  GET-SOURCE-REGISTER  9 +SHIFT
   5 SET-BIT ;

: DO-NON-<EA>  ( ---OPCODE )  GET-SOURCE-MODE  #-CODE =
    IF    DO-#SHIFT
    ELSE  DO-DN-SHIFT
    THEN  OPCODEM @
    [ BINARY 111011 DECIMAL 6 +SHIFT -1 XOR ] LITERAL AND
    OR  SIZE @ OR   GET-DESTINATION-REGISTER OR
   CLR-SOURCE  CLR-DESTINATION   ;

( TYPE13:  SHIFT ROTATE  )
BINARY
: TYPE13
  CREATE ( OPCODE -) ALLOT-SPACE  OPCODE,  010 SIZEM,
  001111111000 SOURCEM,  100000000000 DESTM,
  DOES>   ( <PFA> --- ) MASKS  !
  GET-SOURCE-MODE  DUP #-CODE = SWAP DN-CODE = OR NOT
  IF
     ( SIZE? - removed 00001 )  size @ size->sizem size-ok?
     SOURCE?  OPCODEM @  111000 -1 XOR AND
     GET-SOURCE-EA OR
  ELSE
     DO-NON-<EA>
  THEN  W,(T)   A-FINIS  ;

\ DX DY ---
\ #  DY ---
\ <ea>  ---  ( once )

( TYPE14:   EXTENDED  )
BINARY
: TYPE14 
    CREATE  ( dest-mask opcode --- )  ALLOT-SPACE  OPCODE,
           100010000000  DUP SOURCEM,  DESTM,  [ DECIMAL ]  
     DOES>  MASKS !   SOURCE?  DESTINATION? OPCODEM @
            GET-SOURCE-MODE  DN-CODE =
            IF    GET-DESTINATION-MODE  DN-CODE = NOT
                  IF     " NOT DN" "ILLEGAL
                  THEN
            ELSE  GET-DESTINATION-MODE  -A@-CODE = NOT
                  IF     " BOTH NOT -A@"  "ILLEGAL
                  THEN  3 SET-BIT
            THEN  GET-SOURCE-REGISTER OR
            GET-DESTINATION-REGISTER 9 +SHIFT OR
            SIZE @ OR  W,(T)  A-FINIS  ;

( TYPE15:  SBCD  ABCD  )
BINARY 
( NOTE THIS IS ALMOST IDENTICAL TO TYPE14 )
: TYPE15  
    CREATE     ALLOT-SPACE  OPCODE, 100 SIZEM,
           100010000000  DUP SOURCEM,  DESTM,  [ DECIMAL ] 
     DOES>  MASKS !   SOURCE?  DESTINATION? SIZE?
           OPCODEM @  GET-SOURCE-MODE  DN-CODE =
           IF    GET-DESTINATION-MODE  DN-CODE = NOT
                 IF " NOT DN" "ILLEGAL
                 THEN
          ELSE  GET-DESTINATION-MODE  -A@-CODE = NOT
                IF " BOTH NOT -A@"  "ILLEGAL
                THEN  3 SET-BIT
           THEN  GET-SOURCE-REGISTER OR
           GET-DESTINATION-REGISTER 9 +SHIFT OR  W,(T)  A-FINIS  ;

BINARY
: MOVEP  000000100001000 ( OPCODEM ) [ DECIMAL ]
  GET-SOURCE-MODE  DN-CODE =
         IF acr   GET-DESTINATION-MODE  AN+W-CODE = NOT
               IF    " NOT AN+W"  "ILLEGAL  THEN
              7 SET-BIT  GET-DESTINATION-REGISTER OR
              GET-SOURCE-REGISTER  9 +SHIFT  OR
         ELSE  GET-SOURCE-MODE AN+W-CODE = NOT
                IF  " NOT AN+W OR DN"  "ILLEGAL  THEN
               GET-DESTINATION-MODE  DN-CODE = NOT
               IF   " NOT DN"  "ILLEGAL  THEN
               GET-DESTINATION-REGISTER  OR
         THEN  SIZE @ CASE
               LONG-SIZE  OF  6 SET-BIT  ENDOF
               WORD-SIZE  OF  ENDOF  " BYTE" "ILLEGAL ENDCASE
               W,(T)  A-FINIS   ;  DECIMAL

BINARY
: TRAP  ( VECTOR# --- )   GET-SOURCE-MODE  #-CODE = NOT
        IF  " NOT IMMEDIATE"  "ILLEGAL
        THEN  1 SOURCE-ARRAY @  1111 AND
        0100111001000000  OR  W,(T)
        CLR-SOURCE  CLR-DESTINATION  A-FINIS  ;

BINARY
: CMPM   GET-SOURCE-MODE  A@+-CODE =
   GET-DESTINATION-MODE  A@+-CODE = AND NOT
    IF     " NOT A@+"  "ILLEGAL
    THEN   1011000100001000  ( OPCODEM )  [ DECIMAL ]
   GET-SOURCE-REGISTER OR   SIZE @ OR
   GET-DESTINATION-REGISTER  9 +SHIFT OR W,(T) A-FINIS ;

BINARY
: MOVEQ  ( SIZE-WARNING? ) LONG-SIZE SIZE !
        GET-DESTINATION-MODE  DN-CODE =  NOT
        IF      " NOT DN"  "ILLEGAL
        THEN  GET-SOURCE-MODE  #-CODE = NOT
        IF      " NOT IMMEDIATE" "ILLEGAL
        THEN  0111000000000000  ( OPCODEM )  [ DECIMAL ]
        GET-DESTINATION-REGISTER 9 +SHIFT OR
        1 SOURCE-ARRAY @ [ HEX ] 0FF AND   OR   W,(T)
        CLR-SOURCE  A-FINIS  ;

( TYPE6:   MOVE  )
DECIMAL     ( USED BY MOVE ONLY...WILL REVERT TO MOVEQ )
: TYPE6   ( SOURCEM DESTM --- )
   CREATE  ALLOT-SPACE  DESTM, SOURCEM, 0 OPCODE,
   DOES>  GET-SOURCE-MODE #-CODE =
    GET-DESTINATION-MODE DN-CODE =   [ FORTH ] AND [ ASSEMBLER ]
    1 SOURCE-ARRAY @ ABS 128 <       [ FORTH ] AND [ ASSEMBLER ]
    2 SOURCE-ARRAY @ 0=              [ FORTH ] AND [ ASSEMBLER ]
    QUICK @ 0= 0=    [ FORTH ] AND [ ASSEMBLER ]   TRUE QUICK !
    IF    DROP MOVEQ
    ELSE  MASKS !   SOURCE?  DESTINATION?
          OPCODEM @   SIZE @ ALT/MOVE/SIZE OR
          GET-SOURCE-EA OR
          GET-DESTINATION-EA  TO-MOVE/DESTINATION OR
          ?AN/BYTE/SOURCE   ?AN/BYTE/DESTINATION  W,(T) A-FINIS
    THEN    ;  

BINARY
: LINK    GET-SOURCE-MODE  AN-CODE = NOT
  IF
         " NOT AN"  "ILLEGAL
  THEN
  GET-DESTINATION-MODE  #-CODE = NOT
  IF
       " NOT IMMEDIATE"  "ILLEGAL
  THEN
  WORD-SIZE SIZE !   ( mdh force word size for offset w,<t> )
  0100111001010000 ( OPCODEM ) GET-SOURCE-REGISTER OR W,(T) A-FINIS  ;

BINARY
: DO-#-BIT  ( ---OPCODE )
    0000,1000,0000,0000  GET-DESTINATION-EA OR
                      OPCODEM             @ OR        ;

: DO-DN-BIT  ( ---OPCODE )
    000,00001,0000,0000  GET-DESTINATION-EA OR  [ DECIMAL ]
       GET-SOURCE-REGISTER  9 +SHIFT   OR
                    OPCODEM              @  OR         ;

DECIMAL
: DN/LONG-ELSE-BYTE  ( -- ) SIZE @
      GET-DESTINATION-MODE DN-CODE =
      IF    LONG-SIZE = NOT
            IF     " LONG ONLY; OTHERS" "ILLEGAL
            THEN
      ELSE  BYTE-SIZE = NOT
            IF      " BYTE ONLY; OTHERS" "ILLEGAL
            THEN
      THEN  ;

( TYPE16:  BIT  )
BINARY
: TYPE16  ( DESTM OPCODE ---  )
    CREATE   ALLOT-SPACE
       OPCODE,   100000000001 SOURCEM,   DESTM,   101 SIZEM,
    DOES> MASKS ! SOURCE?  SIZE?
       GET-SOURCE-MODE  #-CODE =
       IF    DO-#-BIT  DN/LONG-ELSE-BYTE  W,(T)  ( OPCODE )
             1 SOURCE-ARRAY @ W,(T)      ( BIT#  )
       ELSE  DO-DN-BIT  DN/LONG-ELSE-BYTE W,(T)
       THEN  ( A-FINIS -- mdh 01/24/87 -- )
             0 DESTINATION-ARRAY   ADD-[EXT]   INIT-ASM  ;

( TYPE17:  BRANCHES )
BINARY
: TYPE17  
    CREATE  ALLOT-SPACE [ DECIMAL ]
          ( condition-code )  8 +SHIFT  [ BINARY ]
          0110000000000000   OR  OPCODE,  110 SIZEM,
    DOES>  MASKS !  ( displacment---) (  size-warning?  )
          SIZE @  LONG-SIZE =  
          IF   WORD-SIZE  SIZE !
          THEN HAVE-SOURCE? 
          IF      " ALL MODES"  "ILLEGAL 
          THEN  [ DECIMAL ]  OPCODEM @  W,(T)
          SIZE @ BYTE-SIZE =
          IF    BYTE-RELATIVE
          ELSE  WORD-RELATIVE
          THEN     A-FINIS  ;

( TYPE17.25:  BRANCHES )
BINARY
: TYPE17.25  
    CREATE  ALLOT-SPACE [ DECIMAL ]
          ( condition-code )  8 +SHIFT  [ BINARY ]
          0110,0001,0000,0000   OR  OPCODE,  110 SIZEM,
    DOES>  MASKS !  ( displacment---) (  size-warning?  )
          SIZE @  BYTE-SIZE = 
          IF   ." BSR only support WORD branches" cr
          THEN
          WORD-SIZE  SIZE ! 
\          SIZE @  LONG-SIZE = 
\          IF   WORD-SIZE  SIZE ! 
\          THEN
          HAVE-SOURCE? 
          IF     " ALL MODES"  "ILLEGAL  \ quit 
          THEN
          [ DECIMAL ]
\          SIZE @ BYTE-SIZE =
\          IF    BYTE-RELATIVE
\          ELSE  WORD-RELATIVE
\          THEN     A-FINIS
     here 2+ - 
    dup abs $ 7FFF >
    IF " BSR attemped over 32K" $error
    ELSE   OPCODEM @  W,(T)   w,(t)
    THEN  A-FINIS
;

( TYPE17.5  DBCC ETC... )
BINARY   ( <DN> <LABEL> WORD DB<XX>  )
: TYPE17.5  
    CREATE  ALLOT-SPACE [ DECIMAL ]
          ( CONDITION-CODE )  8 +SHIFT  [ BINARY ]
          0101000011001000  OR  OPCODE,  010 SIZEM,
          100000000000 SOURCEM,  ( DN ONLY )
    DOES>  MASKS !  ( DISPLACMENT---)
          SIZE-WARNING?
          WORD-SIZE  SIZE ! 
          SOURCE?
          OPCODEM @  GET-SOURCE-REGISTER OR   W,(T)
          WORD-RELATIVE    A-FINIS    ;

( TYPE18  SET-BY-CONDITION )
BINARY
: TYPE18  
    CREATE  ALLOT-SPACE [ DECIMAL ]
          ( CONDITION-CODE )  8 +SHIFT  [ BINARY ]
          0101000011000000  OR  OPCODE,  100 SIZEM,
          101111111000  SOURCEM,
    DOES>  MASKS !  SIZE?   SOURCE?
          OPCODEM @  GET-SOURCE-EA OR  W,(T)  A-FINIS  ;

HEX
: DATA-REG?  ( REG+BIT--REG F) DUP 10 AND SWAP 07 AND SWAP ;

: REG-MASK   ( REG1 REG2...REGN--MASK )
   #REGISTERS  @
     IF     0   #REGISTERS @  0
            DO    ( REGS...MASK---)  SWAP  DATA-REG?
                  IF     SET-BIT
                  ELSE   8 +  SET-BIT
                 THEN
            LOOP
     ELSE   0
     THEN   ; 

DECIMAL
: -REG-MASK  ( REG1 REG2...REGN--MASK )
         0 #REGISTERS @ -DUP
      IF 0  DO SWAP DATA-REG? NOT
               IF 7 SWAP -
               ELSE 15 SWAP -
               THEN SET-BIT
            LOOP
      THEN  ;

DECIMAL
: HANDLE-MOVEM-DIRECTION  ( OPCODE---OPCODE' )
      REGISTER-PENDING  @
               IF    ( RAM TO REG )  SOURCE?  10 SET-BIT
               ELSE  ( REG TO RAM )  SWAP-SOURCE-DEST
                     DESTINATION?    SWAP-SOURCE-DEST
               THEN
      GET-SOURCE-MODE  -A@-CODE =  REGISTER-PENDING @ AND
                IF  " RAM TO REG WITH -A@" "ILLEGAL THEN
      GET-SOURCE-MODE  A@+-CODE = REGISTER-PENDING @ NOT AND
                IF  " REG TO RAM WITH A@+" "ILLEGAL  THEN  ;

BINARY
: MOVEM-TYPE  
    CREATE  ALLOT-SPACE  011 SIZEM,
            0100100010000000 OPCODE,
            001011111000 DESTM,  ( REGISTER TO RAM )
            001101111110 SOURCEM, ( RAM TO REGISTER )  [ DECIMAL ] 
    DOES>   MASKS !  SIZE?   OPCODEM @
            GET-SOURCE-EA OR   SIZE @ LONG-SIZE =
            IF    6 SET-BIT 
            THEN  HANDLE-MOVEM-DIRECTION  W,(T)
               GET-SOURCE-MODE -A@-CODE =
            IF    -REG-MASK  
            ELSE   REG-MASK 
            THEN   W,(T)    A-FINIS    ; 

DECIMAL
MOVEM-TYPE  MOVEM  ( A@+ : MEM->REG : DR0->DR7,A0->A7.  )
                   ( -A@ : REG->MEM : A7->A0,D7->D0.    )
                  ( ELSE : MEM+     : D0->D7,A0->A7.    )

: ADDRESSES?   HAVE-SOURCE?   HAVE-DESTINATION?  AND
          IF   " TOO MANY MODES; "  $ERROR THEN ;
HEX
: DATA?   ( N1---N1 ) DUP 10 AND 
      IF    " MUST BE AN ADDRESS REG: " $ERROR 
      THEN ;

: ADDRESS? ( N1---N2 )  ( STRIPS DN MARK TOO ) DUP 10 AND  NOT 
    IF     " MUST BE A DATA REG: " $ERROR
    THEN  7 AND ;

BINARY
: ->DESTINATION  ( MODE/REG---REG/MOD/000000 )
      DUP 111 AND   [ DECIMAL ]  3 +SHIFT  SWAP
    [ BINARY ] 111000 AND [ DECIMAL ] 3 -SHIFT
    OR  6 +SHIFT  ;

DECIMAL
: MODE ( MODE-#REG---) HAVE-SOURCE? 
    IF    0 DESTINATION-ARRAY !   HAVE-DESTINATION
    ELSE  0 SOURCE-ARRAY ! HAVE-SOURCE 
    THEN ;

: ADDR-MODE ( REG# MODE---) SWAP DATA? ADDRESSES? OR MODE ;

: FROM-#REGISTERS  ( N-- ) #REGISTERS +!
       FALSE REGISTER-PENDING !  ;

: DN ( REG#---) ADDRESS? DN-CODE OR MODE -1 FROM-#REGISTERS ;

: AN ( REG#--- )  AN-CODE  ADDR-MODE -1 FROM-#REGISTERS ;

: A@ ( REG#---)   A@-CODE  ADDR-MODE -1 FROM-#REGISTERS ;

: A@+ ( REG#---)  A@+-CODE ADDR-MODE -1 FROM-#REGISTERS ;

: -A@  ( REG#---) -A@-CODE ADDR-MODE -1 FROM-#REGISTERS ;

: AN+W  ( AREG N---) 1 ADDRESS-ARRAY! AN+W-CODE ADDR-MODE
        -1 FROM-#REGISTERS  ;

: MODE-SIZE  ( --- )  ( SETS SIZE FOR MODE )  SIZE-SET?  @
     IF     SIZE @   FALSE SIZE-SET? !  LONG-SIZE SIZE !
     ELSE   -1   ( FLAG FOR USE DEFAULT SIZE )
     THEN   4 ADDRESS-ARRAY !               ;

: AN+R+B  ( AREG REG BYTE---) 2 ADDRESS-ARRAY! 1 ADDRESS-ARRAY!
          MODE-SIZE  AN+R+B-CODE ADDR-MODE -2 FROM-#REGISTERS  ;

 ASSEMBLER  DEFINITIONS
: MAKE-DOUBLE  ( N-OR-D --- D )  DPL @ -1 =
    IF   0    THEN   -1 DPL !    ;

: ABS.W  ( N---) 1 ADDRESS-ARRAY!  ABS.W@-CODE  MODE
                 0 FROM-#REGISTERS  ;

: ABS.L  ( N.LSW N.MSW---) MAKE-DOUBLE  2 ADDRESS-ARRAY!
  1 ADDRESS-ARRAY!    ABS.L@-CODE MODE  0 FROM-#REGISTERS  ;

: PC+W  ( W ---)  1 ADDRESS-ARRAY!  PC+W-CODE MODE
     ( -1 FROM-#REGISTERS )  ;

: PC+R+B  ( REG BYTE---) 2 ADDRESS-ARRAY!  1 ADDRESS-ARRAY!
    MODE-SIZE   PC+R+B-CODE  MODE -1 FROM-#REGISTERS  ;

: #  ( N-OR-D---) MAKE-DOUBLE
  2 ADDRESS-ARRAY!   1 ADDRESS-ARRAY!   #-CODE MODE       ;

HEX
4E77 TYPE1 RTR
4E76 TYPE1 TRAPV
4E75 TYPE1 RTS
4E73 TYPE1 RTE
4E70 TYPE1 RESET
4E71 TYPE1 NOP
 ( 4AFC TYPE1 ILLEGAL  )

4E72 TYPE2 STOP
027C TYPE2 ANDI-SR
0A7C TYPE2 EORI-SR
007C TYPE2 ORI-SR

023C TYPE3 ANDI-CCR
0A3C TYPE3 EORI-CCR
003C TYPE3 ORI-CCR

   4200 TYPE4 CLR
   4400 TYPE4 NEG
   4600 TYPE4 NOT
   4A00 TYPE4 TST
   4000 TYPE4 NEGX

(  USE:  N1 ADDRESSING-MODE SIZE TYPE5-WORD )
   0C00 TYPE5 CMPI
   0000 TYPE5 ORI
   0200 TYPE5 ANDI
   0400 TYPE5 SUBI
   0600 TYPE5 ADDI
   0A00 TYPE5 EORI


BINARY
( SOURCEM   DESTM  )
111111111111 111111111000 TYPE6 MOVE

BINARY
( EXC  DESTM       SOURCEM       OPCODE   )
00000 101111111111 001111111000 1100000000000000 TYPE7 AND
00000 101111111111 001111111000 1000000000000000 TYPE7 OR
01000 111111111111 001111111000 1001000000000000 TYPE7 SUB
11010 010000000000 111111111111 1001000000000000 TYPE7 SUBA
01000 111111111111 001111111000 1101000000000000 TYPE7 ADD
11010 010000000000 111111111111 1101000000000000 TYPE7 ADDA
00010 101111111000 100000000000 1011000000000000 TYPE7 EOR
01101 110000000000 111111111111 1011000000000000 TYPE7 CMP
( EXCEPTIONS:   AN/BYTE/SOURCE   SRC-IS-DN!    DEST-IS-DN! )
(        BIT:   2                1             0             )
(               AN/BYTE/DESTINATION                          )
(        BIT:   3                                            )

BINARY
( SOURCEM       DESTM      SIZEM    OPCODE )
101111111111  100000000000  010  HEX C1C0 TYPE8 MULS   BINARY
101111111111  100000000000  010  HEX C0C0 TYPE8 MULU   BINARY
101111111111  100000000000  010  HEX 4180 TYPE8 CHK    BINARY
101111111111  100000000000  010  HEX 81C0 TYPE8 DIVS   BINARY
101111111111  100000000000  010  HEX 80C0 TYPE8 DIVU   BINARY
001001111110  010000000000  001  HEX 41C0 TYPE8 LEA    DECIMAL

BINARY
( DESTM      SIZEM  OPCODE  )
111111111000 111 0101000100000000 TYPE9 SUBQ
111111111000 111 0101000000000000 TYPE9 ADDQ


( SOURCEM       SIZEM  OPCODE         )
 100000000000  010 0100100001000000 TYPE10 SWAP
 010000000000  111 0100111001011000 TYPE10 UNLK
 010000000000  001 0100111001100000 TYPE10 MOVE-TO-USP
 010000000000  001 0100111001101000 TYPE10 MOVE-FROM-USP

( EXCEPTIONS:  ALT-SIZE  AN/BYTE/SOURCE  X   X   )
( SOURCEM       SIZEM  OPCODE         )
 100000000000  011 0100100000000000 TYPE10.5 EXT

( TYPE11  TYPE11.5  TYPE12    DEFINITIONS  )
BINARY
( SOURCEM       SIZEM     OPCODE    )
1011,1111,1111   010    HEX  46C0 BINARY TYPE11 MOVE-TO-SR
1011,1111,1000   010    HEX  44C0 BINARY TYPE11 MOVE-TO-CCR
1011,1111,1000   100    HEX  4AC0 BINARY TYPE11 TAS
1011,1111,1000   010    HEX  40C0 BINARY TYPE11 MOVE-FROM-SR
0010,0111,1110   001    HEX  48C0 BINARY TYPE11 PEA
0010,0111,1110   001    HEX  4EC0 BINARY TYPE11 JMP
0010,0111,1110   001    HEX  4E80 BINARY TYPE11 JSR
1011,1111,1000   100    HEX  4800 BINARY TYPE11 NBCD

TYPE12 EXG

BINARY
1110011011011000 TYPE13 ROR     ( E6D8 )
1110011111011000 TYPE13 ROL     ( E7D8 )
1110001011001000 TYPE13 LSR     ( E2C8 )
1110001111001000 TYPE13 LSL     ( E3C8 )
1110010011010000 TYPE13 ROXR    ( E4D0 )
1110010111010000 TYPE13 ROXL    ( E5D0 )
1110000011000000 TYPE13 ASR     ( E0C0 )
1110000111000000 TYPE13 ASL     ( E1C0 )

( OPCODE )
1101000100000000  TYPE14  ADDX
1001000100000000  TYPE14  SUBX

( OPCODEM  )
1100000100000000  TYPE15  ABCD
1000000100000000  TYPE15  SBCD

( DESTM       TYPE     CODE )
101111111000 01000000 TYPE16 BCHG
101111111000 10000000 TYPE16 BCLR
101111111000 11000000 TYPE16 BSET
101111111110 00000000 TYPE16 BTST

( CONDITION-CODE  )
0100 TYPE17 BCC    0011 TYPE17 BLS
0101 TYPE17 BCS    1101 TYPE17 BLT
0111 TYPE17 BEQ    1011 TYPE17 BMI
0110 TYPE17 BNE
1100 TYPE17 BGE    1010 TYPE17 BPL
1110 TYPE17 BGT    0000 TYPE17 BRA
0010 TYPE17 BHI    1000 TYPE17 BVC
1111 TYPE17 BLE    1001 TYPE17 BVS

0001 TYPE17.25  BSR

( CONDITION-CODE  )
0100 TYPE17.5 DBCC    0011 TYPE17.5 DBLS
0101 TYPE17.5 DBCS    1101 TYPE17.5 DBLT
0111 TYPE17.5 DBEQ    1011 TYPE17.5 DBMI
0110 TYPE17.5 DBNE    0001 TYPE17.5 DBF  0001 TYPE17.5 DBRA
1100 TYPE17.5 DBGE    1010 TYPE17.5 DBPL
1110 TYPE17.5 DBGT    0000 TYPE17.5 DBT
0010 TYPE17.5 DBHI    1000 TYPE17.5 DBVC
1111 TYPE17.5 DBLE    1001 TYPE17.5 DBVS
( OFFSET REG --- )

( TYPE18 DEFINITIONS SET-BY-CONDITION )
BINARY
( CONDITION-CODE  )
0100 TYPE18 SCC    0011 TYPE18 SLS
0101 TYPE18 SCS    1101 TYPE18 SLT
0111 TYPE18 SEQ    1011 TYPE18 SMI
0001 TYPE18 SF     0110 TYPE18 SNE
1100 TYPE18 SGE    1010 TYPE18 SPL
1110 TYPE18 SGT    0000 TYPE18 ST
0010 TYPE18 SHI    1000 TYPE18 SVC
1111 TYPE18 SLE    1001 TYPE18 SVS
DECIMAL


\ register definitions
0 AREG TEMP0         
0 AREG 0AR

1 AREG TEMP1
1 AREG 1AR

2 AREG LOC 
2 AREG 2AR

3 AREG +64k
3 AREG 3AR

4 AREG ORG
4 AREG 4AR

5 AREG UP
5 AREG 5AR

6 AREG DSP
6 AREG 6AR

7 AREG RP 
7 AREG 7AR

0 DREG 0DR             
1 DREG 1DR
2 DREG 2DR             
3 DREG 3DR
4 DREG 4DR  
           
5 DREG ILOOP
5 DREG 5DR

6 DREG JLOOP             
6 DREG 6DR

7 DREG TOS
7 DREG 7DR
only FORTH DEFINITIONS
max-inline !
