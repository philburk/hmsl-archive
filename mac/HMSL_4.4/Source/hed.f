\ Hierarchy Editor\\ Author: Phil Burk\ Copyright 1992 Phil Burk\ All Rights ReservedANEW TASK-HED.Fvariable		HED-CUR-MORPH	\ currently selected morphvariable 		HED-YBOT		\ bottom of outlinevariable		HED-YTOP\ Control GridsOB.MENU.GRID	HED-ADD			\ adds morphsOB.RADIO.GRID	HED-REC/PLAYOB.NUMERIC.GRID HED-DELAYSOB.MENU.GRID	HED-PATCHESOB.SCREEN		HED-SCREENOB.OBJLIST		HED-PARENTS		\ stack of parents above currentOB.LIST			HED-INDICES		\ indices within parentOB.COLLECTION	HED-TOP \ top of hierarchy: HED.GO.LEFT { | indx parent  -- , move current morph to the left }	many: hed-parents 1 >	IF		last: hed-indices -> indx		last: hed-parents -> parent		indx remove: parent		many: hed-parents 1- remove: hed-parents		many: hed-indices 1- remove: hed-indices\		last: hed-indices -> indx		last: hed-parents -> parent		hed-cur-morph @ indx insert: parent		indx add: hed-indices   \ update	THEN;: HED.GO.RIGHT { | indx parent newp -- , move current morph to the right }	last: hed-indices -> indx	last: hed-parents -> parent	indx 0>	IF		indx 1- get: parent -> newp \ morph immediately above		?hierarchical: newp  \ is it hierarchical		IF			indx remove: parent			hed-cur-morph @ many: newp insert: newp			many: newp 1- add: hed-indices			newp add: hed-parents		THEN	THEN;: HED.GO.UP { | indx parent  -- , move current morph up }	last: hed-indices -> indx	last: hed-parents -> parent	indx 0>	IF		indx remove: parent		hed-cur-morph @ indx 1- insert: parent		indx 1- many: hed-indices 1- put: hed-indices   \ update	ELSE\ go to next level		hed.go.left	THEN;: HED.GO.DOWN { | indx parent -- , move current morph down }	last: hed-indices -> indx	last: hed-parents -> parent	indx many: parent 1- <	IF		indx remove: parent		hed-cur-morph @ indx 1+ insert: parent		indx 1+ many: hed-indices 1- put: hed-indices   \ update	ELSE\ go to next level		hed.go.left	THEN;:CLASS OB.CONTROL.OUTLINE <SUPER OB.CONTROL: HED.X.EDGE  ( -- xpos , left edge indented )	hed-xleft @	hed-indent @ hed_indent_by * +;: HED.CUR.INDEX ( -- indx , in parent )	many: hed-indices 0>	IF		last: hed-indices	ELSE		0	THEN;: HED.DRAW.MORPH  { morph high? -- }	hed.x.edge	hed-ypos @	xy.draw: morph\\ Highlight?	high?	IF		hed.x.edge hed-ypos @		over mhed_name_x + over get.height: morph +		gr.highlight	THEN\	get.height: morph 2+ hed-ypos +!\	get.expanded: morph ?hierarchical: morph AND	IF		1 hed-indent +!		many: morph 0		DO			i get: morph\ should we highlight this one?			dup hed-cur-morph @ =			i hed.cur.index = AND			RECURSE			hed-ypos @ hed-ybot @ >			IF				LEAVE			THEN		LOOP		-1 hed-indent +!	THEN;:M DRAW: ( -- )	draw: super	0 gr.color!	-1 get.rect: self	gr.rect	1 gr.color!	-1 get.rect: self	ug.box\	0 hed-indent !	hed-ytop @ hed-ypos !	hed-top	dup hed-cur-morph @ = hed.draw.morph;M$ 17 constant shift_left_arrow$ 18 constant shift_right_arrow \ 00002$ 18 constant shift_up_arrow$ 1A constant shift_down_arrow$ 1C constant left_arrow$ 1D constant right_arrow$ 1E constant up_arrow$ 1F constant down_arrow: HACK.CONVERT.CHAR  ( char -- char' , MERGE THIS WITH HH:H4th_EVENTS )	dup left_arrow down_arrow within?	if		?shift		if			5 -		then	then;:M KEY: ( char -- , move morph within hierarchy )	hack.convert.char	many: hed-parents 0>  \ is it not top of hierarchy?	IF		CASE			left_arrow OF hed.go.left ENDOF			right_arrow OF hed.go.right ENDOF							up_arrow OF hed.go.up ENDOF			down_arrow OF hed.go.down ENDOF		ENDCASE		self draw: []	ELSE		drop	THEN;M;CLASSOB.CONTROL.OUTLINE	HED-OUTLINE		\ contains outline format: HED.SCAN.MORPH { xpos ypos morph | xoff yoff obj -- xoff yoff morph|0 }\ scan for Y hit, calculate ofsets in object	0 -> obj	0 -> xoff	0 -> yoff	ypos	hed-ypos @ dup get.height: morph +	within?	IF		xpos hed.x.edge - -> xoff		ypos hed-ypos @ - -> yoff		morph -> obj	ELSE\\ advance Y position		get.height: morph hed-ypos +!\\ scan children		get.expanded: morph ?hierarchical: morph AND		IF			1 hed-indent +!			many: morph 0			DO				morph add: hed-parents				i add: hed-indices				xpos ypos i get: morph RECURSE ?dup				IF					-> obj					-> yoff					-> xoff					LEAVE				ELSE					many: hed-parents 1- remove: hed-parents					many: hed-indices 1- remove: hed-indices					2drop				THEN				hed-ypos @ hed-ybot @ >				IF					LEAVE				THEN			LOOP			-1 hed-indent +!		THEN	THEN	xoff yoff obj;: HED.SELECT.MORPH { morph -- }	morph hed-cur-morph !	get.start.delay: morph 0 put.value: hed-delays	get.repeat.delay: morph 1 put.value: hed-delays	get.stop.delay: morph 2 put.value: hed-delays	draw: hed-delays;: HED.OUTLINE.DOWN { val part | xoff yoff obj -- , mouse down response }	0 hed-indent !	hed-ytop @ hed-ypos !	empty: hed-parents	empty: hed-indices	ev.getxy hed-top hed.scan.morph	-> obj	-> yoff	-> xoff	OBJ	IF		obj hed.select.morph		xoff yoff hit: obj\\ check to see if we are still active in case of modal screens %Q		cg-current-screen @ hed-screen =		IF			draw: hed-outline		THEN	THEN;: HED.BUILD.OUTLINE	'c hed.outline.down put.down.function: hed-outline;: HED.ADD.MORPH ( morph -- )	hed-cur-morph @ ?dup	IF		add: []		true hed-cur-morph @ put.expanded: []		draw: hed-outline	ELSE		drop	THEN;: (HED.ADD.DOWN) { part | obj -- }	0 -> obj	part	CASE		0 OF 'c ob.collection >body <?instantiate> dup -> obj			IF				ACT.PARALLEL: obj				32 new: obj			THEN		ENDOF		1 OF 'c ob.collection >body <?instantiate> dup -> obj			IF				ACT.SEQUENTIAL: obj				32 new: obj			THEN		ENDOF		2 OF 'c ob.shape >body <?instantiate> dup -> obj			IF				prefab: obj				48 put.offset: obj				8 choose 1+ put.channel: obj			THEN		ENDOF\[ exists? ob.patch .IF ]		3 OF " Patch" create.object -> obj." How do we UNMAKE this unit?" cr		ENDOF[ .THEN ]	ENDCASE\	obj ?dup	IF		hed.add.morph	ELSE		." Could not instantiate Morph!" cr	THEN;: HED.ADD.DOWN { val part -- }	part 4 =	IF		." Create an Alias!" cr		print: hed-parents		many: hed-parents 0>		IF			hed-cur-morph @			last: hed-indices			last: hed-parents insert: []			draw: hed-outline		THEN	ELSE		hed-cur-morph @ ?hierarchical: []		IF			part (hed.add.down)		THEN	THEN;: HED.BUILD.ADD ( - )	1 5 new: hed-add	'c hed.add.down put.down.function: hed-add	stuff{ " ParCol" " SeqCol" " Shape" " Patch" " Alias" }stuff.text: hed-add;: HED.DUMP.NAMES { morph -- }	dump.source.name: morph	?hierarchical: morph	IF		many: morph 0		DO			i get: morph recurse		LOOP	THEN;: HED.DUMP.BODIES { morph -- }cr." \ Initialize " name: morph cr	dump.source.body: morph	?hierarchical: morph	IF		many: morph 0		DO			i get: morph recurse		LOOP	THEN;: HED.DUMP.SOURCE ( -- )	" ram:hed.dump" $logto	cr	." \ Automatically generated by Hierarchy Editor" cr	cr	." ANEW TASK-PIECE" cr	cr	." \ Instantiate objects." cr	hed-top hed.dump.names	cr\\ Terminate	." : PIECE.TERM ( -- , cleanup everything )" cr	tab ." cleanup: hed-top" cr	." ;" cr	." if.forgotten piece.term" cr	cr\\ Initialize	." : PIECE.INIT ( -- , initialize morphs )" cr	tab ." piece.term" cr	hed-top hed.dump.bodies	>newline	." ;" cr	cr\\ Play	." : PIECE ( -- )" cr	tab ." piece.init" cr	tab ." hed-top ao.exec" cr  \ %Q use HMSL.PLAY	tab ." piece.term" cr	." ;" cr	cr	logend	." Source code dumped to RAM:HED.DUMP" cr;: HED.PLAY.DOWN ( value part -- )	nip	CASE		0 OF hed-cur-morph @ start: [] ENDOF		1 OF ENDOF		2 OF hed-cur-morph @ stop: [] ENDOF		3 OF hed.dump.source ENDOF	ENDCASE;: HED.BUILD.PLAY ( - )	1 4 new: hed-rec/play	'c hed.play.down put.down.function: hed-rec/play	stuff{ " Play" " Record" " Stop" " Dump"  }stuff.text: hed-rec/play;\ -------------------------------------------------------: HED.DELAY.UP  { val part | morph -- }	hed-cur-morph @ -> morph	part	CASE		0 OF val put.start.delay: morph ENDOF		1 OF val put.repeat.delay: morph ENDOF		2 OF val put.stop.delay: morph ENDOF	ENDCASE;\ TEXTROM HED-DEL-LABELS  ," Start" ," Repeat"  ," Stop": HED.BUILD.DELAYS ( - )	1 3 new: hed-delays	'c hed.delay.up put.up.function: hed-delays\    'c hed-del-labels put.text.function: hed-delays    0 -1 put.min: hed-delays    999 -1 put.max: hed-delays    " Delays" put.title: hed-delays;\ -------------------------------------------------------: HED.GET.FUNCTION { part | morph -- func }	hed-cur-morph @ -> morph	part	CASE		0 OF get.start.function: morph ENDOF		1 OF get.repeat.function: morph ENDOF		2 OF get.stop.function: morph ENDOF	ENDCASE;: HED.PUT.FUNCTION { func part | morph -- }	hed-cur-morph @ -> morph	part	CASE		0 OF func put.start.function: morph ENDOF		1 OF func put.repeat.function: morph ENDOF		2 OF func put.stop.function: morph ENDOF	ENDCASE;: HED.EDIT.PATCH { val part | -- }	part hed.get.function	0=	IF		" Patch" create.object		part hed.put.function	THEN\	part hed.get.function	dup ob.valid?	IF		edit.patch	ELSE		drop	THEN;: HED.BUILD.PATCHES ( - )	1 3 new: hed-patches	'c hed.edit.patch put.down.function: hed-patches	stuff{ " Start" " Repeat"  " Stop" }stuff.text: hed-patches    " Patches" put.title: hed-delays;\ -------------------------------------------------------	: HED.INIT	hed.build.outline	hed.build.add	hed.build.play	hed.build.delays	hed.build.patches		32 new: hed-top	32 new: hed-parents	32 new: hed-indices	hed-top hed-cur-morph !		10 3 new: hed-screen	hed-outline    -1  -1 add: hed-screen	hed-add       3000  200 add: hed-screen	hed-rec/play  3600  200 add: hed-screen	hed-patches   3000  2000 add: hed-screen	hed-delays    3600  2000 add: hed-screen	hed-screen default-screen !	" Hierarchy" put.title: hed-screen	ascii H put.key: hed-screen		2800 3600 put.wh: hed-outline	500 300 put.wh: hed-add	500 300 put.wh: hed-rec/play	500 300 put.wh: hed-patches	300 300 put.wh: hed-delays		120 300 put.xy: hed-outline	get.xy.dc: hed-outline	3 + hed-ytop !	3 + hed-xleft !	get.wh.dc: hed-outline	hed-ytop @ + hed-ybot !	drop." Horrible knudge for screen titles. remove after recompilation of HMSL!" cr	" Enter text!" put.title: popt-screen;: HED.TERM	deinstantiate.hierarchy: hed-top	freeall: hed-screen	free: hed-parents	free: hed-indices;: USER.INIT user.init hed.init ;: USER.TERM hed.term user.term ;if.forgotten hed.termtrue .IF: SC.TEST  ( screen -- )    dup draw: []    stack.mark    BEGIN        stack.check        sys.task        sc.check.event    UNTIL    undraw: [];.THENexists? HMSL .IF: HED\ ." ' us.use.patch is edit.patch" cr\ ' us.use.patch is edit.patch	hed.init	hmsl.open	hed-screen default-screen !	hmsl;.ELSE\ For low level testing: SYS.INIT  sys.init hed.init ;: SYS.TERM  hed.term sys.term ;: HED." ' us.use.patch is edit.patch" cr' us.use.patch is edit.patch	sys.init	gr.closecurw	gr.openhmsl	hed-screen sc.test	gr.closecurw;.THEN