\ Event Buffering\\ Simplified version of old event buffer.\ The old version used multiple levels of lists\ to avoid scanning long lists.  Unfortunately, this \ put more of a burden on the interrupt code when several levels\ cascaded down which caused timing glitches.\\ A second version put everything in one long list but\ then the foreground did a lot of list scanning which\ locked out the interrupt task.\\ The third version combines a circular buffer of linked lists\ that is hashed by time, with a long list for later nodes.\ The foreground doesn't have to lock out interrupts for\ the long list.  It can just set a flag to keep the\ interrupt from messing with it.  WHAT ABOUT ON AMIGAS! Need semaphore!\ The interrupt will pull from the long list as needed but\ has plenty of time so it can do it on whatever interrupt\ gets permission.\\ Nodes will be drawn from a pool of prelinked nodes.\\ Author: Phil Burk\ Copyright 1989 -  Phil Burk, Larry Polansky, David Rosenboom.\ All Rights Reserved\ Changed Permits and Forbids in EB.ADD.NODE\\ MOD: 7/91 Modified to work with Mac\ MOD: 9/5/91 Changes merged with Amiga style.\ MOD: 9/25/91 Removed : 2!\ 950816 PLB in EB.PROCESS.NODE, fill level after processing slot\        for better timing.  Increase num-nodes to 2048.\        Disable message in EB.ADD.NODES\ 950820 PLB New simplified single active list scheme.\ 960116 PLB Third scheme.decimalinclude? { ju:localsANEW TASK-EVENT_BUFFERexists? FORBID() not   host=amiga and .IF: FORBID() ( -- )    callvoid exec_lib forbid;: PERMIT() ( -- )    callvoid exec_lib permit;.THENhost=amiga .IF: DISABLE.CLOCK.INT ( -- sr )	forbid() true;: RESTORE.INTERRUPT ( sr -- )	drop permit();.THENhost=mac .IF: DISABLE.CLOCK.INT ( -- sr )	disable.via;: RESTORE.INTERRUPT ( sr -- )	restore.sr;.THEN\ Pool of linked list nodes to allocate from.-1 constant EB_ILLEGAL_CFA1 10 shift constant EB_NUM_SLOTSeb_num_slots 1- constant EB_SLOT_MASKvariable EB-NUM-NODES2048 eb-num-nodes !    ( this value can be increased )variable EB-POOL-PTRvariable EB-IN-EVBUF  \ use to prevent unexpected recursionvariable EB-LAST-TIME-PROCESSED  ( last time processed )variable EB-ERRORvariable EB-FREE-NODES     ( head for list of free nodes )variable EB-PENDING-NODES  ( head for list of pending active nodes )variable EB-NUM-POST-LOOPS ( used for performance statistics )variable EB-NUM-POSTS      ( used for performance statistics )variable EB-LAST-NODE-POSTED  ( start search from here )variable EB-RESERVE-LIST   ( set by foreground while using list )\ error codes1 constant EB_NO_CFA2 constant EB_BAD_NODE3 constant EB_NO_SLOT\ Define structure of a node.:STRUCT EBNode    rptr  eb_next   ( JForth relative address of next link )    long  eb_time   ( absolute time to execute event )    rptr  eb_cfa    ( cfa to call )    long  eb_data   ( data to pass );STRUCTsizeof() EBNode 16 -.IF ." EBNode should be 16 bytes for shifting!" abort.THEN:STRUCT EBSlot	rptr  ebs_first	rptr  ebs_last;STRUCTcreate EB-SLOTS  sizeof() EBSlot  eb_num_slots *  allot: EB.NTH.SLOT  ( n -- &ebslot )	sizeof() EBSlot  * eb-slots +;: EB.CLEAR.SLOTS	eb-slots  sizeof() EBSlot  eb_num_slots *   0 fill;\ Maintain a pool of event nodes.: EB.ALLOC.POOL ( num_nodes -- )    dup eb-num-nodes !    eb-pool-ptr @ 0=    IF sizeof() ebnode * mm.alloc       eb-pool-ptr !    ELSE drop    THEN;: EB.FREE.POOL ( -- )    eb-pool-ptr @ ?dup    IF mm.free eb-pool-ptr off    THEN;: EB.NODE  ( index -- node , index into allocated node array )    4 shift   \  ( instead of )   sizeof() EBNode *    eb-pool-ptr @ +;: EB.NEXT ( node -- next_node )    @ inline;: EB.LINK ( next_node node -- )    ! inline;: EB.LINK.AFTER { newnode oldnode | nextnode -- }	oldnode eb.next -> nextnode	newnode oldnode eb.link	nextnode newnode eb.link;: EB.ALLOC.NODE ( -- node | 0 , alloc a node from free pool )    eb-free-nodes eb.next dup    IF dup eb.next eb-free-nodes !   \ link free header to second node       0 over eb.link                \ remove head from free list    THEN;: EB.SETUP.NODE ( data cfa time node -- node )    dup>r ..! eb_time    r@ ..! eb_cfa    r@ ..! eb_data    r>;: EB.FREE.NODE  ( node -- , free by adding to free list )    eb-free-nodes eb.link.after;: EB.TIME>SLOT   ( time -- slot )	eb_slot_mask and  \ hash into slot array by time	eb.nth.slot;: EB.ADD.TO.SLOTS { node | slot -- }	node ..@ eb_time   eb.time>slot  dup -> slot	..@ ebs_last ?dup	IF		node swap eb.link	ELSE		node slot ..! ebs_first	THEN	node slot ..! ebs_last	0 node eb.link;: EB.CLEAR.POOL  ( -- , mark all nodes as free )    0 eb-free-nodes !    0 eb.node  eb-num-nodes @ sizeof() ebnode *  0 fill    eb-num-nodes @ 1-  0    DO  0 EB_ILLEGAL_CFA 0 i eb.node eb.setup.node        eb.free.node    LOOP    0 eb-pending-nodes !	0 eb-num-post-loops !	0 eb-num-posts !	0 eb-last-node-posted !;: EB.DUMP.NODE ( node -- , dump contents )    ." Time = " dup ..@ eb_time . cr    ." Data = " dup ..@ eb_data . cr    ." CFA  = " ..@ eb_cfa >name id. cr;: EB.DUMP.LIST ( list_header -- )    BEGIN @ dup    WHILE    	." -------" cr        dup eb.dump.node        ?pause    REPEAT    drop;: EB.DUMP.SLOTS  { | time slot -- }	." Slots +++++++++++++++" cr	eb_num_slots 0	DO		eb-last-time-processed @ i + -> time		time eb.time>slot -> slot		slot ..@ ebs_first		IF			." ================= Time = " time . cr			slot .. ebs_first eb.dump.list		THEN	LOOP;: EB.DUMP	cr	eb.dump.slots	." Pending list +++++++++++++" cr	eb-pending-nodes eb.dump.list;	\ background process ======================================: EB.EXEC.NODE { node1 -- }\ ." EB.EXEC.NODE " node1 . cr    eb-in-evbuf on    node1 ..@ eb_data    node1 ..@ eb_cfa ?dup    IF execute    ELSE drop eb_no_cfa eb-error ! \ . ." EB.EXEC.NODE - CFA = 0!" cr    THEN    EB_ILLEGAL_CFA node1 ..! eb_cfa   \ mark as having been processed    eb-in-evbuf off;: EB.PROCESS.SLOT { rtime | node1 node2 slot -- , execute nodes in slot }	rtime eb.time>slot -> slot	slot ..@ ebs_first -> node1	BEGIN    	node1      \ non NULL ?    WHILE		node1 eb.exec.node        node1 eb.next -> node2        node1 eb.free.node        node2 -> node1    REPEAT    0 slot ..! ebs_first    0 slot ..! ebs_last;: EB.MOVE.NODES.TO.SLOTS  { rtime | time_limit node1 node2 --  }	rtime eb_num_slots + -> time_limit    BEGIN    	eb-pending-nodes @ -> node1   \ get first node or NULL    	node1      \ non NULL ?    	IF			node1 ..@ eb_time time_limit time< \ is it time to move this node?		ELSE			false		THEN	    WHILE    	node1 eb.next -> node2		node1 eb.add.to.slots        node2 eb-pending-nodes !    REPEAT;: EB.PROCESS.PENDING  ( rtime -- )	dup eb.process.slot	eb-reserve-list @ 0=	IF		dup eb.move.nodes.to.slots	THEN	drop;variable EB-MAX-LATE: EB.TASK ( -- , called by tasker !!!!!!!!!!!!!!!!!!! )	BEGIN		rtc.time@ eb-last-time-processed @ time>	WHILE		eb-last-time-processed @ 1+		dup eb.process.pending		eb-last-time-processed !	REPEAT;\ foreground process ========================================: EB.POST.NODE { node1 startnode | rtime qnode oldnode -- , insert node just before node with later time }	1 eb-num-posts +!	node1 ..@ eb_time -> rtime	startnode dup  -> oldnode   @ -> qnode	BEGIN		1 eb-num-post-loops +!		qnode		IF			rtime   qnode ..@ eb_time  time< not \ stop when rtime<qtime		ELSE			false		THEN	WHILE		qnode -> oldnode		qnode eb.next -> qnode	REPEAT	node1 oldnode eb.link.after	node1 eb-last-node-posted !;: EB.POST.NODE.FAST { node1 | rtime lasttime lastnode -- }	eb-last-node-posted @ -> lastnode	lastnode	IF\ if new node is at or after the last node posted then start search from there		node1 ..@ eb_time -> rtime		lastnode ..@ eb_time -> lasttime		rtime lasttime  time< not		IF			lastnode ..@ eb_cfa EB_ILLEGAL_CFA = not  \ make sure not already processed			IF				node1 lastnode eb.post.node			ELSE				node1 eb-pending-nodes eb.post.node			THEN		ELSE			node1 eb-pending-nodes eb.post.node		THEN	ELSE		node1 eb-pending-nodes eb.post.node	THEN;: EB.ADD.NODE { data cfa time -- , called by foreground task to schedule event }    disable.clock.int >r  \ save status-reg    time eb-last-time-processed @ time>  \ is time in future?    IF\ get a node        BEGIN            eb.alloc.node ?dup 0=         WHILE            r> restore.interrupt\            ." EB.ADD.NODE - Waiting for free node!" cr            ?terminal abort" EB.ADD.NODE - Wait aborted!"            disable.clock.int >r        REPEAT        >r \ save node        data cfa time        r> eb.setup.node   ( -- node )        time eb-last-time-processed @ EB_NUM_SLOTS + time<    	IF    		eb.add.to.slots        	r> restore.interrupt    	ELSE    		eb-reserve-list on        	r> restore.interrupt        	eb-pending-nodes eb.post.node \ use .fast ? FIXME    		eb-reserve-list off        THEN    ELSE data cfa execute  ( just do it now )    	r> restore.interrupt    THEN;: CAUSE  ( data cfa time -- , alias for eb.add.node )    eb.add.node;: EB.CLEAR  ( -- , clear all nodes and levels, leave time alone )    disable.clock.int    	eb.clear.pool    restore.interrupt;: EB.RESET  ( -- , reset system , called when time changes )    disable.clock.int    eb.clear.pool    eb.clear.slots    eb-in-evbuf off    eb-error off    eb-pending-nodes off    eb-num-post-loops off    eb-num-posts off    eb-last-node-posted off    eb-reserve-list off    rtc.time@ eb-last-time-processed !    restore.interrupt;: EB.REPORT.STATS  ( -- )	eb-num-post-loops @ dup . ." loops for "	eb-num-posts @ dup . ." posts" cr	." Average of " / . ."  loops/post." cr;	: EB.INIT ( -- )    " EB.INIT" debug.type    disable.clock.int >r    eb-error off    eb.free.pool    eb-num-nodes @ eb.alloc.pool    eb.reset    r> restore.interrupt;: EB.TERM ( -- )    " EB.TERM" debug.type    disable.clock.int >r    eb.free.pool    r> restore.interrupt;: EB.REALLOC.POOL  ( num_nodes -- )    eb.term    eb-num-nodes !    eb.init;: SYS.INIT sys.init eb.init ;: SYS.TERM eb.term sys.term ;if.forgotten eb.termif-testing @ .IF\ Test of event buffering ---------------------------variable TEST-LIST  : TEST1    eb.clear.pool    eb.alloc.node dup test-list !    4 0    DO >r eb.alloc.node dup r> eb.link       i over ..! eb_data       ' dup over ..! eb_cfa    LOOP;: DUMWORD  ( data -- )	." data = " . ." eb-last-time-processed = " eb-last-time-processed ? cr;: EB.CATCHUP ( -- )    BEGIN        rtc.time@ eb.process.pending		?terminal    UNTIL;: EB.RUN ( -- )	BEGIN		eb-last-time-processed @ 1+\		." EB.RUN - time = " dup . cr		dup eb.process.pending		eb-last-time-processed !		?terminal	UNTIL;variable EBT-OFFSET: EBT.ADD  ( data cfa time-offset )	ebt-offset @ + eb.add.node;: ADD.EVENTS ( -- )	eb-last-time-processed @  ebt-offset !\    123 ' dumword 0  ebt.add\    222 ' dumword 0  ebt.add\    333 ' dumword 0  ebt.add    444 ' dumword 1  ebt.add    555 ' dumword 4  ebt.add    1111 ' dumword 23  ebt.add    2222 ' dumword 43  ebt.add    3333 ' dumword 259  ebt.add    666 ' dumword 4  ebt.add    777 ' dumword 10  ebt.add    888 ' dumword 20  ebt.add    999 ' dumword 23  ebt.add    4444 ' dumword 294  ebt.add    5555 ' dumword 387  ebt.add    6666 ' dumword 600  ebt.add    7777 ' dumword eb_num_slots  ebt.add    9999 ' dumword eb_num_slots 200 +  ebt.add    8888 ' dumword eb_num_slots 100 +  ebt.add;: TEST2	eb.init	add.events	eb.run;: EB.TEST	eb.init	123 ' dumword 23 eb.alloc.node eb.setup.node eb.add.to.slots	eb.dump;\ Moved to EVMIDI so that we can load w/out MIDIvariable EBM-ZAP-PAD  ( only used by this word in background ): MIDI.ZAP  ( packed-data -- )    ebm-zap-pad 2dup !    swap 3 and 0	DO dup i + c@ midi.xmit	LOOP	drop;: ADD.MIDI.EVENTS    [ hex ]	time@ 5 + ebt-offset !    90326003 'c midi.zap 1  ebt.add    90320003 'c midi.zap 6  ebt.add    90346003 'c midi.zap 9  ebt.add    90367003 'c midi.zap 10  ebt.add    90386003 'c midi.zap 11  ebt.add    90340003 'c midi.zap 20  ebt.add    90360003 'c midi.zap 30  ebt.add    90380003 'c midi.zap 40  ebt.add    [ decimal ];: ADD.SIMPLE.MIDI  ( -- , no overlapping events )    [ hex ]	time@ 5 + ebt-offset !    90326003 'c midi.zap 1  ebt.add    90320003 'c midi.zap 6  ebt.add    90346003 'c midi.zap 9  ebt.add    90340003 'c midi.zap 20  ebt.add    [ decimal ];: BANG 100 midi.noteon ;: TEST3    20 rtc.rate!    eb.init    add.midi.events    eb.run;: TEST4    20 rtc.rate!    eb.init    add.midi.events;." 0 time-advance !" cr0 time-advance !.THENif.forgotten eb.term