\ Assemble parts of hashing to speed it up.\ Author: Phil Burk\ Copyright 1992 Phil BurkANEW TASK-HASHING_PLUSASM NAME.4N+.ASM  ( nfa -- key , faster hash key generator )\ Register Usage\    D0 = Shift Count\    D1 = Number of characters left\    D2 = Pad for bytes\    D7 = running total\    A0 = Address of next char	MOVE.L		D2,-(A7)	MOVE.L		(A6)+,A0	\ get NFA	MOVEQ.L		#0,D7	MOVE.L		D7,D0	MOVE.L		D7,D2	MOVE.B		(A0)+,D1	\ get count	ANDI.L		#$1F,D1		\ mask off flag bits	BEQ		@2	SUBQ.L		#1,D1    \ Adjust for DBRQ	MOVEQ.L		#2,D0    \ Size determines shift count!	CMP.W		#8,D1	BLT		@1	MOVEQ.L		#1,D0@1	ASL.L		D0,D7	MOVE.B		(A0)+,D2	ADD.L		D2,D7	DBRA.W		D1,@1@2	ANDI.L		#$FFFFFF,d7  \ clip result 0F!!	MOVE.L		(A7)+,D2	MOVE.L		D7,-(a6)	RTSEND-CODEASM HASH.SEARCH.ARRAY.ASM  ( array size name -- hash# flag )\ Register Usage\  D2 = modulus\  D3 = increment\  D4 = key\  D5 = hash#\  D6 = name\  A0 = array base	move.l		d2,-(a7)	move.l		d3,-(a7)	move.l		d4,-(a7)	move.l		d5,-(a7)	move.l		d6,-(a7)	move.l		d7,-(a7)\ Get Key for Name        move.l		(a6),-(a6)	\ DUP	bsr		name.4n+.asm  ( -- a s n key )\\ Gather parameters        move.l		(a6)+,d4	\ key	move.l		(a6)+,d6	\ name  ( rel )	move.l		(a6)+,d2	\ modulus	move.l		(a6)+,a0	\ array\\ DO fast MOD to convert key>hash	move.l		d4,d5	divu		d2,d5		\ hash# = mod(key,modulus)    	swap		d5	and.l		#$FFFF,d5\\ Lookup NFA in array	move.l		d5,d7		\ hash#,d7	asl.l		#2,d7		\ cell*	move.l		$0(a0,d7),d7	\ load name address\\ Check for match if name found.	BEQ		@4		\ skip if empty slot	move.l		d6,-(a6)	\ push names	move.l		d7,-(a6)	move.l		a0,-(a7)	\ save address of array	bsr		match.names	move.l		(a7)+,a0	move.l		(a6)+,d7\\ Return true if matched	tst.l		d7		\ result non zero?	BNE		@4		\ \\ If it is not the right name, collision!\ Calculate increment and begin searching.\ Increment = MOD(KEY,SIZE-2)	move.l		d4,d3		\ copy KEY\ Use size for loop count	move.l		d2,d4	move.l		d2,d7		\ size	subq.l		#2,d7		\ 2-	divu		d7,d3		\ MOD	swap		d3	and.l		#$FFFF,D3	BNE		@2	moveq.l		#1,d3		\ 1 better than 0\@2	add.l		d3,d5		\ increment hash#	divu		d2,d5		\ SIZE MOD	swap		d5	and.l		#$FFFF,d5\\ Increment Collision Counter	moveq.l		#1,d7	lea		HASH-#COLLISIONS,a1	add.l		d7,(a1)\\ lookup name in new array location	move.l		d5,d7		\ new hash#	asl.l		#2,d7	move.l		$0(a0,d7),d7	\ load name address\\ check for match if NFA found	BEQ		@3		\ otherwise return 0	move.l		d6,-(a6)	move.l		d7,-(a6)	move.l		a0,-(a7)	\ save address of array	bsr		match.names	move.l		(a7)+,a0	move.l		(a6)+,d7\\ Keep looking if not a match	cmpi.l		#0,d7	DBNE.W		d4,@2\	moveq.l		#$-1,d7	bra		@4\ @3	moveq.l		#0,d7\@4	move.l		d5,-(a6)	move.l		d7,-(a6)\	move.l		(a7)+,d7	move.l		(a7)+,d6	move.l		(a7)+,d5	move.l		(a7)+,d4	move.l		(a7)+,d3	move.l		(a7)+,d2	rtsEND-CODE: HASH.USE.ASM  ( -- , use assembly language for critical words )	hash.off	' hash.search.array.asm is hash.search.array	' name.4n+.ASM is name.4n+	hash.on;hash.use.asmif.forgotten hash.use.forth