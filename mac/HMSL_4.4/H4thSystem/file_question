\ File? and EDIT\\ Author: Phil Burk\ Copyright 1992 Phil Burk\\ 00001 PLB 2/21/92 Handle words from kernel or keyboard.\		Support EACH.FILE?ANEW TASK-FILE_QUESTIONvariable FILE?-DEPTH\ scan dictionary from NFA for filename: F?.SEARCH.NFA { nfa | dpth found? stoploop keyb nfa0 -- addr count true | false }	0 -> dpth	0 -> found?	0 -> stoploop	0 -> keyb	nfa -> nfa0	nfa 0>	IF		BEGIN			nfa prevname -> nfa			nfa 0>			IF				nfa 1+ odd@				CASE					$ 3a3a3a3a ( :::: )					OF						dpth 0=						IF							nfa count 31 and							4 - swap 4 + swap							true -> found?							true -> stoploop						ELSE							-1 dpth + -> dpth						THEN					ENDOF					$ 3b3b3b3b ( ;;;; )					OF							1 dpth + -> dpth							true -> keyb     \ maybe from keyboard					ENDOF				ENDCASE			ELSE				true -> stoploop				>newline nfa0 id. ."  compiled " keyb				IF					." from keyboard." cr				ELSE					." in assembly language kernel." cr				THEN			THEN			stoploop		UNTIL	ELSE		." FILE? NFA = 0" cr	THEN	found?;: F?.SEARCH { $word -- addr cnt true | false }	$word findnfa	IF		f?.search.nfa	ELSE		$type ."  not found!" cr false	THEN;\ Use deferred words so that we can put FILE? low down in Forthdefer $F?.OPEN.FIND ( $word $filename -- )' 2drop is $F?.OPEN.FINDdefer $F?.OPEN.FIND.RO ( $word $filename -- )' 2drop is $F?.OPEN.FIND.ROexists? $tx.open.find .IF' $tx.open.find is $f?.open.find' $tx.open.find.ro is $f?.open.find.ro.THEN: (FILE?) { $word addr cnt -- , ask to see file }	>newline	$word $type ."  from file: " addr cnt type cr	." Do you want to see the source code?" y/n/q	IF		file?-pad off		addr cnt file?-pad $append		$word file?-pad $F?.OPEN.FIND.RO	THEN;: FILE? ( <name> -- )	bl word dup f?.search ( $word addr cnt true | $word false )	IF		(file?)	ELSE		drop	THEN;: EACH.FILE? {  | $word nfa done? -- , take name from input }	0 -> done?	bl word -> $word 	$word findnfa	IF		-> nfa		BEGIN			nfa f?.search.nfa ( addr cnt true | false )			IF				$word -rot (file?)			THEN\ search for next occurence, if any			BEGIN				nfa prevname -> nfa				nfa 0>				IF					nfa $word match.nfas					IF						true  \ stop search					ELSE						false					THEN				ELSE					true -> done?					true \ stop search				THEN			UNTIL			done?		UNTIL	THEN;: EDIT ( <name> -- )	bl word dup>r f?.search	IF		file?-pad off		file?-pad $append		r@ file?-pad $F?.OPEN.FIND	THEN	rdrop;	