\ Assign Logical Volume Names to directories like on the\ VAX and the Amiga.\\ Maintain two string tables with corresponding strings.\\ Author: Phil Burk\ Copyright 1987 Phil Burk, Larry Polansky, David Rosenboom\ All Rights Reserved\\ MOD: PLB 11/5/90 Fix ASSIGN L$ to clear\ MOD: PLB 7/16/91 FILEWORD now uses LWORD\ 00001 PLB 2/21/92 Save FILE-TYPE and FILE-CREATOR when replacing a file.\ 00002 PLB 9/28/92 Add EOF\ 960623 PLB Change MAX_#ASSIGNS from 32 to 50decimalANEW TASK-FILE_TOOLS.F50 constant MAX_#ASSIGNS80 constant MAX_REAL_CHARS32 constant MAX_LOGICAL_CHARSmax_#assigns max_logical_chars $array AS-LOGICAL-NAMESmax_#assigns max_real_chars $array AS-REAL-NAMESCREATE AS-BUFFER max_real_chars 2* 2+ allotCREATE AS-SCRATCH max_real_chars 2* 2+ allotCREATE AS-HOLDER max_real_chars 2+ allotCREATE AS-#NAMES 0 ,: AS.INIT    0 as-logical-names max_#assigns max_logical_chars * 0 fill    0 as-real-names max_#assigns max_real_chars * 0 fill    0 as-#names !;as.init\ Search logical table for match: AS.MATCH ( $string -- index true | false )    -1 swap    as-#names @ 0    DO  i as-logical-names        over $match?        IF  swap drop i swap LEAVE        THEN    LOOP drop    dup 0<    IF drop 0    ELSE -1    THEN;: AS.CHECK ( $string -- , will it fit )    c@ max_real_chars >    IF ." Name too big for ASSIGN!!" abort    THEN;: AS.MOVE.NAMES   ( high low -- , move names down one )    DO i 1+ as-logical-names i as-logical-names  $move       i 1+ as-real-names i as-real-names  $move    LOOP; : AS.REMOVE ( index -- , remove name from tables %Q not finished!!!)    as-#names @ 1- over >   ( valid index? )    IF  ( -- index )        as-#names @ 1- swap 2dup =        IF 2drop         ELSE   ( #names-1 index -- ) as.move.names        THEN        -1 as-#names +!    ELSE ." AS.REMOVE - index out of range!" cr drop    THEN;: ASSIGNS? ( -- , print logical assignments )    as-#names @ 0    DO  cr i . 4 spaces i as-logical-names count type		bl 20 emit-to-column        i as-real-names count type    LOOP cr;variable EF-NAMEvariable EF-TEMP-ADDRvariable EF-LOGLEN: REMOVE.LAST.:    ( $string -- , strip off last : if there is one )    dup count 1- + c@ ascii : =	IF ( -- $string ) dup c@ 1- swap c!	ELSE drop	THEN;: EXPAND.FILENAME ( $name -- $fullname, expand logical to full path )    dup ef-name !    as.check    ef-name @ as-scratch $move   ( save in scratch area )    as-scratch ascii : index     ( is there a ':' in the name )    IF  ef-temp-addr !        ( address just before : )        as-scratch as-buffer $move   ( save whole name in buffer )        ef-temp-addr @ as-scratch - ( -- len_volume_name_: )		dup 1 >		IF	dup ef-loglen !  ( -- len_volume_name_: )        	as-buffer c!  ( update length to just include up to : )        	as-buffer as.match         	IF  as-real-names as-buffer $move  ( copy real prefix to buffer )          		as-scratch c@ ef-loglen @ - dup 0>  ( chars after : ? )				IF	1+ ef-temp-addr @ 1- c!  ( copy suffix w/ : )          			ef-temp-addr @ 1- count as-buffer $append				ELSE drop          		THEN as-buffer        	ELSE ef-name @        	THEN		ELSE drop ef-name @		THEN   	ELSE ef-name @    THEN;: $ASSIGN ( $logical_name $real_name -- , set assignment )    over as.match not  ( -- $l $n index false | $l $n true )    IF  as-#names @ dup max_#assigns <        IF  dup 1+ as-#names !        ELSE ." Sorry, ASSIGN table full!" cr abort        THEN    THEN  ( $l $n index )    swap dup c@   ( any chars in real name? )    IF  ( $l index $n )		expand.filename		over as-real-names $move		dup as-real-names remove.last.:        as-logical-names $move    ELSE ( $l index $n -- , no second name, clear entry )        drop as.remove drop    THEN;: ASSIGN ( <logical> <real> -- )    32 word dup as.check as-holder $move as-holder    32 word $assign;\ File extensions-1 constant EOF \ 00002VARIABLE FIO-CHAR-BUFFER: FKEY  ( fid -- char | -1)    fio-char-buffer 1 fread    1 =    IF   fio-char-buffer c@    ELSE EOF \ 00002    THEN;: FEMIT ( fid char -- )    fio-char-buffer c!    fio-char-buffer 1 fwrite    drop;0 constant MODE_OLDFILE1 constant MODE_NEWFILEvariable FILEMODE13 constant EOL   ( Host dependant EOL ): NEW  ( -- , open next file as a brand new file )    mode_newfile filemode !;: REPORT.MAC.ERROR   ( error# -- )    >newline ." Macintosh Error = " dup . ."  - "    CASE        -33 OF ." File directory FULL!" cr ENDOF        -34 OF ." Disk is FULL!" cr ENDOF        -35 OF ." Specified volume doesn't exist!" cr ENDOF        -36 OF ." I/O Error!?" cr ENDOF        -37 OF ." Bad name! 0 length?" cr ENDOF        -38 OF ." File not open!" cr ENDOF        -39 OF ." End of file reached!" cr ENDOF        -40 OF ." Attempt to position before start!" cr ENDOF        -41 OF ." Memory Full!" cr ENDOF        -42 OF ." Too many files open!" cr ENDOF        -43 OF ." File not found!" cr ENDOF        -44 OF ." Volume locked, release tab!" cr ENDOF        -45 OF ." File is Locked!" cr ENDOF        -46 OF ." Volume locked by software!" cr ENDOF        -47 OF ." File is busy!" cr ENDOF		-48 OF ." File already exists!" ENDOF        -49 OF ." File already open for Write!" cr ENDOF        -50 OF ." Error in Parameter List!" cr ENDOF        -51 OF ." Bad path reference number!" cr ENDOF        -52 OF ." Error in GetFpos" cr ENDOF        -53 OF ." Volume not on-line!" cr ENDOF        -54 OF ." Read Permission only!" cr ENDOF        -55 OF ." Specified Volume already mounted!" cr ENDOF        -56 OF ." No such drive!" cr ENDOF        -57 OF ." Not a Macintosh Disk!" cr ENDOF        -58 OF ." External file system!" cr ENDOF        -59 OF ." Problem during rename!" cr ENDOF        -60 OF ." Bad master directory block, must reinitialize volume!" cr ENDOF        -61 OF ." Write permission denied!" cr ENDOF		." Unrecognized error!" cr    ENDCASE;: FILEWORD  ( -- addr , parse name with quote delimiters)    bl lword	dup 1+ c@ ascii " =  ( is first char a " )	IF ( -- addr , reset >in and reparse )		c@ negate >in +!		ascii " lword	THEN;: CD ( <volname> -- , set directory , this doesn't seem to work! )	fileword	expand.filename	0 $fsetvol_vr ?dup	IF report.mac.error abort	THEN;\ Install filename expansion into system.defer EF-OLD-$FOPEN_VRvariable SCRATCH1 \ for holding parameters temporarilyvariable SCRATCH2: EF.$FOPEN_VR  ( $name vrefnum -- fileptr | 0 , expand name before opening, create new if NEW mode )    >r \ save vrefnum	expand.filename    filemode @ mode_newfile =    IF		file-type @ scratch1 !  \ save for second fcreate below, 00001		file-creator @ scratch2 !		dup r@ $fcreate_vr ( -- $name error )  dup        IF	dup -48 = ( $name error flag )			IF	drop >newline ." Original file overwritten." cr				( $name ) dup r@ $fdelete_vr dup				IF ( $name error ) nip report.mac.error false				ELSE					drop					scratch1 @ file-type ! \ 00001					scratch2 @ file-creator !					dup r@ $fcreate_vr dup					IF nip report.mac.error false					ELSE drop true					THEN				THEN			ELSE nip report.mac.error false			THEN        ELSE drop true   ( creation successful )        THEN    ELSE true    THEN  ( -- $name true | false )\\ Open if OK    mode_oldfile filemode !    IF  r> ef-old-$fopen_vr dup 0=		IF  drop ferror @ report.mac.error 0        THEN	ELSE rdrop false    THEN;variable EF-IF-ON." Change names in kernel for $FOPEN_VR !!!!" cr: $FOPEN.VR  ( $filename vrefnum -- )	$fopen_vr;: ASSIGN.ON  ( -- , use ASSIGNs with file system )    ef-if-on @ 0=	IF what's $fopen_vr is ef-old-$fopen_vr		['] ef.$fopen_vr is $fopen_vr		ef-if-on on	THEN;: ASSIGN.OFF  ( -- )	ef-if-on @	IF what's ef-old-$fopen_vr is $fopen_vr		ef-if-on off	THEN;if.forgotten assign.offas.initassign.on: SFGETFILE ( -- , $filaname vrefnum true | 0 )	0 sfgetfilep;: HOST.GETFILE  ( -- filename fileptr | 0 0 )	sfgetfile	IF	over swap $fopen_vr	ELSE 0 0 	THEN;\ redefined later: HOST.PUTFILE  ( -- filename fileptr | name 0 )    new " ram:hmsl.data" dup $fopen;