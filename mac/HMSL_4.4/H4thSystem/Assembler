\ Motorola Style 680x0 Assembler\\ This is a "forward parsing" assembler\ which is easier to use than the traditional\ Forthlike RPN assembler.\\ Author: Phil Burk\ Copyright 1990 Phil Burk\\ Work remaining -------------\	CALL\	variable reference\	ALL opcodes\   Allow n(a5) addressing on Mac\  8(a0,d1.w) versus 8(a0,d1.L)\ coerce $0(Ar) to (Ar)\ MOD: PLB 10/8/90 Fixed   MOVE.L   [con1](a3),A1   ASM.TALLY.[] blew!echo offdecimalinclude? tolower ju:char-macrosANEW TASK-ASSEMBLERFALSE constant host=amigaTRUE constant host=mac\ Support Words\ self fetching arrays -------------------------------------variable VALSTATE  \ if true, store into array: VALARRAY	CREATE  ( #entries <name> -- ) cell* ALLOT	DOES> ( index -- address-entry ) swap cell* +	    valstate @	    IF !  valstate off	    ELSE @	    THEN;: WVALARRAY	CREATE  ( #entries <name> -- ) 2* ALLOT	DOES> ( index -- address-entry ) swap 2* +	    valstate @	    IF w!  valstate off	    ELSE w@	    THEN;: BVALARRAY	CREATE  ( #entries <name> -- ) allot	DOES> ( index -- address-entry ) +	    valstate @	    IF c!  valstate off	    ELSE c@	    THEN;: ->A ( val <array> -- )    valstate on;\ ------------------------------------------------------\ Variables used by assembler.variable ASM-STATE    \ true if assemblingvariable ASM-RTS?     \ has an RTS been assembled yet\ buffer used to build opcodes and datavariable ASM-OPCODE   14 cell- allotvariable ASM-OFFSET,  \ offset used by ,variable ASM-PAD      \ used for various thingsvariable ASM-SIZE     \ letter suffix from opcode2 array ASM-CODES \ arrays used to hold both src/dst2 array ASM-AREGS2 array ASM-DREGS2 array ASM-NUMBERSvariable ASM-SRC/DST  ( 0 = src , 1 = dst ): ASM-CODE  ( -- addr , changes for src/dst )    asm-src/dst @ asm-codes;: ASM-AREG  ( -- addr , changes for src/dst )    asm-src/dst @ asm-aregs;: ASM-DREG  ( -- addr , changes for src/dst )    asm-src/dst @ asm-dregs;: ASM-NUMBER  ( -- addr , changes for src/dst )    asm-src/dst @ asm-numbers;variable ASM-()NEST \ how deep nested ()s64 constant ASM_OPSIZEcreate $ASM-BFR1 ASM_OPSIZE allot \ string buffer for operandscreate $ASM-BFR2 ASM_OPSIZE allot \ string buffer for operandscreate $ASM-BFR3 ASM_OPSIZE allot \ string buffer for temp\ Tables to drive Assembler80 constant ASM_MAX_#OPCODESasm_max_#opcodes valarray ASM_NAMES  \ stored as compressed text, 4 cellsasm_max_#opcodes wvalarray ASM_MASKS \ bitmask for building opcodeasm_max_#opcodes bvalarray ASM_TYPES \ code for type of operandvariable ASM-#OPCODES\ Unresolved Branch tracking tables32 constant ASM_MAX_BRANCHES\ at address +1 will be stored byte with packed nibbles\ telling labelIndex + +/1size ( - for relative )asm_max_branches valarray ASM_UNRB_ADDRS  ( unresolved branch addrs )asm_max_branches bvalarray ASM_UNRB_DESTS  ( local label# )asm_max_branches bvalarray ASM_UNRB_SIZES  ( - if rel )variable ASM_#BRANCHES   \ keep count of number of branches10 valarray ASM_LOCAL_LABELS  ( addresses of local labels @0-@9 )host=amiga .IF: 0<> 0= NOT ;: <> - 0<> ;3 constant ASM_REG_64K4 constant ASM_REG_ORG: ASM.IN.DICT?  ( addr -- )    0 here within?;: CODEBASE ( -- , address of start of kernel ) 0 ;: TEXT=  ( addr1 addr2 count -- flag )	swap text=?;.THENhost=mac .IF3 constant ASM_REG_64K4 constant ASM_REG_ORG: ASM.IN.DICT?  ( addr -- )    codebase here within?;variable LASTSCAN   \ used by Amiga, not needed on Mac.THEN: ASM.PACK.NAME  ( $long -- packed suffix , pack left justified )\ pack into a form that simplifies searching    count 2dup ascii . scan ?dup    IF  2 =  ( just a normal .L or other suffix? )        IF 1+ c@ toupper >r  2-  ( remove suffix from string )        ELSE >newline ." Suffix can only be one char, eg. .L" drop            cr type abort        THEN    ELSE drop 0 >r    THEN    ( -- addr count' )    over odd@ asm-pad !  ( store first 4 chars )\ pack MOVEQ -> MOVQ , MOVEM -> MOVM    dup 5 =    IF drop 4 + c@ asm-pad 3 + c!  ( pack into last spot )    ELSE 4 swap - 0        DO BL  asm-pad 3 + i - c!  ( pad with blanks )        LOOP drop    THEN    asm-pad @ r>;: ASM.ADD  ( $name type mask -- )    asm-#opcodes @ dup 1+ asm_max_#opcodes > abort" Too many opcodes!"	->a asm_masks    asm-#opcodes @ ->a asm_types    1+ odd@ asm-#opcodes @ ->a asm_names    1 asm-#opcodes +!;\ Build Tables\ name type mask" ADD "  1 $ D000 asm.add " ADDA"  5 $ D000 asm.add" ADDI"  6 $ 0600 asm.add " ADDQ"  7 $ 5000 asm.add " AND "  1 $ C000 asm.add" ANDI"  6 $ 0200 asm.add " ASL "  4 $ E100 asm.add " ASR "  4 $ E000 asm.add" BCC "  9 $ 6400 asm.add" BCS "  9 $ 6500 asm.add" BEQ "  9 $ 6700 asm.add" BGE "  9 $ 6C00 asm.add" BGT "  9 $ 6E00 asm.add" BHI "  9 $ 6200 asm.add" BLE "  9 $ 6F00 asm.add" BLS "  9 $ 6300 asm.add" BLT "  9 $ 6D00 asm.add" BMI "  9 $ 6B00 asm.add" BNE "  9 $ 6600 asm.add" BPL "  9 $ 6A00 asm.add" BRA "  9 $ 6000 asm.add" BSET" 21 $ 00C0 asm.add" BTST" 21 $ 0000 asm.add" BSR "  9 $ 6100 asm.add" BVC "  9 $ 6800 asm.add" BVS "  9 $ 6900 asm.add" CLR " 10 $ 4200 asm.add " CMP "  2 $ B000 asm.add" CMPI"  6 $ 0C00 asm.add" DBCC" 17 $ 54C8 asm.add" DBCS" 17 $ 55C8 asm.add" DBEQ" 17 $ 57C8 asm.add" DBF " 17 $ 51C8 asm.add" DBGE" 17 $ 5CC8 asm.add" DBGT" 17 $ 5EC8 asm.add" DBHI" 17 $ 52C8 asm.add" DBLE" 17 $ 5FC8 asm.add" DBLS" 17 $ 53C8 asm.add" DBLT" 17 $ 5DC8 asm.add" DBMI" 17 $ 5BC8 asm.add" DBNE" 17 $ 56C8 asm.add" DBPL" 17 $ 5AC8 asm.add" DBRA" 17 $ 51C8 asm.add" DBT " 17 $ 50C8 asm.add" DBVC" 17 $ 58C8 asm.add" DBVS" 17 $ 59C8 asm.add" DC  " 18 $ 0000 asm.add" DIVS" 12 $ 81C0 asm.add" DIVU" 12 $ 80C0 asm.add" EOR "  3 $ B100 asm.add" EORI"  6 $ 0A00 asm.add" EXT " 16 $ 4800 asm.add" JMP " 19 $ 4EC0 asm.add" JSR " 19 $ 4E80 asm.add" LEA " 13 $ 41C0 asm.add" LINK" 14 $ 4E50 asm.add" MOVE"  0 $ 0000 asm.add" MOVQ"  20 $ 7000 asm.add" MULS" 12 $ C1C0 asm.add" MULU" 12 $ C0C0 asm.add" NEG " 10 $ 4400 asm.add" NOP "  8 $ 4E71 asm.add" NOT " 10 $ 4600 asm.add" OR  "  1 $ 8000 asm.add" ORI "  6 $ 0000 asm.add" RTS "  8 $ 4E75 asm.add" RTR "  8 $ 4E77 asm.add" SUB "  1 $ 9000 asm.add" SUBA"  5 $ 9000 asm.add" SUBI"  6 $ 0400 asm.add" SUBQ"  7 $ 5100 asm.add" SWAP" 11 $ 4840 asm.add" TST " 10 $ 4A00 asm.add " UNLK" 15 $ 4E58 asm.add \ Constants% 000 constant EFACODE_Dr% 001 constant EFACODE_Ar% 010 constant EFACODE_(Ar)% 011 constant EFACODE_(Ar)+% 100 constant EFACODE_-(Ar)% 101 constant EFACODE_n(Ar)% 110 constant EFACODE_n(Ar,Dr)% 1000 constant EFACODE_ABSW% 1001 constant EFACODE_ABSL% 1010 constant EFACODE_n(PC)% 1011 constant EFACODE_n(PC,Dr)% 1100 constant EFACODE_#n% 1110 constant EFACODE_LOCAL   \ local label eg. @5% 1111 constant EFACODE_SYMBOL  \ eg. variables, CREATEd words: ASM.CODE>RM  ( code -- reg mode )    dup % 111 and    swap % 1000 and    IF % 111    ELSE dup 0=		IF			asm-dreg @ \ Dn mode		ELSE			asm-areg @ \ other Ar related mode		THEN		swap    THEN;decimal\ Support for laying down code in dictionary.: ASM,  ( 32bits -- , lay into dictionary )    asm-offset, @ asm-opcode + !    4 asm-offset, +!;: ASMW,  ( 16bits -- , lay 16 bit word down )    asm-offset, @ asm-opcode + w!    2 asm-offset, +!;: ASMC,  ( 8bits -- , lay byte into dictionary, ALIGN afterwards )    asm-offset, @ asm-opcode + c!    1 asm-offset, +!;: ASM.LAYDOWN  ( -- , move from opcode buffer to dict )    asm-opcode here asm-offset, @ cmove    asm-offset, @ allot    2 asm-offset, !;: ASM.OR  ( data -- , or with opcode buffer    asm-opcode w@ or asm-opcode w!;variable ASM-IN-[]: ASM.TALLY.[] ( $string -- flag , true if in [] )    lastscan @ >r    count dup 0= abort" CODE - Missing ']'"	asm-in-[] @	IF	ascii ] scan nip 0=    ELSE ascii [ scan dup 0>		IF	ascii ] scan nip 0=		ELSE 2drop false		THEN	THEN    dup asm-in-[] !    r> lastscan !;: ASM.GET.OPS  ( <operands> -- , get operands and comment)    $asm-bfr1 off    asm-in-[] off    BEGIN    bl word \ dup ." = " $type cr       dup count $asm-bfr1 $append       asm.tally.[]    WHILE $asm-bfr1 BL $append.char    REPEAT    [compile] \;: ASM.ABORT ( -- )    $asm-bfr1 $type ." ,"    $asm-bfr2 $type cr abort;: ASM.ERROR  ( error# -- , display appropriate message )	CASE	0 OF ." Invalid number" ENDOF	1 OF ." Unbalanced parentheses" ENDOF	2 OF ." Incorrect number of operands" ENDOF	3 OF ." Invalid Size" ENDOF	4 OF ." One of the operands must be a Data Register" ENDOF	5 OF ." Invalid Register Number" ENDOF	6 OF ." Destination must be a Data Register" ENDOF	7 OF ." Source must be a Data Register" ENDOF	8 OF ." Destination must be an Address Register" ENDOF	9 OF ." Source must be an Address Register" ENDOF	10 OF ." Illegal SHIFT" ENDOF	11 OF ." Source must be Immediate" ENDOF	12 OF ." Local labels must be '@d' where d=0-9" ENDOF	13 OF ." Data too large for QUICK mode" ENDOF	14 OF ." Unrecognized Symbol" ENDOF	15 OF ." Symbol must leave ONE number on stack" ENDOF	16 OF ." Displacement too large" ENDOF	ENDCASE	ascii ! emit cr	asm.abort;\ Assume string in $asm-bfr1\ Input Parsingfalse .IFAddressing modes will be identified by key.Parentheses?YES	(comma)?	YES	has "(PC,"?		YES	= n(PC,Dr)		NO	= n(Ar,Dr)	NO	leading '-(A'		YES = -(Ar)		NO	leading '('?   \ ASM.PARSE.NO,			YES trailing '+'				YES = (Ar)+				NO	= (Ar)			NO	has (PC)?				YES = n(PC)				NO	= n(Ar)NO	'#'?	YES = Immediate, number or symbol	NO	number?		YES = absolute		NO	, D0-7 or A0-7 ?			Yes = Dr Ar			No  = symbol.THEN: ASM.GRAB.REG#  ( index -- reg# , get register from string )    $asm-bfr1 1+ + c@ 10 digit 0=    IF emit ." = " 5 asm.error    THEN;: $EAT1  ( addr count -- addr+1 count-1 )    1- swap 1+ swap;: ASM.STRIP.BASE  ( addr count -- addr' count' )\ strip numeric base from string and set	over c@	CASE		ascii $ OF HEX $eat1 ENDOF		ascii % OF BINARY $eat1 ENDOF		DECIMAL	ENDCASE;: ASM.[?]  ( $string -- number true | $string false )    depth >r\ interpret string if in [ ... ]    dup 1+ c@ ascii [ =    IF count 2- swap 1+ swap       [compile] [ $interpret [compile] ] true    ELSE false    THEN    depth 1- r> <>    IF " String in [ ] should leave one number!" asm.abort    THEN;: ASM.NUMBER?  ( $string -- d true | false , stick space at end !!!! )	BL over count + c!	number?;: ASM.EXEC.VAL ( cfa -- value )	depth >r	[compile] [ execute [compile] ]  \ execute in interpreting mode	depth r> -	IF 15 asm.error	THEN;: ASM.GET.LEADING#  ( addr count char -- number , get from head )\ char is character that terminates numeric string	>r 2dup r> scan nip -	asm.strip.base	$asm-bfr3 off  $asm-bfr3 $append	$asm-bfr3 asm.number? 0=	IF $asm-bfr3 asm.[?]  0=	    IF			FIND			IF				asm.exec.val			ELSE				0 asm.error			THEN	    THEN	ELSE drop	THEN	decimal;: ASM.GET.OFFSET ( -- , get offset from leading portion of op )	$asm-bfr1 count	ascii ( asm.get.leading# asm-number !;: ASM.GET.IMM ( -- , eat '#', then get number)	$asm-bfr1 count $eat1	ascii , asm.get.leading# asm-number !;: ASM.PARSE.NO,  ( -- code , continue parsing )    $asm-bfr1 count 3 min    " -(A" count drop swap text=    IF efacode_-(Ar) 3 asm.grab.reg# asm-areg !    ELSE $asm-bfr1 1+ c@ ascii ( =        IF $asm-bfr1 count + 1- c@ ascii + =            IF efacode_(Ar)+            ELSE efacode_(Ar)             THEN  2 asm.grab.reg# asm-areg !        ELSE $asm-bfr1 count " (PC)" count match?            IF efacode_n(PC) asm.get.offset            ELSE efacode_n(Ar) asm.get.offset                $asm-bfr1 c@ 2- asm.grab.reg# asm-areg !            THEN        THEN    THEN;: ASM.ADDR>EFA  ( addr -- efa , convert address to appropriate efa )	dup>r asm.in.dict?	IF ( address of something in dictionary, make relocatable )\ Try relative branch first		r@ here - 2- dup abs 32766 <		IF asm-number ! efacode_n(pc)		ELSE drop\ Then try relative to base			r@ codebase -  dup 32766 <			IF asm-number ! asm_reg_org asm-areg !				efacode_n(Ar)			ELSE drop\ Try relative to 64K+ reg				r@ codebase 32768 98304 within?				IF r@ codebase - 65536 - asm-number !					asm_reg_64k asm-areg !					efacode_n(Ar)				ELSE rdrop 16 asm.error				THEN			THEN		THEN	ELSE r@ asm-number !  efacode_absl	THEN rdrop;: ASM.PARSE.SYMBOL ( -- code )\ Save value of symbol	$asm-bfr1 FIND	IF 	asm.exec.val		asm.addr>efa	ELSE count asm.strip.base		$asm-bfr3 off  $asm-bfr3 $append		$asm-bfr3 asm.number?		IF drop asm-number ! efacode_absl		ELSE $type cr 14 asm.error		THEN		decimal	THEN;: ASM.PARSE.SYM/REG ( -- code )    $asm-bfr1 c@ 2 =    IF ( might be reg, check number )        $asm-bfr1 2+ c@ 10 digit        IF ( -- reg# )        	$asm-bfr1 1+ c@        	CASE        	ascii D OF asm-dreg ! efacode_Dr ENDOF        	ascii A OF asm-areg ! efacode_Ar ENDOF        	ascii @ OF asm-number ! efacode_local ENDOF        	  drop asm.parse.symbol        	ENDCASE        ELSE asm.parse.symbol        THEN    ELSE  asm.parse.symbol    THEN;: ASM.PARSE.OP   ( -- code , parse operand in $asm-bfr1 )    $asm-bfr1 count ascii ( scan dup    IF ( addr count , of remainder , found one! )        ascii , scan nip        IF  $asm-bfr1 count " (PC," count match?            IF	efacode_n(PC,Dr)            	asm.get.offset            	$asm-bfr1 c@ 2- asm.grab.reg# asm-dreg !            ELSE efacode_n(Ar,Dr)            	asm.get.offset            	$asm-bfr1 c@ 2- asm.grab.reg# asm-dreg !            	$asm-bfr1 c@ 5 - asm.grab.reg# asm-areg !            THEN        ELSE asm.parse.no,        THEN    ELSE 2drop $asm-bfr1 1+ c@ ascii # =    	IF efacode_#n asm.get.imm    	ELSE decimal $asm-bfr1 asm.number?    		IF drop asm-number ! cr efacode_absl    		ELSE asm.parse.sym/reg    		THEN    	THEN    THEN;: ASM.SPLIT.OPS  ( -- , parse operand in buffer )    asm-()nest off    $asm-bfr2 off    asm-in-[] off\ first split apart the two operands    $asm-bfr1 c@ 1+ 1    DO  $asm-bfr1 i + c@        CASE        ascii , OF  asm-()nest @ 0=                    asm-in-[] @ 0= AND                    $asm-bfr2 @ 0= AND                    IF  $asm-bfr1 count i - swap i +                        swap dup $asm-bfr2 c!                        $asm-bfr2 1+ swap cmove                        i 1- $asm-bfr1 c!  ( truncate src )                    THEN                ENDOF        ascii ( OF 1 asm-()nest +! ENDOF        ascii ) OF -1 asm-()nest +! ENDOF        ascii [ OF asm-in-[] on ENDOF        ascii ] OF asm-in-[] off ENDOF        ENDCASE    LOOP    asm-()nest @    IF 1 asm.error    THEN;: ASM.DUMP.OP  ( -- , report on results of parsing op )    >newline ." ---------------------" cr    ."  code = " asm-code @ .bin cr    ."  areg = " asm-areg @ .hex cr    ."  dreg = " asm-dreg @ .hex cr    ."  numb = " asm-number @ .hex cr;: ASM.PARSE.OPS  ( -- #operands )    asm.get.ops    asm.split.ops    0 asm-src/dst !    asm.parse.op asm-code !  \ asm.dump.op    $asm-bfr2 c@ 0=    IF	1  ( operand )    ELSE    	$asm-bfr2 $asm-bfr1 $move	    1 asm-src/dst !    	asm.parse.op asm-code !  \ asm.dump.op    	2 ( operands )    THEN    0 asm-src/dst !;: ASM.PARSE.1OP  ( -- )    asm.parse.ops 1 -    IF	2 asm.error    THEN;: ASM.PARSE.2OP  ( -- )    asm.parse.ops 2 <    IF	2 asm.error    THEN;: ASM.LAY.IMM  ( -- , lay down immediate data after opcode )	asm-number @	asm-size @ ascii L =	IF asm,	ELSE asmw,	THEN;\ Compile different opcodes: ASM.EFA.OR  ( mode-shift reg-shift -- , compile effective address )	asm-code @ asm.code>rm ( ms rs r m )	>r swap shift asm.or	r> swap shift asm.or\	asm-code @	CASE	EFACODE_Dr	OF asm-dreg @ asm-areg ! ENDOF \ for proper efa	EFACODE_n(Ar)	OF asm-number @ asmw, ENDOF	EFACODE_n(Ar,Dr)	OF		asm-number @ -128 127 within?		IF			asm-number @ $ FF and			1 11 shift OR \ !!!!!! this should be a size field			asm-dreg @ 12 shift OR			asmw,		ELSE			16 asm.error		THEN	ENDOF	EFACODE_ABSW	OF asm-number @ asmw, ENDOF	EFACODE_ABSL	OF asm-number @ asm, ENDOF	EFACODE_n(PC)	OF asm-number @ asmw, ENDOF	EFACODE_n(PC,Dr)	OF		asm-number @ -128 127 within?		IF			asm-number @ $ FF and			asm-dreg @ 12 shift OR			asmw,		ELSE			16 asm.error		THEN	ENDOF	EFACODE_#n		OF asm.lay.imm  ENDOF	ENDCASE;: ASM.DST/SRC,  ( opcode -- , xxxx,drr,dmm,smm,srr )	asm-opcode w!	0 asm-src/dst !	3 0 asm.efa.or	1 asm-src/dst !	6 9 asm.efa.or;: ASM.MOVE.  ( mask <operands> -- )\ Move instruction, 2 operands	asm.parse.2op	drop asm-size @	CASE	    0       OF $ 2000 ENDOF	    ascii L OF $ 2000 ENDOF	    ascii W OF $ 3000 ENDOF	    ascii B OF $ 1000 ENDOF	    3 asm.error	ENDCASE	asm.dst/src,;: ASM_SIZE_MASK  ( -- sizemask )    asm-size @	CASE	    ascii L OF 2 ENDOF	    ascii W OF 1 ENDOF	    ascii B OF 0 ENDOF		2 swap ( default )	ENDCASE;: ASM.OP.SD.EA ( opcode s/d -- , lay efa at end )    asm-src/dst !    asm-opcode w!    3 0 asm.efa.or;: ASM.TYPE1  ( mask -- )	asm.parse.2op	asm_size_mask 6 shift or \ determine whether source or dest is Dr    1 asm-codes @ 0=    IF 	1 asm-dregs @ 9 shift or    	0    ELSE 0 asm-codes @ 0=        IF 	$ 100 or  ( direction bit )    		0 asm-dregs @ 9 shift or    		1        ELSE 4 asm.error        THEN    THEN    asm.op.sd.ea;: ASM.TYPE2  ( mask -- )	asm.parse.2op	asm_size_mask 6 shift or\ check if dest is Dr    1 asm-codes @ efacode_Dr <>    IF  6 asm.error    THEN    1 asm-dregs @ 9 shift or    0 asm.op.sd.ea;    : ASM.TYPE3  ( mask -- , EOR )	asm.parse.2op	asm_size_mask 6 shift or\ check if src is Dr    0 asm-codes @ efacode_Dr <>    IF 7 asm.error    THEN   	0 asm-dregs @ 9 shift or    1 asm.op.sd.ea;: ASM.TYPE4  ( mask -- )\ ASL , three types of addressing	asm_size_mask 6 shift or	asm.parse.ops 1 =	IF ( -- mask , MEMORY SHIFT )		$ C0 or    	asm-opcode w!    	3 0 asm.efa.or	ELSE  ( -- mask , register shift )\ determine if src is Dr    	0 asm-codes @ 0=    	IF  $ 20 or  ( specify DATA REG )    		0 asm-dregs @ 9 shift or    	ELSE 0 asm-codes @ efacode_#n =    		IF asm-number @ 7 and 9 shift or    		ELSE 10 asm.error    		THEN    	THEN    	1 asm-dregs @ or    	asm-opcode w!    THEN;: ASM.TYPE5  ( mask -- , ADDA , SUBA )	asm.parse.2op\ determine whether dest is Areg    1 asm-codes @ efacode_Ar <>    IF 8 asm.error    THEN    asm-size @ ascii L =    IF % 111    ELSE % 011    THEN 6 shift or    1 asm-aregs @ 9 shift or    0 asm.op.sd.ea;: ASM.TYPE6  ( mask -- , ADDI, SUBI )	asm.parse.2op	asm_size_mask 6 shift or\ determine whether source is #n    0 asm-codes @ efacode_#n <>    IF  11 asm.error    THEN    asm.lay.imm    1 asm.op.sd.ea;: ASM.TYPE7  ( mask -- , ADDQ, SUBQ )	asm.parse.2op	asm_size_mask 6 shift or  \ determine whether source is #n    0 asm-codes @ efacode_#n <>    IF  11 asm.error    THEN    asm-number @ 1 7 within?    IF asm-number @ 9 shift or    ELSE 13 asm.error    THEN    1 asm.op.sd.ea;: ASM.TYPE8  ( index -- , RTS, NOP , just use mask )	asm-opcode w!;: ASM.CHECK.LOCAL  ( $addr -- index , abort if bad )	dup w@ $ 0240 =	swap 2+ c@ ascii 0 - dup>r	0 9 within? AND not	IF 12 asm.error	THEN	r>;: ASM.BRANCH.LOCAL  ( -- , handle branch to local label )\ get  label # in and store in array	$asm-bfr1 asm.check.local	asm_#branches @ ->a asm_unrb_dests  \ save local#\\ store size in array	asm-size @	CASE		ascii S OF 1 ENDOF		ascii W OF 0 asmw, 2 ENDOF  \ save space		0      OF 0 asmw, 2 ENDOF		ascii L OF ." Long Branch not on 68000" asm.abort ENDOF		." Illegal Branch Size" asm.abort	ENDCASE	negate asm_#branches @ ->a asm_unrb_sizes        \ save -size\\ save addr and increment counter	here asm_#branches @ ->a asm_unrb_addrs	asm_#branches @ 1+ dup asm_max_branches >	IF ." Too many Branches!" asm.abort	THEN	asm_#branches !;: ASM.BRANCH.SYMBOL  ( -- , branch to CFA of symbol )\ Save value of symbol	$asm-bfr1 FIND	IF \ calc relative branch 		here - 2- dup abs 32766 <		IF asmw,		ELSE ." Branch out of range!" cr asm.abort		THEN	ELSE ." Could not find " $type cr asm.abort	THEN;: ASM.TYPE9 ( mask -- , handle Branch )	asm.get.ops	asm-opcode w!		$asm-bfr1 w@ $ 0240 =  \ start with @	IF asm.branch.local	ELSE asm.branch.symbol	THEN;: ASM.TYPE10  ( mask -- , CLR, TST )	asm.parse.ops drop	asm_size_mask 6 shift or	0 asm.op.sd.ea;: ASM.TYPE11  ( mask -- , SWAP )	asm.parse.ops drop	0 asm-codes @ efacode_Dr <>	IF 7 asm.error	THEN	asm-dreg @ or    asm-opcode w!;: ASM.TYPE12  ( mask -- , MULS, MULU )	asm.parse.2op\ determine dest is Dr    1 asm-codes @ efacode_Dr =    IF 	1 asm-dregs @ 9 shift or    ELSE 6 asm.error    THEN    0 asm.op.sd.ea;    : ASM.TYPE13  ( mask -- , LEA )	asm.parse.2op\ determine dest is Ar    1 asm-codes @ efacode_Ar -    IF 	8 asm.error    THEN    1 asm-aregs @ 9 shift or    0 asm.op.sd.ea;: ASM.TYPE14  ( mask -- , LINK )	asm.parse.2op\ determine source is Ar    0 asm-codes @ efacode_Ar =    IF 	0 asm-aregs @ or    	asm-opcode w!		1 asm-src/dst !		asm-code @ efacode_#n =		IF asm-number @ asmw,		ELSE ." Offset must be Immediate!" asm.abort		THEN    ELSE 8 asm.error    THEN;: ASM.TYPE15  ( mask -- , UNLK )	asm.parse.ops drop\ determine source is Ar    0 asm-codes @ efacode_Ar =    IF 	0 asm-aregs @ or    	asm-opcode w!    ELSE 9 asm.error    THEN;: ASM.TYPE16  ( mask -- , EXT )	asm.parse.ops drop	0 asm-codes @ efacode_Dr <>	IF 7 asm.error	THEN	asm-dreg @ or	ASM-size @	CASE		ascii W OF % 010 ENDOF		ascii L OF % 011 ENDOF		." Illegal on 68000" asm.abort	ENDCASE	6 shift or    asm-opcode w!;: ASM.TYPE17 ( mask -- , handle DBcc )	asm.parse.2op	0 asm-codes @ efacode_Dr <>	IF 7 asm.error	THEN	0 asm-dregs @ or	asm-opcode w!\\ store label # in array	$asm-bfr1 asm.check.local	asm_#branches @ ->a asm_unrb_dests  \ save local#\\ store size in array	0 asmw, -2	asm_#branches @ ->a asm_unrb_sizes        \ save -size\\ save addr and increment counter	here asm_#branches @ ->a asm_unrb_addrs	asm_#branches @ 1+ dup asm_max_branches >	IF ." Too many Branches!" asm.abort	THEN	asm_#branches !;: ASM.TYPE18 ( mask -- , lay down number DC.W or DC.L )	0 asm-offset, !	drop asm.parse.1op	asm.lay.imm;: ASM.TYPE19 ( mask -- , JSR, JMP )	asm.parse.1op	0 asm.op.sd.ea;: ASM.TYPE20  ( mask -- , MOVEQ )	asm.parse.2op\ determine whether source is #n    0 asm-codes @ efacode_#n <>    IF  11 asm.error    THEN\ check if dest is Dr    1 asm-codes @ efacode_Dr <>    IF  6 asm.error    THEN    1 asm-dregs @ 9 shift or \ OR register\ check range of immediate	0 asm-numbers @	dup -128 127 within?	IF		$ 7F and or asm-opcode w!	ELSE		13 asm.error	THEN;: ASM.TYPE21  ( mask -- , BSET , BTST )	asm.parse.2op\ determine whether source is #n    0 asm-codes @ efacode_#n =    IF		ascii W asm-size !		asm.lay.imm		$ 0800 or \ static		1 asm.op.sd.ea    ELSE\ check if src is Dr    	0 asm-codes @ efacode_Dr <>    	IF  6 asm.error    	ELSE			0 asm-dregs @ 9 shift or \ dynamic			$ 0100 or			1 asm.op.sd.ea		THEN	THEN;\ ================================================================: ASM.RESOLVE.BRANCHES  ( -- , resolve any locals )	asm_#branches @ 0	DO  i asm_unrb_addrs  ( get address )		dup w@  ( get opcode + info )		i asm_unrb_dests asm_local_labels		( -- addr opcode local_addr )		dup 0=		IF ." Unresolved local branch!" asm.abort		THEN		i asm_unrb_sizes dup 8 >		IF \ relative branch			>r 2 pick - 2- r> $ FFFFFF00 or			negate 1 =			IF ( byte displacement )				dup -128 126 within?				IF ( -- addr opcode rel )					$ 00FF and					swap $ FF00 and OR					swap w!				ELSE ." Branch too far!" asm.abort				THEN			ELSE dup -32768 32766 within?				IF ( -- addr opcode rel )					2 pick 2+ w!  ( save 16 bit offset )					swap w!				ELSE ." Branch too far!" asm.abort				THEN			THEN		ELSE ." Absolute Jumps not yet supported!" asm.abort		THEN	LOOP	0 asm_#branches !;				: ASM.MATCH  ( incode -- index | -1 )    -1 swap    asm-#opcodes @ 0    DO	dup i asm_names =        IF nip i swap LEAVE        THEN    LOOP drop;: ASM.EXEC  ( index -- , execute proper assembly for opcode )	2 asm-offset, !	0 asm-src/dst !	dup asm_masks swap asm_types	CASE		0 OF asm.move. ENDOF  \ move		1 OF asm.type1 ENDOF  \ add, or		2 OF asm.type2 ENDOF  \ cmp		3 OF asm.type3 ENDOF  \ eor		4 OF asm.type4 ENDOF  \ asl, asr		5 OF asm.type5 ENDOF  \ adda, suba		6 OF asm.type6 ENDOF  \ addi, subi		7 OF asm.type7 ENDOF  \ addq, subq		8 OF asm.type8 ENDOF  \ rts, nop		9 OF asm.type9 ENDOF  \ Bcc		10 OF asm.type10 ENDOF  \ clr, tst		11 OF asm.type11 ENDOF  \ swap		12 OF asm.type12 ENDOF  \ mulu, muls		13 OF asm.type13 ENDOF  \ lea		14 OF asm.type14 ENDOF  \ link		15 OF asm.type15 ENDOF  \ unlk		16 OF asm.type16 ENDOF  \ ext		17 OF asm.type17 ENDOF  \ DBcc		18 OF asm.type18 ENDOF  \ dc		19 OF asm.type19 ENDOF  \ JSR, JMP		20 OF asm.type20 ENDOF  \ MOVEQ		21 OF asm.type21 ENDOF	\ BSET, BTST		dup . ." Unrecognized OpCode Type - HMSL Bug!" asm.abort	ENDCASE	asm.laydown;: ASM.GET.LABEL ( -- , process local label )	bl word asm.check.local	here swap ->a asm_local_labels;host=mac .IF: ASM.GETLINE	FSOURCE @	IF fquery	ELSE >newline query	THEN;.THEN: ASM.DOLINE  ( -- done? )	asm.getline	$asm-bfr1 off $asm-bfr2 off $asm-bfr3 off\ is the first column a label?	tib >in @ + c@ ascii @ =	IF asm.get.label	THEN\ is the first column a \ comment	tib >in @ + c@ ascii \ =	IF		false	ELSE		bl word dup c@ 0>		IF \ dup $TYPE cr			dup " END-CODE" $= dup not			IF	swap asm.pack.name				asm-size ! asm.match dup 0< ( match opcode )			    IF  ." Invalid opcode." asm.abort			    ELSE asm.exec			    THEN			ELSE nip			THEN		ELSE drop false		THEN	THEN;: CODE  ( <name> -- , start assembly )    asm-state @ warning" CODE - previous definition did not complete!"    :  ( start definition ) [compile] \    asm-rts? off	0 asm_#branches !	10 0 DO 0 i ->a asm_local_labels LOOP \ clear em all	here\    BEGIN		depth >r    	asm.doline		depth 1- r> - abort" Stack depth changed in assembler!"    UNTIL\	asm.resolve.branches    unsmudge    asm-rts? @ 0=    IF $ 4e75 w,    THEN\\ set size for INLINE and optimizer	here swap -  2- ( size-RTS ) 254 min	latest nfa->sfa c!\    [compile] [;: ASM CODE ;  \ alias