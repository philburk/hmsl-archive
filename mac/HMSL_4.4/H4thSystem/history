\ Command Line History\ Provide Shell like History for JForth\\ Useful words for you to know are:\ HISTORY.ON   HISTORY.OFF\ HISTORY\\ Author: Phil Burk\ Copyright 1988 Phil Burk\\ MOD: PLB 1/22/98 Fixed bad comment in HISTORY.RESET\ MOD: PLB 2/13/89 Use value of EXPECT as flag for ON/OFF.\ NOD: PLB 11/13/89 Convert to H4thANEW TASK-HISTORYdecimalvariable BSOUT8 bsout !variable BSIN8 bsin !.NEED ODDW@   ( this should be in kernal ): ODDW@ ( addr -- w )    dup c@ 8 shift    swap 1+ c@ or;.THEN.NEED ODDW!   ( this should be in kernal ): ODDW! ( w addr -- )	over -8 shift over c!	1+ c!;.THEN\ You can expand the history buffer by increasing this constant!!!!!!!!!!512 constant KH_HISTORY_SIZEcreate KH-HISTORY kh_history_size allot\ An entry in the history buffer consists of\   a Count byte = N,\   N chars,\   16 bit line number,\   another Count byte = N\\ The most recent entry is put at the beginning,\ older entries are shifted up.: KH-END ( -- addr , end of history buffer )    kh-history kh_history_size +;variable KH-LOOK   ( index of history line , point to count )variable KH-LINES  ( count of lines back )variable KH-COUNT  ( temporary storage )variable KH-MAXvariable KH-COUNTER ( 16 bit counter for line # )variable HIGHLIGHT-INPUT  ( if true, input in f:3 )variable KH-MATCH-SPAN  ( span for matching on shift-up )highlight-input on  ( turn on as default !! ): KH.MAKE.ROOM ( N -- , make room for N more bytes at beginning)    >r  ( save N )    kh-history dup r@ + ( source dest )    kh_history_size r> - 0 max move;: KH.RECENT.LINE  ( -- addr count , most recent line )    kh-history count;: KH.CURRENT.ADDR ( -- $addr , count byte of current line )    kh-look @ kh-history +;: KH.CURRENT.LINE ( -- addr count )    kh.current.addr count;: KH.COMPARE ( addr count -- flag , true if redundant )    kh.recent.line nip =    IF  kh.recent.line compare 0=    ELSE drop false    THEN;: KH.NUM.ADDR ( -- addr , address of current line count )    kh.current.line +;: KH.CURRENT.NUM ( -- # , number of current line )    kh.num.addr oddw@;: KH.ADDR++  ( $addr -- $addr' , convert one kh to previous )    count + 3 +;: KH.ADDR--  ( $addr -- $addr' , convert one kh to next )    dup 1- c@ - cell-;: KH.ENDCOUNT.ADDR ( -- addr , address of current end count )    kh.num.addr 2+;: KH.ADD.LINE ( addr count -- )    dup 256 >    IF ." KH.ADD.LINE - Too big for history!" 2drop    ELSE   ( add to end )\ Compare with most recent line.        2dup kh.compare        IF 2drop        ELSE            >r ( save count )\ Set look pointer to point to first count byte of last string.            0 kh-look !            r@ cell+ kh.make.room\ Set count bytes at beginning and end.            r@ kh-history c!  ( start count )            r@ kh.endcount.addr c!            kh-counter @ kh.num.addr oddw!  ( line )\ Number lines modulo 1024	    kh-counter @ 1+ $ 3FF and kh-counter !            kh-history 1+   ( calc destination )            r> cmove  ( copy chars into space )        THEN    THEN;: KH.BACKUP.LINE  ( -- atend? , advance KH-LOOK if in bounds )    true  ( default flag, at end of history )\ KH-LOOK points to count at start of current line    kh.current.addr c@ ( -- count )    IF  kh.current.addr kh.addr++ kh-end <        IF  kh.current.addr kh.addr++ kh-history - kh-look !            1 kh-lines +!            drop false        THEN    THEN;: KH.PREVIOUS.LINE ( -- addr count | 0 , find previous line in history )    kh.current.line    kh.backup.line    IF 2drop 0    THEN;: KH.FORWARD.LINE ( -- atstart? )\ KH-LOOK points to count at start of current line    kh-lines @ 0>    IF  kh.current.addr kh.addr--	kh-history - kh-look !        -1 kh-lines +! false    ELSE        kh-lines off        0 kh-look ! true    THEN;: KH.NEXT.LINE ( -- addr count | 0 , find next line if there )    kh.forward.line    IF 0    ELSE kh.forward.line         IF 0         ELSE kh.current.line kh.backup.line drop        THEN    THEN;: KH.OLDEST.LINE   ( -- addr count | 0, oldest in buffer )    BEGIN kh.backup.line    UNTIL    kh-lines @    IF  kh.forward.line drop kh.current.line    ELSE 0    THEN;: KH.EMITBS  ( -- , emit backspace sequence )	backspace;: ?WAIT  ( -- )    ?terminal    IF  key drop f:2 ."  ?q" f:1        key $ 20 or ( convert to lower case ) ascii q =        IF  abort        THEN        3 tio.backwards tio.erase.eol    THEN;: HISTORY# ( -- , dump history buffer with numbers)    cr kh.oldest.line ?dup    IF  BEGIN kh.current.num 3 .r ." ) " type ?wait cr            kh.forward.line 0=        WHILE kh.current.line        REPEAT    THEN;: HISTORY ( -- , dump history buffer )    cr kh.oldest.line ?dup    IF  BEGIN type ?wait cr            kh.forward.line 0=        WHILE kh.current.line        REPEAT    THEN;: KH.FIND.LINE ( -- $addr )    BEGIN kh.current.num over -    WHILE kh.backup.line        IF ." Line not in History Buffer!" cr drop 0 exit        THEN    REPEAT    drop kh.current.addr;: XX  ( line# -- , execute line x of history )    kh.find.line ?dup    IF count $interpret    THEN;   variable KH-CURSOR ( points to next insertion point )variable KH-ADDRESS  ( address to store chars ): KH-BUFFER ( -- buffer )    kh-address @;: KH.RETURN ( -- , move to beginning of line )    0 out !;: KH.REPLACE.LINE  ( addr count )    kh.return    tio.erase.eol    dup span !    dup kh-cursor !    2dup kh-buffer swap cmove    highlight-input @ IF f:3 THEN    type    highlight-input @ IF f:1 THEN;: KH.SHIFT.UP.ARROW ( -- , search for line with same start )    kh-match-span @ 0=  ( keep length for multiple matches )    IF span @ kh-match-span !    THEN    BEGIN kh.previous.line    WHILE kh-buffer kh-match-span @ text=        IF kh.forward.line drop kh.current.line kh.replace.line           kh.backup.line drop exit        THEN    REPEAT;: KH.SHIFT.RIGHT.ARROW    span @ kh-cursor @ - dup 0>    IF tio.forwards        span @ kh-cursor !    ELSE drop    THEN;: KH.SHIFT.LEFT.ARROW ( -- )    kh.return    kh-cursor off;: KH.UP.ARROW ( -- , goto previous line )    kh.previous.line ?dup    IF kh.replace.line    THEN;: KH.DOWN.ARROW ( -- , next line )    kh.next.line ?dup    IF kh.replace.line    ELSE tib 0 kh.replace.line    THEN;: KH.SHIFT.DOWN.ARROW ( -- , next line )    kh-look off	kh-lines off	tib 0 kh.replace.line;: KH.RIGHT.ARROW    kh-cursor @ span @ <    IF 1 kh-cursor +!       1 tio.forwards    THEN;: KH.LEFT.ARROW ( -- )    kh-cursor @ ?dup    IF 1- kh-cursor !       1 tio.backwards    THEN;: KH.REFRESH  ( -- , redraw current line as is )    13 emit  ( true return )    highlight-input @ IF f:3 THEN    kh-buffer span @ type out @    highlight-input @ IF f:1 THEN    13 emit kh-cursor @ ?dup     IF tio.forwards    THEN out !;21 ARRAY FKEY-VECTORS  ( f0 not used, f1-f20 ): EXEC.FKEY  ( # -- , do function )    fkey-vectors @execute flushemit;: LIST.FKEYS ( -- )    >newline ." Function key assignments." cr    20 1 DO        i fkey-vectors @ dup ' noop -        IF  i 1- 10 /mod            IF ."   Shift-F" 1+ .            ELSE 8 spaces ASCII F emit 1+ .            THEN ."  = " >name id. cr        ELSE drop        THEN    LOOP cr;    : KH.SPECIAL.KEY ( char -- , handle fkeys or arrows )	?shift   ( check to see if shift key was held down )	IF $ 10 -	THEN	CASE		$ E OF kh.shift.up.arrow    ENDOF			0 kh-match-span ! ( reset if any other key )		$ 1E OF kh.up.arrow    ENDOF		$ 1F OF kh.down.arrow  ENDOF		$ 1D OF kh.right.arrow ENDOF		$ 1C OF kh.left.arrow  ENDOF		$ F OF kh.shift.down.arrow  ENDOF		$ D OF kh.shift.right.arrow ENDOF		$ C OF kh.shift.left.arrow  ENDOF	ENDCASE;: SMART.KEY ( -- char )    BEGIN  key        dup $ 1c $ 1f within?    WHILE kh.special.key    REPEAT;: KH.BACKSPACE ( -- , backspace character from buffer and screen )    kh-cursor @ ?dup  ( past 0? )    IF  span @ <        IF  ( inside line )            1 tio.backwards            1 tio.delete            kh-buffer kh-cursor @ +  ( -- source )            dup 1- ( -- source dest )            span @ kh-cursor @ - cmove\            ." Deleted!" cr         ELSE            kh.emitbs        THEN        -1 span +!        -1 kh-cursor +!    ELSE bell    THEN;: KH.DELETE ( -- , forward delete )    kh-cursor @ span @ <  ( before end )    IF  ( inside line )        1 tio.delete        kh-buffer kh-cursor @ + 1+ ( -- source )        dup 1- ( -- source dest )        span @ kh-cursor @ - 0 max cmove        -1 span +!    THEN;: KH.CONTROLX ( -- , kill line )    kh.return  ( true carriage return )    span @ 0 DO 1 tio.delete LOOP    kh-cursor off span off out off;        : KH.INSCHAR  ( char -- )    kh-cursor @ span @ <    IF  ( inside line )        1 tio.insert\ Move characters up        kh-buffer kh-cursor @ +  ( -- source )        dup 1+ ( -- source dest )        span @ kh-cursor @ - cmove>    THEN    highlight-input @ IF f:3 THEN    dup emit    highlight-input @ IF f:1 THEN    kh-buffer kh-cursor @ + c!    1 kh-cursor +!    1 span +!;: $>EXPECT ( $address -- , insert a string into input stream )    count kh-max @ span @ - min 0    DO dup i + c@ kh.inschar    LOOP drop;: KH.GETLINE ( max -- )    kh-max !    span off    kh-cursor off    0 kh-look !    0 kh-match-span !    BEGIN        kh-max @ span @ >        IF  smart.key dup 13 -  ( <cr?> )        ELSE 0 false        THEN  ( -- char flag )    WHILE ( -- char )        CASE        bsin @ OF ?shift			IF kh.delete    ( shift-delete = delete-forward )			ELSE kh.backspace			THEN		ENDOF        127  OF kh.delete ENDOF        24   OF kh.controlx ENDOF        dup kh.inschar        ENDCASE    REPEAT drop    span @ kh-cursor @ - ?dup    IF 1+ tio.forwards  ( move to end of line )    ELSE space    THEN    flushemit;: KH.EXPECT ( addr max -- )    swap kh-address !    kh-lines off    kh.getline    span @ 0>    IF kh-buffer span @ kh.add.line    THEN;: HISTORY.ON ( -- , install history vectors )    what's expect ' (expect) =    IF ' kh.expect is expect    THEN;: HISTORY.OFF ( -- , deinstall )    what's expect ' kh.expect =    IF ' (expect) is expect    THEN;: HISTORY.RESET  ( -- , reset vectors and clear table )    kh-history kh_history_size erase    kh-counter off;: AUTO.INIT    auto.init    history.on;if.forgotten history.offhistory.resethistory.on