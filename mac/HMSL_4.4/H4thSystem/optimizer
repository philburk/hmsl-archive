\ Optimize compilation using various techniques.\\ This first level head tail optimizer, has a problem with HERE.\ HERE can move when you lay down code.\\ *********************************************************************\ * HMSL Forth System                                                 *\ * Author: Phil Burk                                                 *\ * Copyright 1989 Phil Burk , All Rights Reserved                    *\ *********************************************************************ANEW TASK-OPTIMIZER\									I/O		Sums	Threads	Search\ Before optimization:				2.60	2.60	1.91	4.56\ Variables and Constants\ use ALITERAL and LITERAL			2.68	2.16	1.90	5.01\ VARIABLE uses LEA\ changed benchmark to use variable			2.05	1.91	4.93	( not standard \ Changed constant to use MOVEQ		2.71	1.75	1.91	4.95\ Added Head Tail Optimization		2.58	1.65	1.91	4.96defer OLD.COMPILE_INLINE  ( size cfa -- )defer OLD.COMPILE_NFA_INLINE  ( size nfa -- )defer OLD.HERE	( -- here )$ 2D00 constant PUSH_D0_CODE$ 201E constant POP_D0_CODE$ 2D08 constant PUSH_A0_CODE$ 205E constant POP_A0_CODE\ flags defined in name header4 constant FLAG_HEAD8 constant FLAG_TAIL16 constant FLAG_INLINE\ Information stored from last call to COMPILE_INLINEvariable OPT-LAST-HEREvariable OPT-LAST-SIZEvariable OPT-LAST-CFAvariable OPT-THIS-SIZEvariable OPT-THIS-CFAvariable OPT-TEMP-DISABLEvariable LAST-HERE: :  ( <name> -- , redefine : to save here )	:  ( do old )	here last-here !;: ;  ( -- , redefine ; , set size field )	last-here @ ?dup	IF	here swap - 255 min		latest nfa->sfa c!		last-here off   ( only do this for colon definitions )	THEN	[compile] ;; immediate: SET.INLINE  ( -- , force previous word to be copied inline )	latest nfa->ffa dup c@ flag_inline or	swap c!;: FORCE.INLINE set.inline ;: TAILFLAG?  ( nfa -- flag , true if tail set )	nfa->ffa c@ flag_tail and 0= 0=;: HEADFLAG?  ( nfa -- flag , true if head set )	nfa->ffa c@ flag_head and 0= 0=;: SET.TAIL  ( -- , set flag in latest )	latest nfa->ffa dup c@ flag_tail or	swap c!;: SET.HEAD  ( -- , set flag in latest )	latest nfa->ffa dup c@ flag_head or	swap c!;: OPT.CRUNCH.2,2  ( -- , remove last opcode and next opcode )	-2 opt-this-size +!	2 opt-this-cfa +!	-2 allot;: OPT.COMPILE_INLINE  ( size cfa -- , remove redundant code at boundary )	opt-this-cfa !	opt-this-size !	opt-temp-disable @ 0= 	opt-last-here @ opt-last-size @ + here - 0=   AND	IF  ( we have two contiguous instructions )		here 2- w@  ( last opcode )		dup push_d0_code =		IF drop opt-this-cfa @ w@ pop_d0_code =			IF	opt.crunch.2,2			THEN		ELSE push_a0_code =			IF opt-this-cfa @ w@ pop_a0_code =				IF	opt.crunch.2,2				THEN			THEN		THEN	THEN	opt-this-size @ dup opt-last-size !	opt-this-cfa @ dup opt-last-cfa !	here opt-last-here !	old.compile_inline	opt-temp-disable off;: OPT.COMPILE_NFA_INLINE  ( size nfa -- , we get a chance to examine HT flags )	dup >r dup headflag?  ( head optimizable! )	IF  nfa->cfa opt.compile_inline	ELSE old.compile_nfa_inline	THEN	r> tailflag? 0= opt-temp-disable !  ( if no tail flag, disable next opt );: OPT.HERE  ( -- , disable optimization if here called )	old.here	opt-temp-disable on;variable IF-OPTIMIZE: OPTIMIZER.ON  ( -- )	if-optimize @ 0=	IF	what's compile_inline is old.compile_inline		'c opt.compile_inline is compile_inline		what's compile_nfa_inline is old.compile_nfa_inline		'c opt.compile_nfa_inline is compile_nfa_inline		what's here is old.here		'c opt.here is here		if-optimize on	THEN;: OPTIMIZER.OFF  ( -- )	if-optimize @	IF	what's old.compile_inline is compile_inline		what's old.compile_nfa_inline is compile_nfa_inline		what's old.here is here		if-optimize off	THEN;." Optimizer turned on!" cr optimizer.onif.forgotten optimizer.off