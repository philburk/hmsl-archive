\ HMSL Text Editor using HMSL's Low Level TextEdit Toolbox\\ Author: Phil Burk\ Copyright 1990\ ALl Rights Reserved\\ MOD: PLB 10/19/90 Add keyUpEvt trap\ MOD: PLB 11/26/90 Flush Volume after FCLOSE, add TYPEFILE\ MOD: PLB 12/90 converted to simple one huge block format.\ MOD: PLB 2/13/91 Add EOL at end if none when file opened.\ MOD: PLB 5/30/91 Add RSI test, add cursor type based on position,\		force visible after each char.\ MOD: PLB 6/25/91 Stub TX.MIDI.OFF if MIDI not loaded so we can move TX down\ MOD: PLB 8/7/91 Add UNDO\ 00001 PLB 11/20/91 Make command-G work when dialog down.\ 00002 PLB 1/13/92 Added support for FILE?, Read Only\ 00003 PLB 2/21/92 Close FIND window after successful FIND\ 00004 PLB 7/8/92 Added FontSize menu.false .IFThings to add	triple click	ibeam for FIND windowOptional tasks	Save All Command	Include from Clipboard.THENdecimalANEW TASK-TextEditor\ TXED Window Management Data Structures ---------------------------------------windowTemplate TX-NewWindowfalse .IF:STRUCT WindowTracker	aptr	wt_EVHandler	aptr	wt_MDHandler	aptr	wt_Window;STRUCT.THEN:STRUCT	TxEdWindow	struct	DoubleNode	txed_node	struct	windowTracker txed_tracker	aptr	txed_header	long	txed_vrefnum		\ volume reference number for file	aptr	txed_scroll		\ handle for scroll bar	byte	txed_saveable	\ true if name known for save	byte	txed_reserved	\ 0 if no changes since opened	128 bytes txed_filename	\ name of file;STRUCTDoubleList TX-LIST   \ list of TxEdWindow structuresvariable	TX-CUR-TEW  \ current TxEdWindowvariable	TX-IF-INIT129 constant FILE_MENU_ID130 constant EDIT_MENU_ID131 constant INCLUDE_MENU_ID132 constant FONTSIZE_MENU_ID \ 00004135 constant WINDOW_MENU_IDvariable	FILE-MENU-HANDLEvariable	EDIT-MENU-HANDLEvariable	INCLUDE-MENU-HANDLEvariable	FONTSIZE-MENU-HANDLEvariable	WINDOW-MENU-HANDLErect txVRectrect txsbRect	\ Rect for Scroll Bar\ Declare Menu Item #s\ File Menu1 constant TX_NEW_ITEM2 constant TX_OPEN_ITEM4 constant TX_CLOSE_ITEM5 constant TX_SAVE_ITEM6 constant TX_SAVEAS_ITEM\ Edit Menu1 constant TX_UNDO_ITEM3 constant TX_CUT_ITEM4 constant TX_COPY_ITEM5 constant TX_PASTE_ITEM6 constant TX_CLEAR_ITEM13 constant TX_UPPER_ITEM14 constant TX_LOWER_ITEM15 constant TX_SMART_ITEM17 constant TX_SIZE_ITEM \ 00004: TX.DISABLE.FILE  ( item# -- disable item in file menu )	file-menu-handle @ swap DisableItem();: TX.ENABLE.FILE  ( item# -- enable item in file menu )	file-menu-handle @ swap EnableItem();: TX.DISABLE.EDIT  ( item# -- disable item in EDIT menu )	EDIT-menu-handle @ swap DisableItem();: TX.ENABLE.EDIT  ( item# -- enable item in EDIT menu )	EDIT-menu-handle @ swap EnableItem();: TX.DISABLE.INCLUDE  ( item# -- disable item in include menu )	include-menu-handle @ swap DisableItem();: TX.ENABLE.INCLUDE  ( item# -- enable item in include menu )	include-menu-handle @ swap EnableItem();: TX.DISABLE.WMENU  ( item# -- disable item in WIndow menu )	WINDOW-menu-handle @ swap DisableItem();: TX.ENABLE.WMENU  ( item# -- enable item in Window menu )	WINDOW-menu-handle @ swap EnableItem();: TEW.SET.CURRENT  ( tew -- , set tew and lt )	dup ..@ txed_header lt.set.current	tx-cur-tew !;: TEW>WINDOW  ( tew -- window )	.. txed_tracker ..@ wt_window;: TX.WINDOW>TEW ( window --- tew )	wRefCon + @ txed_tracker -;: TX.WINDOW>HEADER ( window -- ltx_header )	tx.window>tew ..@ txed_header;: TX.CUR.WINDOW  ( -- curwindow|0 )	tx-cur-tew @ ?dup	IF		TEW>WINDOW	ELSE		0	THEN;: TX.CUR.HEADER  ( -- ltx_header )	tx-cur-tew @ dup	IF ..@ txed_header	ELSE ." No TEW" unravel abort	THEN;: TX.ALLOC.TEW  ( -- tew | 0 , allocate linked structure to manage window )	sizeof() TxEdWindow mm.zalloc dup	IF dup tx-list dll.add.tail	THEN;: TEW.FREE  ( tew -- , unlink and free )	dup dll.remove	mm.free;: TEW.DUMP ( tew -- )	." Header = " dup ..@ txed_header lth.dump	." , Name = " .. txed_filename $type cr;: TX.DUMP ( -- )	'c tew.dump is dll.process.node	>newline	tx-list dll.scan.list;: TEW.SET.TITLE ( tew -- , set title in window )	dup .. txed_tracker ..@ wt_window	swap .. txed_filename SetWTitle();: TX.ADD.WNAMES  ( -- )	tx-list	12 0	DO		dll.next dup dll.end? IF LEAVE THEN		window-menu-handle @ over .. txed_filename AppendMenu()	LOOP	drop;: TX.KILL.WMENU  ( -- , get rid of window menu )	window-menu-handle @ ?dup	IF		window_menu_id DeleteMenu()		DisposeMenu()		DrawMenuBar()		window-menu-handle off	THEN;: TX.REBUILD.WMENU ( -- )	tx.kill.wmenu	window_menu_id " Window" NewMenu() dup window-menu-handle !	dup 0 InsertMenu()	DrawMenuBar()	dup " Next Window/N" AppendMenu()	dup " Forth Window/W" AppendMenu()	dup " HMSL Window" AppendMenu()	drop	tx.add.wnames;: TEW.WRITE.TEXT  { fileid tew | addr nchars -- }	tew ..@ txed_header lt.set.current	lt.get.text  ( -- addr count ) -> nchars -> addr	nchars	IF	fileid addr nchars fwrite nchars <>		IF " Error writing file!" dialog.a		ELSE			fileid ftruncate drop \ set end of file in case file has gotten smaller				THEN	ELSE		fileid ftruncate drop	THEN;: TEW.CLEAR.CHANGE  ( tew -- )	0 swap ..@ txed_header ..! lth_changed;\ ScrollBar -------------------------------------------------variable WHICH-CONTROL\ Constants for the parts of the Scroll Bar20 constant inUpButton21 constant inDownButton22 constant inPageUp23 constant inPageDown129 constant inThumb: TX.DO.SCROLLBAR  ( part -- , process hit )	CASE		inUpButton OF which-control @ dup GetCtlValue() 1-			SetCtlValue()			lt.scroll.up drop			ENDOF		inDownButton OF which-control @ dup GetCtlValue() 1+			SetCtlValue()			lt.scroll.down drop			ENDOF		inPageUp OF which-control @ dup GetCtlValue()			lt.lines.vis 2- 2 max -			dup lt.goto.line lt.redraw			SetCtlValue() ENDOF		inPageDown OF which-control @ dup GetCtlValue()			lt.lines.vis 2- 2 max +			dup lt.goto.line lt.redraw			SetCtlValue() ENDOF	ENDCASE;: TX.FIX.SCROLLBAR  ( -- , move scrollbar to curent position )	tx-cur-tew @ ..@ txed_scroll	lt.where.line	SetCtlValue();\ Find and Replace Dialog --------------------------------------WindowTracker TFR-Trackervariable TFR-DIALOGcreate ITEM-FIND-TEXT 258 allotcreate ITEM-REP-TEXT 258 allot: TFR.CLOSE ( -- , close FIND dialog )	tfr-dialog @ ?dup	IF	DisposeDialog()		tfr-dialog off	THEN;:  TFR.WINDOW.CONTENT ( -- )	FrontWindow() which-window @ -	IF which-window @ SelectWindow()	THEN;: TFR.WINDOW.DRAG  ( -- , drag window )	which-window @	last-event ..@ er_where	DragRect DragWindow();: TFR.GET.IHANDLE  ( item -- handle )	tfr-dialog @  swap item-type item-handle	item-box-rect GetDitem()	item-handle @;: TFR.GET.TEXTS  ( -- )	2 tfr.get.ihandle item-find-text GetIText()	4 tfr.get.ihandle item-rep-text GetIText();: TFR.LOAD.TEXTS  ( addr count -- )	40 min item-find-text off	item-find-text $append	2 tfr.get.ihandle item-find-text SetIText()	tfr-dialog @  2  0 item-find-text c@ SELIText()	4 tfr.get.ihandle item-find-text SetIText();: TFR.GET.SEARCH$  ( -- addr count | addr 0 ){ | addr nchars off1 line#1 line1 off2 line#2 line2 -- addr count | 0 0 }	0 -> addr   0 -> nchars	lt.get.select 2dup <>	IF	lt.char#>line#off -> off2 -> line#2		lt.char#>line#off -> off1 -> line#1		line#1 line#2 =		IF line#1 lt.line#>text drop			off1 + -> addr			off2 off1 - -> nchars		THEN	ELSE 2drop	THEN	addr nchars;	5 constant TFR_FIND_ITEM6 constant TFR_REP&FIND_ITEM7 constant TFR_ALL_ITEM8 constant TFR_WRAP_ITEMvariable TX-WRAP-FIND   \ if true, do wrap around find: TX.FIND?  { $string start | offset addr nchars -- offset | -1, find and highlight }	-1 -> offset	lt.get.text -> nchars -> addr	nchars start - $string c@ >  \ enough text left past cursor?	IF		addr start + nchars start -		$string count match? ?dup		IF			tfr.close \ 00003			addr - -> offset			offset dup $string c@ +			lt.highlight lt.put.select lt.highlight		THEN	THEN	offset;: TX.FIND { $string | result -- , find and highlight, select window or error }	$string lt.get.start 1+ tx.find? dup -> result 0<	IF		tx-wrap-find @		IF	\ try again from beginning of file			$string 0 tx.find? -> result		THEN	THEN	result 0<	IF		" Could not find text!" dialog.a	ELSE		lt.new.position	THEN;: TX.REPLACE ( $string -- , replace currently selected string )	count lt.insert;: TX.REPLACE.NEXT  ( -- , for edit menu )	item-rep-text tx.replace	item-find-text tx.find	tx.fix.scrollbar	lt.redraw;: TX.FIND.NEXT  ( -- , for edit menu )\ tfr-dialog @ IF \ 00001	item-find-text tx.find  tx.fix.scrollbar\ THEN;: TFR.HANDLE.HIT  ( item -- )	tfr.get.texts	CASE		tfr_find_item OF  tx.find.next			ENDOF		tfr_rep&find_item OF  tx.replace.next			ENDOF		tfr_all_item OF BEGIN item-find-text lt.get.start							tx.find? 0< not						WHILE item-rep-text tx.replace						REPEAT						lt.new.position lt.redraw tx.fix.scrollbar			ENDOF		tfr_wrap_item OF tx-wrap-find @ not dup tx-wrap-find !					tfr_wrap_item tfr.get.ihandle ( get control )					swap 1 and SetCtlValue()			ENDOF	ENDCASE;: (TFR.HANDLE.EVENT) ( -- processed? )	last-event IsDialogEvent()	IF	last-event ..@ er_what  keyDwnEvt =		IF	last-event ..@ er_message $ FF and   $ 0D =  ( carriage return ? )			IF tfr_find_item tfr.handle.hit true			ELSE false			THEN		ELSE false		THEN		0=		IF last-event tfr-dialog item-hit DialogSelect()			IF item-hit w@ tfr.handle.hit			THEN		THEN		true	ELSE false	THEN;: TFR.HANDLE.EVENT ( --  )	(tfr.handle.event) drop;: TFR.HANDLE.DOWN ( -- )	(tfr.handle.event) 0=	IF	which-part @		CASE			INContent	OF tfr.window.Content ENDOF			InDrag		OF tfr.window.Drag ENDOF			InGoaway	OF tfr.close ENDOF		ENDCASE	THEN;: TFR.OPEN  ( -- )	tfr-dialog @ 0=    IF	129 0 -1 GetNewDialog()			dup tfr-tracker link.window<->tracker		tfr-dialog !	\	\ Initialize Tracker for events		'c tfr.handle.event tfr-tracker ..! wt_EVHandler		'c tfr.handle.down tfr-tracker ..! wt_MDHandler	ELSE tfr-dialog @ SelectWindow()	THEN\ preload search strings	tfr.get.search$ ?dup	IF tfr.load.texts	ELSE drop	THEN;exists? MIDIM-IF-ON .IF\ Mac+ with MIDI Mangler 1.1 trashes files when written.\ Turn off MIDI if flag is set and MIDI ONvariable TX-MIDI-SAFEvariable TX-MIDI-FORCED-OFF: TX.MIDI.OFF ( -- , turn off midi if needed )\ turn off MIDI because of Apple bug	tx-midi-safe @  midim-if-on @ AND	IF ." Apple MIDI Manager temporarily turned off to avoid bug!" cr		midi.ser.term		tx-midi-forced-off on	ELSE tx-midi-forced-off off	THEN;: TX.MIDI.ON  ( -- , turn MIDI back on )	tx-midi-forced-off @	IF	midi.ser.init		tx-midi-forced-off off	THEN;.ELSE: TX.MIDI.ON ;: TX.MIDI.OFF ;.THEN: TEW.SAVEAS.FILE (  tew -- )	dup tew.set.current	dup>r 	.. txed_filename \ $origname	r@ ..@ txed_vrefnum  ABS mySFReply ..! sfr_vrefnum \ set default directory	30 30 \ x y	" Enter name to save as..." \ $prompt	SFPutFile  \ filename vRefNum true | 0 )	IF  over r@ .. txed_filename $move		dup r@ ..! txed_vrefnum		tx.midi.off		new $fopen_vr ?dup		IF	dup r@ tew.write.text			fclose			r@ ..@ txed_vrefnum FLUSHVOL  ( M901126-0 )			r@ tew.clear.change		THEN		tx.midi.on	THEN	true r@ ..! txed_saveable	rdrop	lt.update.status	tx-cur-tew @ tew.set.title	tx.rebuild.wmenu;: TEW.SAVE.FILE  ( tew -- , save contents of text edit record )	dup ..@ txed_saveable	IF	tx.midi.off		dup>r			.. txed_filename r@ ..@ txed_vrefnum $fopen_vr ?dup		IF dup r@ tew.write.text			fclose			r@ ..@ txed_vrefnum ?dup			IF FLUSHVOL  ( M901126-0 )			THEN		THEN		r> tew.clear.change		tx.midi.on	ELSE tew.saveas.file	THEN	lt.update.status;: TEW.FORCE.CLOSE ( tew -- , close window, etc. )	dup ..@ txed_header ?dup	IF lt.free.header	THEN\    dup tew>window disposeWindow()    dup tx-cur-tew @ =	IF  tx-cur-tew off	THEN	tew.free\	tx-list dll.empty?  \ is this the last window	IF		1 tx.disable.wmenu  ( no next window to switch to )		tx_close_item tx.disable.file		tx_save_item tx.disable.file		tx_saveas_item tx.disable.file		3 tx.disable.include		tfr.close \ close find dialog	THEN	arrow.cursor;: TEW.CLOSE  ( tew -- , close the window and TextEdit record, etc.)\ Ignore cancel, close anyway!	dup ..@ txed_header ..@ lth_changed	IF 	dup .. txed_filename pad $move		"  - Save changes before closing?" count pad $append		pad dialog.y/n/c		dup 3 <		IF 1 =			IF dup tew.save.file			THEN		ELSE drop		THEN	THEN	tew.force.close;: TEW.CLOSE.MAYBE  ( tew -- , close the window and TextEdit record, etc.)\ If damaged, give an opportunity to not close!\ This is called if user hits close box.	dup ..@ txed_header ..@ lth_changed	IF	dup .. txed_filename pad $move		"  - Save changes before closing?" count pad $append		pad dialog.y/n/c		dup 3 <		IF 1 =			IF dup tew.save.file			THEN			tew.force.close		ELSE 2drop \ don't close!		THEN	ELSE tew.force.close	THEN	tx.rebuild.wmenu;: TX.SETPORT  ( -- , set current graphport to current window )	tx.cur.window SetPort();\ Text Editing and window manipulation -----------------------------: TEW.CALC.SCRMAX ( tew -- , calculate maximum value for lines )\ max = #lines_total - #lines_visible	lt.lines.vis	tx.cur.header ..@  lth_nlines swap - 8 +	0 max ( 0 will disable if all fits in window )	swap ..@ txed_Scroll swap SetCtlMax();: TX.GET.SELECT ( -- start end )	lt.get.select;: TX.CUT ( -- , cut from current Rec )	lt.cut	tx_paste_item tx.enable.edit;: TX.COPY ( -- , cut from current Rec )	lt.copy	tx_paste_item tx.enable.edit;: TX.PASTE ( -- , cut from current Rec )	lt.paste	tx-cur-tew @ tew.calc.scrmax	lt.new.position	tx.fix.scrollbar;: TX.DELETE ( -- , cut from current Rec )	lt.chop;\ -------------------------------------------------------------: TX.KEY  ( char -- )	tx.setport	lt.key	tx-cur-tew @ tew.calc.scrmax	tx.fix.scrollbar;: TX.ACT  ( -- )	last-event ..@  er_message  tx.window>tew tew.set.current	lt.setport lt.invalrect\	tx.setport lt.highlight	tx_close_item tx.enable.file	tx_save_item tx.enable.file	tx_saveas_item tx.enable.file	tx_undo_item tx.enable.edit	7 tx.enable.edit	9 tx.enable.edit	10 tx.enable.edit	11 tx.enable.edit	12 tx.enable.edit	tx_smart_item tx.enable.edit	tx_size_item tx.enable.edit \ 00004	3 tx.enable.include	ibeam.cursor;: TX.DEACT  ( -- )\	last-event ..@  er_message  tx.window>tew tew.set.current\	tx.setport lt.highlight	tx_close_item tx.disable.file	tx_save_item tx.disable.file	tx_saveas_item tx.disable.file	tx_undo_item tx.disable.edit	7 tx.disable.edit	9 tx.disable.edit	10 tx.disable.edit	11 tx.disable.edit	12 tx.disable.edit	tx_smart_item tx.disable.edit	tx_size_item tx.disable.edit \ 00004	3 tx.disable.include	arrow.cursor;: (TX.SCROLL.CALLBACK)  ( part -- )\ wait for 10 ticks before auto scrolling	TickCount() last-event ..@ er_when - 10 >	IF		tx.do.scrollbar	ELSE		drop	THEN;create HFORTH-REGS  4 cells allot: SETUP.FORTH.REGS  ( -- , setup registers for callback )	0 0 0 0   ( pad stack )	[	$ 41FA w, hforth-regs here - w,						\ lea		*-hforth-regs,a0		$ 48D05C00 ,	\ movem.l	a2-a4/a6,(a0)	]	2drop 2drop;: TX.SCROLL.CALLBACK  ( -- , CALLED BY MAC SYSTEM when holding down scroll buttons)\ Setup hforth Registers for high level calls.	[		$ 205F	w,		\ move.l	(a7)+,a0	\ get return address		$ 7200	w,		\ moveq.l	#0,d1		\ clear high bits		$ 321F	w,		\ move.w	(a7)+,d1	\ get int parameter		$ 201F	w,		\ move.l	(a7)+,d1	\ get long parameter		$ 2F08	w,		\ move.l	a0,-(a7)	\ restore return address		$ 48E7FFFE ,	\ movem.l   d0-d7/a0-a6,-(a7)		$ 41FA w, hforth-regs here - w,						\ lea		*-hforth-regs,a0		$ 4CD05C00 ,	\ movem.l	(a0),a2-a4/a6		$ 2d01	w,		\ move.l  d1,-(a6)		\ push part number	]	(tx.scroll.callback)	[		$ 4cDF7FFF ,	\ movem.l   (a7)+,d0-d7/a0-a6	];:  TX.WINDOW.CONTENT ( -- )	FrontWindow() which-window @ -	IF which-window @ SelectWindow()	ELSE		which-window @ Setport()\ convert coordinates    	last-event .. er_where GlobalToLocal()\\ Test for click in vertical scroll bar.    	last-event ..@ er_where		which-window @		which-control   FindControl() ?dup		IF ( -- part , we hit the control )			arrow.cursor			inThumb =			IF	\ when in thumb, the tracking action proc has no params!!				which-control @    			last-event ..@ er_where				NULL  TrackControl()  inThumb =				IF which-control @ GetCtlValue() lt.goto.line lt.invalrect				THEN			ELSE				which-control @    			last-event ..@ er_where				setup.forth.regs				'c tx.scroll.callback TrackControl()  ?dup				IF tx.do.scrollbar				THEN			THEN\ Track click in text.		ELSE    		last-event ..@ er_where\ is the shift key held down			?shift			lt.click			tx.get.select - abs 0>			IF 	tx_cut_item tx.enable.edit				tx_copy_item tx.enable.edit				tx_upper_item tx.enable.edit				tx_lower_item tx.enable.edit			ELSE  tx_cut_item tx.disable.edit				tx_copy_item tx.disable.edit				tx_upper_item tx.disable.edit				tx_lower_item tx.disable.edit			THEN			tx.fix.scrollbar		THEN	THEN;: TX.WINDOW.GOAWAY  ( -- )    which-window @	last-event ..@ er_where	TrackGoAway()	IF	which-window @ tx.window>tew tew.close.maybe	THEN;	: TX.WINDOW.DRAG  ( -- , drag window )\	set.drag.hooks	which-window @	last-event ..@ er_where	DragRect DragWindow()\	reset.drag.hooks;16 constant scrollBarProc: TX.CALC.SRECT  ( window -- rect , scrollbar rectangle )	16 + txsbRect 8 cmove  ( copy grafport's rectangle )	txsbRect ..@ rect_top 1- txsbRect ..! rect_top	txsbRect ..@ rect_right 1+ txsbRect ..! rect_right	txsbRect ..@ rect_right 15 - txsbRect ..! rect_left	txsbRect ..@ rect_bottom 14 - txsbRect ..! rect_bottom	txsbRect;: TX.RESIZE.SCROLL  ( window -- , set rect in control structure )	dup tx.calc.SRect	swap tx.window>tew ..@ txed_scroll @ 8 + 8 cmove;	: TX.CALC.VRect  ( window -- rect , based on current window )	16 + >r \ offset to rect in GrafPort	r@ ..@ rect_top lt_topy + txVRect ..! rect_top	0 txVRect ..! rect_left	r@ ..@ rect_right 16 - 10 max txVRect ..! rect_right\ adjust screen to integer number of lines	r@ ..@ rect_bottom txVRect ..@ rect_top -  ( total-height )	lt_lheight / lt_lheight *	txVRect ..@ rect_top + txVRect ..! rect_bottom	rdrop	txVRect;: TX.RESIZE.VIEW  ( window -- , set rect in TxEd structure )	tx.calc.VRect	tx.cur.header .. lth_dest 8 cmove;: TX.REDRAW  ( window -- , redraw a windows text and controls )	tx-cur-tew @ >r	dup tx.window>tew tew.set.current	dup SetPort()	dup 16 +  ( portRect )  EraseRect()	dup tx.resize.scroll	dup tx.resize.view	dup tx.window>tew tew.calc.scrmax	dup DrawGrowIcon()	dup DrawControls()	drop	lt.redraw	r> tew.set.current;: TX.WINDOW.GROW  ( -- , grow a window )\	set.drag.hooks    which-window @	last-event ..@ er_where	GrowRect GrowWindow() ?dup	IF which-window @ swap		dup $ FFFF and swap -16 shift  ( unpack low and high x,y )		-1 SizeWindow()	THEN	which-window @ tx.redraw\	reset.drag.hooks;variable TX-RSI-COUNT  ( count keystrokes and mouse clicks )variable TX-RSI-MAX    ( number of events to trip at )0 tx-rsi-max !: TX.CHECK.RSI  ( -- )	tx-rsi-max @ ?dup	IF		tx-rsi-count @ 1+ dup tx-rsi-count !   <		IF			" Avoid Repetitive Stress Injury - take a break!" dialog.a			tx-rsi-count off		THEN	THEN;: TX.KEYDOWN  ( --  , add to Text Rec)\ Menu events are already filtered	last-event ..@ er_message $ FF and tx.key	tx.check.rsi;: (TX.UPDATE) ( window -- , update a window )	dup BeginUpdate()	dup tx.redraw	EndUpdate();: TX.UPDATE  ( -- , UPDATE event handler )	last-event ..@ er_message (tx.update);: TX.ACTIVATE ( -- )\ Is this an activate event or deactivate event.    last-event ..@ er_modifiers activatemask AND    IF tx.act    ELSE tx.deact    THEN;variable TheWind: TX.SELECT.CURSOR	lt-point GetMouse()	lt-point LocalToGlobal()	lt-point @ TheWind FindWindow()	3 =	TheWind @ tx.cur.window = AND	IF		ibeam.cursor	ELSE		arrow.cursor	THEN;: TX.FLASH.CURSOR  ( -- )	lt_header	IF	lt.get.select =		IF	TickCount() dup			lt-cursor-time @ CaretTime @ + >  ( is it time to flash yet )			IF lt-cursor-time !				lt-cursor-state @				IF lt.cursor.off				ELSE lt.cursor.on				THEN			ELSE drop			THEN		THEN	THEN;: (TX.HANDLE.EVENT) ( -- )	depth >r	last-event ..@ er_what	CASE		0 OF tx.flash.cursor tx.select.cursor ENDOF		mButUpEvt  OF noop ENDOF		keyDwnEvt	OF tx.keydown ENDOF		keyUpEvt	OF noop ENDOF						autoKeyEvt	OF tx.keydown ENDOF		updatEvt OF tx.update ENDOF		activateEvt OF tx.activate ENDOF		IF-DEBUG @		IF	." TX - Unrecognized Event = " dup . cr		THEN	ENDCASE	depth r> <> warning" TX.HANDLE.EVENT - Change in stack!";: TX.HANDLE.EVENT ( -- )	tx-event-recurse @	IF \ ." TX.HANDLE.EVENT - Recursion stopped!" cr		\ tx-event-recurse off abort	ELSE		tx-event-recurse on		(tx.handle.event)		tx-event-recurse off	THEN;: (TX.HANDLE.DOWN)  ( -- )	depth >r	which-part @	CASE		INContent	OF tx.window.Content ENDOF		InDrag	OF	tx.window.Drag ENDOF		InGrow	OF	tx.window.Grow ENDOF		InGoaway	OF tx.window.goaway ENDOF		." Unrecognized FindWIndow() Result = " dup . cr	ENDCASE	depth r> <> warning" TX.HANDLE.DOWN - Change in stack!"	tx.check.rsi;: TX.HANDLE.DOWN ( -- )	lt-down-recurse @	IF ." TX.HANDLE.DOWN - Recursion stopped!" cr	ELSE		lt-down-recurse on		(tx.handle.down)		lt.abort.off		lt-down-recurse off	THEN;: TX.NEW.SCROLL ( -- handle , add scroll bar to current window )	tx.setport	tx.cur.window	dup tx.calc.srect  0	1  100 0 200 scrollBarProc 0	NewControl()	dup 1 SetCtlValue()	dup ShowControl();\ Open window and link it into TX system.\ Make it current.: TX.OPEN.WINDOW ( -- , Open window for editing text in. )	tx.alloc.tew dup 0= abort" Couldn't allocate TXED"	tx-cur-tew !\    TX-NewWindow window.defaults	" Untitled" TX-NewWindow ..! wt_title	40 TX-NewWindow .. wt_rect ..! rect_top	10 TX-NewWindow .. wt_rect ..! rect_left	40 gr_ymax + TX-NewWindow .. wt_rect ..! rect_bottom	10 gr_xmax + TX-NewWindow .. wt_rect ..! rect_right\	TX-NewWindow openwindow() ?dup 	IF	tx-cur-tew @		.. txed_tracker dup>r link.window<->tracker		'c tx.handle.event r@ ..! wt_EVHandler		'c tx.handle.down r> ..! wt_MDHandler	ELSE tx-cur-tew @ tew.free ." Could not open TX window!" cr abort	THEN	tx.cur.window SelectWindow()	tx.new.scroll tx-cur-tew @ ..! txed_scroll	tx-cur-tew @ tew.clear.change	" Untitled" tx-cur-tew @ .. txed_filename $move	1 tx.enable.wmenu;: TX.NEW  ( -- , open NEW window, TEW, and TeRec )	tx.open.window	tx.setport	lt.new.header	dup tx-cur-tew @ ..! txed_header	lt.set.current	0 0 lt.put.select	false tx-cur-tew @ ..! txed_saveable	tx.rebuild.wmenu;: TX.SAVE.CUR  ( -- , save current window )	tx-cur-tew @ ?dup	IF tew.save.file	THEN;: TX.SAVEAS.CUR  ( -- , save current window )	tx-cur-tew @ ?dup	IF tew.saveas.file	THEN;: TX.CLOSE  ( -- ,close current )	tx-cur-tew @ tew.close.maybe;: TX.CLOSE.ALL ( -- )	'c tew.close is dll.process.node	tx-list dll.scan.list;: $TX.OPEN.FILE?  { filename volref | TextAddr size fid result -- error? }	true -> result	filename volref	$fopen_vr ?dup	IF	dup -> fid 0 offset_end fseek drop		fid 0 offset_beginning fseek -> size		tx.new		size lt.alloc.text ?dup		IF  -> TextAddr			watch.cursor			fid TextAddr size fread			size =			IF	\ add EOL if needed				TextAddr size + 1- c@ EOL <>				IF					EOL TextAddr size + c!					size 1+ -> size					size lt_header ..! lth_nchars				THEN\				volref tx-cur-tew @ ..! txed_vrefnum				filename tx-cur-tew @ .. txed_filename $move				TextAddr size EOL count.chars lt.alloc.starts 0=				IF " Could not allocate memory for LineStarts!" dialog.a					arrow.cursor					lt_header lt.clear.header					abort				THEN				lt.recalc.lines				tx-cur-tew @ tew.set.title				true tx-cur-tew @ ..! txed_saveable				0 lt.goto.line  ( sets up line offset cache )				tx.rebuild.wmenu				0 -> result  \ yay we did it!			ELSE " Could not read all of file!" dialog.a			THEN			arrow.cursor		ELSE " Insufficient memory" dialog.a cr		THEN		fid fclose	THEN	result;: $TX.OPEN.FILE  ( filename volref  -- )	$tx.open.file?	IF " Could not open file!" dialog.a	THEN;: TX.OPEN.FILE  ( -- , open a window for a file )	sfgetfile	IF $tx.open.file	THEN;: EDIT.FILE  ( <filename> -- , open a file by name to be edited )	fileword 0 $tx.open.file;: TX.FILE.MENU  ( -- , )	which-part @ 15 and	CASE		tx_new_item OF tx.new ENDOF		tx_open_item OF tx.open.file ENDOF		tx_close_item OF tx.close ENDOF		tx_save_item OF tx.save.cur ENDOF		tx_saveas_item OF tx.saveas.cur ENDOF		12 OF tx.save.cur BYE ENDOF	ENDCASE;: TX.SELECT.ALL  ( -- , for edit menu )	lt.highlight	0 tx.cur.header ..@ lth_nchars 1- 0 max lt.put.select	lt.highlight;: TX.SHOW.CHANGE ( -- , make change in text visible )	lt.invalrect	lt.mark.change	tx-cur-tew @ ..@ txed_header lt.set.current lt.redraw;: TX.GET.SELTEXT ( -- addr count )	lt.get.seltext;: TX.UPPER  ( -- , for edit menu )	lt.writeable? \ 00002	IF		lt.get.select <>		IF lt.get.seltext 0			DO dup c@ toupper over c!   1+			LOOP drop		THEN		tx.show.change	THEN;: TX.LOWER  ( -- , for edit menu )	lt.writeable? \ 00002	IF		lt.get.select <>		IF lt.get.seltext   0			DO dup c@ tolower over c!   1+			LOOP drop		THEN		tx.show.change	THEN;: TX.SHOW.SMART ( -- , put checkmark on menu if on )	EDIT-menu-handle @ tx_smart_item	lt-smart-format @ CheckItem();: TX.TOGGLE.FORMAT  ( -- , toggle smart format )	lt-smart-format @ not lt-smart-format !	tx.show.smart;: TX.EDIT.MENU  ( -- , )	depth >r	which-part @ 15 and	CASE		tx_undo_item OF lt.undo ENDOF		3 OF tx.cut ENDOF		4 OF tx.copy ENDOF		5 OF tx.paste ENDOF		6 OF tx.delete ENDOF		7 OF tx.select.all ENDOF		9 OF tfr.open ENDOF		10 OF tx.find.next ENDOF		11 OF tx.replace.next ENDOF		tx_upper_item OF tx.upper ENDOF		tx_lower_item OF tx.lower ENDOF		tx_smart_item OF tx.toggle.format ENDOF	ENDCASE	depth r> <> abort" TX.EDIT.MENU 0 change in stack depth!";\ Respond to FontSize Menu Pick 00004create tx-font-sizes 9 c, 10 c, 12 c, 18 c, 24 c, align: TX.FONTSIZE.MENU ( -- )	which-part @ 15 and	1- tx-font-sizes + c@	tx.set.size	tx.cur.window ?dup	IF		tx.redraw	THEN;	variable TX-INC-LINE#	\ current line number while compilingdefer TX.OLD.ABORTdefer TX.OLD.QUERY: TX.ABORT  ( -- , handle abort while compiling )\ calculate offsets of last WORD in interpret	arrow.cursor	what's tx.old.abort is abort	what's tx.old.query is query\	tx.cur.window SelectWindow()	tx.setport	tx-inc-line# @ lt.line#>char# >in @ + 1-	dup here c@ - swap lt.put.select lt.invalrect	tx-inc-line# @ lt.force.visible	bell abort;: TX.QUERY  ( -- , get next line of input from Editor )	lt.read.next	IF >tib  at-eof off		1 tx-inc-line# +!	ELSE at-eof on	THEN;: TX.INCLUDE  ( -- , include text from current file )	depth >r	tx-cur-tew @	IF	what's abort is tx.old.abort		'c tx.abort is abort		what's query is tx.old.query		'c tx.query is query		main_window SelectWindow()		." Include from Editor" cr		watch.cursor		pushtib		0 lt.start.read  ( start reading from position 0 in file )		-1 tx-inc-line# !		tx.cur.header ..@ lth_nlines  0		DO				query at-eof @			IF LEAVE			THEN			interpret		LOOP		pulltib		arrow.cursor		what's tx.old.abort is abort		what's tx.old.query is query		update.screen		>newline ." Compilation complete." cr	THEN	depth r> <> abort" Change in stack depth during include!";\ Window Menu Support: TX.NEXT.WINDOW ( -- , move to next window in chain )	frontwindow() main_window =	IF tx-list dll.empty? not		IF	tx-list dll.next tew>window SelectWindow()		THEN	ELSE tx-cur-tew @ ?dup		IF	dll.next  dup dll.end?			IF drop main_window  ( go to Forth window if at end of chain )			ELSE tew>window			THEN SelectWindow()		THEN	THEN;: TX.NTH.TEW  ( n -- tew | 0 , get nth tew )	tx-list dll.next	BEGIN  ( -- n tew )		over 0>		over dll.end? not and	WHILE		dll.next		swap 1- swap	REPEAT	nip	dup dll.end?	IF drop 0	THEN;: TX.SELECT.NTH  ( n -- , select Nth window )	tx.nth.tew ?dup	IF		tew>window SelectWIndow()	THEN;: TX.WINDOW.MENU  ( -- , process window menu )	which-part @ 15 and	CASE		1 OF  tx.next.window ENDOF		2 OF main_window SelectWindow() ENDOF		3 OF hmsl-window @ ?dup			IF SelectWindow()			THEN		 ENDOF		dup 4 - tx.select.nth	ENDCASE;: TX.TERM  ( -- , process all open windows )	tx-if-init @	IF	tfr.close			1 tx.disable.file \ New		2 tx.disable.file \ Open...		3 tx.disable.include \ no include from editor		tx_size_item tx.disable.edit \ 00004		tx.close.all		0 file_menu_id ev.menu.func!		0 edit_menu_id ev.menu.func!		0 window_menu_id ev.menu.func!		0 fontsize_menu_id ev.menu.func!		tx.kill.wmenu		tx-if-init off		lt.free.clip		lt.undo.free	THEN;: TX.INIT ( -- )	tx-list dll.newlist	tx.rebuild.wmenu	'c tx.file.menu file_menu_id ev.menu.func!	'c tx.edit.menu edit_menu_id ev.menu.func!	'c tx.fontsize.menu fontsize_menu_id ev.menu.func!	'c tx.window.menu window_menu_id ev.menu.func!\	file_menu_id getMHandle() file-menu-handle !	edit_menu_id getMHandle() edit-menu-handle !	include_menu_id getMHandle() include-menu-handle !	\ make FontSize a hierarchical menu 00004	fontsize_menu_id GetMHandle() dup 0=	IF		drop fontsize_menu_id GetMenu()	THEN	dup fontsize-menu-handle !	-1 InsertMenu()		tx.show.smart\\ Set deferred word to include from editor	'c tx.include is include.edit\	1 tx.enable.file \ New	2 tx.enable.file \ Open...	tx-if-init on;\ For FILE? ------------------- 00002: $TX.OPEN.FIND { $word $filename -- , open file and find word }	$filename 0 $tx.open.file? 0=	IF		$word tx.find		tx.fix.scrollbar	THEN;: $TX.OPEN.FIND.RO { $word $filename -- , open file and find word, read only }	$filename 0 $tx.open.file? 0=	IF		$word tx.find		tx.fix.scrollbar		true lt_header ..! lth_read_only	THEN;exists? $F?.OPEN.FIND .IF' $tx.open.find is $f?.open.find' $tx.open.find.ro is $f?.open.find.ro.THEN\ ------------------------------if.forgotten tx.term: AUTO.INIT  tx.init auto.init ; \ Init Text Editor first to get Open... event.: AUTO.TERM  tx.term auto.term ;