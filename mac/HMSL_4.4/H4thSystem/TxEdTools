\ Low Level Text Editor Support\\ This system will be much like the Apple TxEd system but\ allows > 32767 chars, and tabs.\\ Author: Phil Burk\ Copyright 1990 Phil Burk\ All rights reserved\\ MOD: PLB 5/29/91 Added LT.FORCE.VISIBLE, faster CHAR>LINE\ MOD: PLB 8/7/91 Add UNDO\ MOD: PLB 10/7/91 Add TX.SET.SIZE\ 00001 PLB 1/13/92 Added Read Only mode.ANEW TASK-TxEdToolsdecimal0 .IF: MM.ALLOC? ( nbytes -- address | zero )	dup . ." MM.ALLOC? from " r@ >name id.	mm.alloc?	dup . cr;.THEN\ one of these for each file$ 57913AF2 constant LT_VALID_KEY:STRUCT  lt_HEAD	struct	rect	lth_dest	aptr	lth_TextAddr	\ address of text	long	lth_MaxText		\ maximum characters allowed in allocated space	aptr	lth_LineStarts	\ pointer to array of Line starts	long	lth_MaxLines	\ allocated Line Start space	aptr	lth_grafport	\ grafport for drawing	long	lth_topline#	\ line# for top line displayed	long	lth_topchar#	\ character offset for top line	long	lth_leftcol		\ left column for horizontal scrolling	long	lth_nlines		\ total # lines in file	long	lth_nchars		\ total number of chars in file	long	lth_selstart	\ character index relative to start of file	long	lth_selend	long	lth_curline#	\ line# for current line for status, start of select	long	lth_curcol		\ current column for status	long	lth_validation	byte	lth_changed		\ true if changed since save	byte	lth_change_s	\ change status displayed	byte	lth_read_only	\ 00001	byte	lth_reserved;STRUCTvariable LT-IF-CURSOR   \ true if cursor visiblevariable LT-DEBUG	\ if true, do a sanity check for listvariable LT-NOW-AT  ( selected position to start )variable LT-NEXT-LINE	\ for sequential line accessvariable LT-SHOW-STATUS  \ true if status update oklt-show-status onvariable LT-CURSOR-STATE	\ true means cursor onvariable LT-CURSOR-TIME		\ time last turned onvariable LT-HIT-TABS		\ tabs hit at beginning of line deliberatelycreate LT-&0D $ 0D090909 , $ 09090909 , $ 09090909 , $ 09090909 ,15 constant LT_MAX_TABSCREATE LT-FONT-INFO 8 allot12 value LT_LHEIGHT6 value LT_CHARWIDTH2 value LT_DESCENT9 value LT_TEXTSIZE14 constant LT_TOPY1024 constant LT_TEXT_EXTRAlt_text_extra 32 / constant LT_STARTS_EXTRA$ a8715392 constant LT_VALID \ unlikely number0 value LT_HEADER: LT.CHECK.VALID  ( header -- )	..@ lth_validation lt_valid_key -	abort" LT.CHECK.VALID - invalid header!";: LT.ADJUST.FONT	lt-font-info GetFontInfo()	lt-font-info w@	lt-font-info 2+ w@ dup -> lt_descent +	lt-font-info 6 + w@ + -> lt_lheight	bl charwidth() -> lt_charwidth;: TX.SET.SIZE ( size -- , user call )	-> lt_textsize;: LT.INIT.HEADER  ( header -- )	>r	r@ sizeof() lt_head 0 fill	lt_valid_key r@ ..! lth_validation	r@ .. lth_dest		0 over ..! rect_left		lt_TOPY over ..! rect_top		300 over ..! rect_right		200 swap ..! rect_bottom	r@ .. lth_grafport GetPort()  \ load current grafport into header	rdrop;: LT.SET.CURRENT  ( header -- )	-> lt_header;: LT.GET.UPDATE  ( -- update-region )	lt_header ..@ lth_grafport	$ 7A + @;: LT.MARK.CHANGE ( -- , mark current header as changed )	TRUE lt_header ..! lth_changed;: LT.CHANGED?  ( header -- flag , has this text been changed )	lt_header ..@ lth_changed;: LT.WRITEABLE?  ( -- flag , true if OK to change , 00001)	lt_header ..@ lth_read_only	IF		" File open only for reading!" dialog.a		false	ELSE		true	THEN;: LTH.DUMP ( header -- , dump stuff about header )	." Changed? = " dup ..@ lth_changed .	drop;: LT.COLUMNS.VIS  ( -- visible-columns )	lt_header .. lth_dest	dup ..@ rect_right	swap ..@ rect_left - lt_charwidth /	1- 0 max;: LT.LineStart[]  ( n LineStarts -- LineStart )	swap cell* +;: LT.START>NCHARS  ( LineStart -- count )	dup cell+ @ swap @ -;: LT.HEADER.COUNT  ( header -- addr count )	dup ..@ lth_textaddr	swap ..@ lth_nchars;: LT.CHAR#>ADDR  ( index -- addr , text address for indexed char )	lt_header ..@ lth_textaddr +;: LT.CHAR#>LINE#OFF { indx | line# offset -- line# offset }	0 -> line#	-1 -> offset	lt_header ..@ lth_linestarts ( -- linestart )	lt_header ..@ lth_nlines 0	DO		cell+ dup  ( increment linestart )		@  indx >  \ is next line past this index		IF	i -> line#			indx over cell- @ - -> offset			LEAVE		THEN	LOOP	drop	line# offset;: LT.CHAR#>LINE# ( char# -- line# )	lt.char#>line#off drop;: LT.CUR.LINE  ( -- line# , current line number )	lt_header ..@ lth_curline#;: LT.LINE#>START  ( line# -- &start )	lt_header ..@ lth_linestarts lt.linestart[];: LT.LINE#>CHAR#  ( line# -- char#  , of beginning of line )	 lt.line#>start @;: LT.LINE#>NCHARS  ( line# -- nchars  , in line )	lt.line#>start  lt.start>nchars;: LT.LINE#>TEXT ( line# -- addr count , get text of line )	lt.line#>start	dup cell+ @ swap @ tuck -  ( offset count )  >r	lt.char#>addr r>;: LT.LINE#>ADDR  ( line# -- addr , of text )	lt.line#>char# lt.char#>addr;: LT.GET.TEXT ( -- addr count )	lt_header lt.header.count;: LT.ROOM.TEXT?  ( -- bytes_empty , how much empty space )	lt_header ..@ lth_MaxText	lt_header ..@ lth_nchars -;: LT.REALLOC.TEXT  { nchars | error addr -- error , make room for more starts }	true -> error	nchars mm.alloc? dup -> addr	IF	nchars lt_header ..! lth_MaxText		lt_header ..@ lth_TextAddr addr		lt_header ..@ lth_nchars nchars min  cmove		lt_header ..@ lth_TextAddr mm.free		addr lt_header ..! lth_TextAddr		false -> error	THEN	error;: LT.MAKE.ROOM.TEXT ( nchars -- error , make sure the text area is big enough )	lt_header ..@ lth_nchars + 4+   ( total chars needed )	dup lt_header ..@ lth_MaxText >	IF lt_text_extra + lt.realloc.text	ELSE drop 0	THEN;: LT.REALLOC.STARTS  { nlines | error addr -- error , make room for more starts }	true -> error	nlines cell* mm.alloc? dup -> addr	IF	nlines lt_header ..! lth_MaxLines		lt_header ..@ lth_LineStarts addr		lt_header ..@ lth_nlines nlines min cell* cmove		lt_header ..@ lth_LineStarts mm.free		addr lt_header ..! lth_LineStarts		false -> error	THEN	error;: LT.MAKE.ROOM.STARTS ( newlines -- error , make sure the text area is big enough )	lt_header ..@ lth_nlines + 4+   ( total lines needed )	dup lt_header ..@ lth_MaxLines >	IF lt_starts_extra + lt.realloc.starts	ELSE drop 0	THEN;true .IF  \ hex version: LT.CALC.LINES  ( addr nchars LineStarts -- #lines )	[ HEX	2F02 w,	2F03 w,	225E w,	2F09 w,	221E w,	201E w,	2040 w,	22FC w,	0000 w,	0000 w,	0C18 w,	000D w,	6600 w,	0008 w,	2408 w,	9480 w,	22C2 w,	5381 w,	6E00 w,	FFEE w,	2009 w,	909F w,	E480 w,	5380 w,	2D00 w,	261F w,	241F w,	4E75 w,	DECIMAL	];0 .IF  \ Assembly versionCODE  LT.CALC.LINES  ( addr nchars LineStarts -- #lines )	move.l	d2,-(a7)	move.l	d3,-(a7)	move.l	(a6)+,a1	move.l	a1,-(a7)	; LineStarts	move.l  (a6)+,d1	; nchars	move.l	(a6)+,d0	; addr	move.l	d0,a0		; addr changing	move.l	#0,(a1)+	; zero first entry, point to next@1	cmpi.b	#$0D,(a0)+ ; EOL ?	bne		@2	move.l	a0,d2	sub.l	d0,d2		; calc char#	move.l	d2,(a1)+	; write next LineStart@2	subq.l	#1,d1		;	bgt		@1	move.l	a1,d0	sub.l	(a7)+,d0	asr.l	#2,d0	subq.l	#1,d0	move.l	d0,-(a6)	move.l	(a7)+,d3	move.l	(a7)+,d2END-CODE.THEN0 .IF   \ High level version: LT.CALC.LINES { addr nchars LineStarts | linePtr -- #lines }	0 linestarts !  \ set first line to start with 0th character	LineStarts cell+ -> linePtr  \ point to line #1 start\ find beginnings of lines	addr	nchars 0	DO 	dup c@ EOL =		IF			i 1+ ( offset of char after EOL )			LinePtr ! ( LineStart )			linePtr cell+ -> linePtr		THEN		1+	LOOP	drop\ calc #lines	linePtr LineStarts - cell/ 1-;.THEN: LT.ADD.LINESTARTS { line# n -- add N to linestarts after line# }	line# 1+ -> line#	line# lt_header ..@ lth_LineStarts lt.LineStart[]  ( LineStart )	lt_header ..@ lth_nlines 1+	line#	DO	n over +!		cell+	LOOP	drop;: LT.RECALC.LINES  ( -- )	lt.get.text	lt_header ..@ lth_linestarts	lt.calc.lines	lt_header ..! lth_nlines;: LT.DUMP.HEADER  ( header -- )	dup lt.set.current	." Nchars = " dup ..@ lth_nchars . cr	." Nlines = " dup ..@ lth_nlines . cr	..@ lth_nlines 20 min 0	DO i lt.line#>text type cr	LOOP;: LT.CLEAR.HEADER  ( header -- )	dup lt.check.valid\ ." Entering LT.CLEAR.HEADER" unravel	dup ..@ lth_TextAddr ?dup	IF		mm.free		0 over ..! lth_TextAddr	THEN	dup ..@ lth_LineStarts ?dup	IF		mm.free		0 over ..! lth_LineStarts	THEN	drop;: LT.FREE.HEADER ( header -- )	dup lt.clear.header	mm.free;: LT.ALLOC.TEXT { nchars | textmem -- textmem }	lt_header lt.clear.header	nchars lt_text_extra + mm.alloc? dup -> textmem	IF		textmem lt_header ..! lth_TextAddr		nchars lt_header ..! lth_NChars		nchars lt_text_extra + lt_header ..! lth_MaxText	THEN	textmem;: LT.NO.MEMORY ( -- , give message of no memory )	" Not enough memory for operation." dialog.a;: LT.ALLOC.STARTS { nlines | LineStarts -- LineStarts }	0 lt_header ..! lth_LineStarts	nlines lt_header ..! lth_NLines	nlines lt_starts_extra +  \ room for more lines without expanding LineStarts	dup lt_header ..! lth_MaxLines	cell*  mm.alloc? dup -> LineStarts	IF		LineStarts lt_header ..! lth_LineStarts	ELSE		lt.no.memory		lt_header lt.clear.header		0 -> LineStarts	THEN	LineStarts;: LT.SET.TEXT  { addr nchars | textmem LineStarts ifaddcr -- textmem | 0 }\ add a CR if not present	addr nchars + 1- c@ EOL <>	IF	nchars 1+ -> nchars		true -> ifaddcr	ELSE false -> ifaddcr	THEN	lt_header lt.clear.header	nchars lt.alloc.text dup -> textmem	IF\ copy in chars		addr textmem  nchars cmove\\ Add CR if needed		ifaddcr		IF	eol lt.get.text + 1- c!		THEN\\ allocate line records		addr nchars EOL count.chars		lt.alloc.starts dup -> LineStarts		IF			addr nchars LineStarts  lt.calc.lines drop		ELSE			lt_header lt.clear.header			0 -> textmem		THEN	THEN	textmem;\ ----------------------------------------------------------------------\ Code beyond this point should not know the internals of blocks or lines records!!\ ----------------------------------------------------------------------\ Low level code for handling tabs\ Convert string with tabs to string with extra spaces260 constant EXP_MAXcreate ExpBuf exp_max 2+ allotvariable ExpMany\ High level version for development: >EXP  ( char -- , add char to buffer )    ExpMany @ dup exp_max >	IF ." EXPAND.TABS - string too long!" cr unravel abort		drop exp_max	ELSE 1 ExpMany +!	THEN	ExpBuf + c!;: EXP.#SPACES  ( -- #spaces , to substitute for a TAB )	ExpMany @ 3 and 4 swap -;9 constant TAB_CHAR: EXPAND.TABS ( addr len -- addr' len' )	ExpMany off	0	DO dup c@ dup TAB_CHAR =		IF drop exp.#spaces 0			DO bl >exp			LOOP		ELSE >exp		THEN		1+	LOOP drop	ExpBuf ExpMany @;: LT.HIT.TEST  { xpos addr len | accum indx -- indx }\ calc char hit in line\ account for horizontal scrolling	lt_header ..@ lth_leftcol lt_charwidth * xpos + -> xpos	0 -> accum  \ accumulate string width	0 -> indx	ExpMany off	len 0	DO	addr i + c@ tab_char = \ is it a TAB ?		IF lt_CharWidth Exp.#Spaces			dup ExpMany +!  *  \ width of N spaces		ELSE lt_CharWidth  1 ExpMany +!		THEN  ( -- width )		accum + dup -> accum		xpos >		IF LEAVE		ELSE i 1+ -> indx		THEN	LOOP	indx;: LT.PUT.SELECT  ( start end -- )\ check order	2dup > abort" LT.PUT.SELECT out of order!"\ clip to end of file	lt_header ..@ lth_nchars min		lt_header ..! lth_selend\ set selstart and calc line and offset	0 max dup lt_header ..! lth_selstart	lt.char#>line#off lt_header ..! lth_curcol	lt_header ..! lth_curline#;: LT.GET.START  ( -- start )	lt_header ..@ lth_selstart;: LT.GET.SELECT  ( -- start end )	lt.get.start	lt_header ..@ lth_selend;: LT.START.READ  ( n -- , set starting index for later reads )	lt-now-at !	-1 lt-next-line !;: LT.READ.NEXT { | line# offset -- addr count true | false }\ This may return part of a line if in middle.	lt-next-line @ -> line#	line# 0<	IF ( first read so get first line based on start-at )		lt-now-at @ lt.char#>line#off -> offset		-> line#	ELSE 0 -> offset	THEN\	line# lt_header ..@ lth_nlines <	IF		line# 1+ lt-next-line !		line# lt.line#>text		offset - swap offset + swap		dup lt-now-at +!   true	ELSE		false	THEN;: LT.READ.SEL  ( -- addr count true | false , read selected text )	lt.read.next dup	IF	lt-now-at @ lt_header ..@ lth_selend - dup 0>		IF ( -- addr count flag #over )			swap >r - dup 0>			IF r>			ELSE 2drop rdrop false			THEN		ELSE drop		THEN	THEN;\ Display Routines ------------------------------------------: LT.SETPORT  ( -- , set tio grafport in header )	lt_header ..@ lth_grafport SetPort();: LT.DRAWTEXT  ( addr count -- )	0 swap DrawText();: LT.DRAW.LINE  ( line# -- , draw text at current position)	lt.line#>text 1- 0 max	expand.tabs	lt_header ..@ lth_leftcol  swap  over -  ( addr offset count' )	dup 0>	IF lt.columns.vis min DrawText()	ELSE 3drop	THEN;: LT.LINES.VIS (  -- #lines , visible in current window )	lt_header .. lth_dest	dup ..@ rect_bottom	swap ..@ rect_top -	lt_lheight /;: LT.LEFT.EDGE  ( -- x , of drawing rectangle )	lt_header .. lth_dest ..@ rect_left 4+;: LT.LINE#>XYLO  ( line#  -- x y , lowest part for highlighting  )	lt_header ..@ lth_topline# -  \ calc line on screen\ this is for drawing text	1+ lt_lheight *	lt_header .. lth_dest ..@ rect_top  + >r  ( save Y )	lt.left.edge ( get x of edge )	r>;: LT.LINE#>XY  ( line# -- x y , calc xy baseline of start of text)	lt.line#>xylo  lt_descent -;: LT.MOVE  ( line#  -- , move graphics cursor to start of line )	lt.line#>xy >r 1+ r> MoveTo();: LT.TEXT>WIDTH  ( addr count -- width )	expand.tabs	0 swap TextWidth();: LT.L#O>XYLO  ( line# offset -- x y , for highlighting )	over lt.line#>addr ( line# offset addr )	swap lt.text>width >r ( line# width )	lt.line#>xylo	swap r> +\ account for horizontal scroll	lt_header ..@ lth_leftcol lt_charwidth * - 0 max	swap;: LT.Y>LINE# ( y -- line# )	lt_header .. lth_dest ..@ rect_top -	lt_lheight /	lt_header ..@ lth_topline# +	lt_header ..@ lth_nlines 1- min	0 max;: LT.XLINE#>INDEX ( xpos line# -- index )	lt.line#>text 1- 0 max	lt.hit.test;: LT.XY>INDEX ( x y -- index )	lt.y>line#  ( x line# )	dup lt.line#>char# >r  ( x  line )	lt.xline#>index r> +;: LT.FILL.RECT  ( x1 y1 x2 y2 -- rect )    gr-rect 4+ w!    2 pick 1+ max  ( make sure at least one pixel wide )		gr-rect 6 + w!    gr-rect w!    gr-rect 2 + w!	gr-rect;: LT.RECT  ( x1 y1 x2 y2 -- , xor rectangle )    lt.fill.rect PaintRect();: LT.EraseRECT  ( x1 y1 x2 y2 -- , xor rectangle )    lt.fill.rect EraseRect();: LT.XRECT  ( x1 y1 x2 y2 -- , xor rectangle )	gr_xor_mode PenMode()	>r >r lt_topy max r> r> lt_topy max  \ clip out of status area	lt.rect	gr_insert_mode PenMode();: LT.HIGH.RIGHT  ( x y  -- , highlight to right of point )	dup lt_lheight - swap	lt_header .. lth_dest ..@ rect_right swap	lt.xrect;: LT.HIGH.LEFT  ( x y -- , highlight to left of point )	lt.left.edge -rot ( x1 x2 y2 )	dup lt_lheight - -rot	lt.xrect;: LT.HIGH.LINE  { line#  -- }	line#  lt.line#>xylo	lt.high.right;: LT.HIGH.LINE.OFF {  line#1 l1off line#2 l2off | col# -- }	lt.setport	line#2 line#1 =	IF \ all on one line		l1off l2off =		IF ( just one vertical bar )			line#1 l1off lt.l#o>xylo			ExpMany @ -> col#			dup>r lt_lheight -			over r>			lt.xrect			lt-cursor-state @ 0= lt-cursor-state !  \ toggle state		ELSE			line#1 l1off lt.l#o>xylo			ExpMany @ -> col#			lt_lheight -			line#2 l2off lt.l#o>xylo 			lt.xrect			lt-cursor-state off		THEN	ELSE line#2 line#1 - 1 >		IF \ must highlight several selected lines			line#2 line#1 1+			DO i lt.high.line			LOOP		THEN		line#1 l1off lt.l#o>xylo lt.high.right		ExpMany @ -> col#		l2off 0>		IF line#2 l2off lt.l#o>xylo lt.high.left		THEN		lt-cursor-state off	THEN;: LT.HIGH.SEL { selstart selend -- }	selstart lt.char#>line#off	selstart selend <>	IF	selend lt.char#>line#off	ELSE 2dup	THEN	lt.high.line.off	;: LT.HIGHLIGHT  ( -- )	lt.cur.line lt_header ..@ lth_curcol  ( -- line col )	lt.get.select <>	IF	lt_header ..@ lth_selend lt.char#>line#off	ELSE 2dup	THEN	lt.high.line.off	;: LT.CURSOR.ON  ( -- , turn cursor on if off )	lt-cursor-state @ 0=	IF lt.highlight	THEN;: LT.CURSOR.OFF  ( -- , turn cursor off if on )	lt-cursor-state @	IF lt.highlight	THEN;: LT.INVALRECT  ( -- , invalidate current view rectangle )	lt_header .. lth_dest InvalRect();: LT.GOTO.LINE ( line# -- , display that line at top of window )	0 max	lt_header ..@ lth_nlines 1- min	lt_header ..! lth_topline#;: LT.WHERE.LINE ( -- line# , top line displayed )	lt_header ..@ lth_topline#;: CLipRect() ( rect -- )	pass: 4 trap: a87b;lt_topy 4- constant lt_statusy: LT.STATUS.TEXT  ( $string x -- )	lt_statusy MoveTo()	count lt.drawtext;: LT.STATUS.NUM  ( n x -- )	base @ >r decimal	dup 2 over 30 + lt_statusy lt.eraserect	lt_statusy MoveTo()	n>text lt.drawtext    \ draw new number	r> base !;: LT.CHANGE.STATUS  ( -- , display change status )	lt.changed? dup	IF " Changed!" 290 lt.status.text	ELSE lt_header ..@ lth_read_only		IF			" Read Only!" 290 lt.status.text		ELSE			290 2 340 lt_statusy lt.eraserect		THEN	THEN 	lt_header ..! lth_change_s;90 constant LT_STATUS_DX: LT.SETUP.STATUS  ( -- , display status on top line )	0 0 lt_header .. lth_dest ..@ rect_right		lt_topy 1- lt.eraserect	0 lt_topy 1- MoveTo()	lt_header .. lth_dest ..@ rect_right   lt_topy 1- LineTo()\	9 TextSize()	10 " Line#  = "   over lt.status.text	lt_status_dx + " Column = "  over lt.status.text	lt_status_dx + " #Chars = "  swap lt.status.text	lt.change.status	lt_TextSize TextSize();: LT.UPDATE.STATUS  ( -- )	lt.setport	lt-show-status @	IF		9 TextSize()		64 lt.cur.line   over lt.status.num		lt_status_dx + lt_header ..@ lth_curcol    over lt.status.num		lt_status_dx + lt_header ..@ lth_nchars    swap lt.status.num\		lt.changed? lt_header ..@ lth_change_s <>		IF lt.change.status		THEN		lt_TextSize TextSize()	THEN;: LT.DISPLAY ( -- , display from top line )	lt.setport	lt_header .. lth_dest  EraseRect()	4 TextFont()	lt_textsize TextSize()\\ draw some text so that CharWidth works	20 20 MoveTo()	"  " count lt.drawtext	lt.adjust.font\	lt_header ..@ lth_topline# dup>r	lt.lines.vis r@ + r>  \ start with first visible line	DO		i lt_header ..@ lth_nlines >=		IF LEAVE		THEN		i lt.move  ( move to start of line )		i lt.draw.line	LOOP drop	lt.setup.status	lt.update.status	lt-cursor-state off;\ Editing routines --------------------------------\ insert char into cache: (LT.CHANGE.HIGH)  { selstart selend | oldstart oldend -- , highlight new portion }	lt.get.select -> oldend -> oldstart\ do the two regions overlap?	selstart oldend <	selend oldstart > AND 	IF	selstart oldstart <>		IF selstart oldstart 2sort lt.high.sel		THEN		selend oldend <>		IF selend oldend 2sort lt.high.sel		THEN	ELSE lt.highlight		selstart selend lt.high.sel	THEN	selstart selend lt.put.select;: LT.CHANGE.HIGH ( selstart selend -- )	lt.get.select =	IF		lt.cursor.off		\ old selection was cursor		lt.put.select		lt.highlight	ELSE 2dup =   \ starting with range on		IF lt.highlight  lt.put.select  lt.highlight		ELSE lt-show-status @ >r lt-show-status off			(lt.change.high) r> lt-show-status !		THEN	THEN;: LT.MOVE.CURSOR  { delta -- }	delta 0<	IF lt.get.start delta + 0 max	ELSE lt_header ..@ lth_selend delta + 		lt_header ..@ lth_nchars 1- min	THEN	dup lt.change.high	lt.update.status;: LT.LINE#>RECT  ( line# -- x1 y1 x2 y2 )	lt.line#>xylo  ( x1 y )	dup lt_lheight - swap	lt_header .. lth_dest ..@ rect_right swap;: LT.UPDATE.LINE  { line# -- }	lt.setport	line# lt.line#>rect lt.eraserect	line# lt.move	line# lt.draw.line	lt.update.status;: LT.ADD.STRING  ( addr nchars -- , within current line, no CRs in line )\ used for adding single characters or strings on a single line{ addr nchars | target line#  -- , assume already chopped }	nchars 0>	IF		nchars lt.make.room.text		IF			lt.no.memory abort		THEN		lt.get.text lt.get.start - >r  ( # of chars to move up )		lt.get.start + -> target		target dup nchars + r> move\ move string into place		addr  target  nchars  cmove		lt_header ..@ lth_nchars  nchars +  lt_header ..! lth_nchars	THEN;: LT.ADD.TEXT  { addr nchars -- }	nchars 0>	lt.writeable? and \ 00001	IF		addr nchars lt.add.string\ extend linestarts array		addr nchars EOL count.chars lt.make.room.starts		IF			lt.no.memory abort		THEN		lt.recalc.lines		lt.get.start nchars + dup lt.put.select		lt.update.status		lt.mark.change	THEN;variable LT-CHAR-PAD: (LT.ADD.CHAR) { char | target -- , add single character }	1 lt.make.room.text	IF		lt.no.memory abort	THEN	lt.get.text lt.get.start - >r  ( # of chars to move up )	lt.get.start + -> target	target dup 1+ r> move	char target c!	lt_header ..@ lth_nchars  1+  lt_header ..! lth_nchars	lt.cur.line 1 lt.add.linestarts	lt.get.start 1+ dup lt.put.select	lt.update.status	lt.mark.change;: LT.ADD.CHAR ( char  -- , add single character )	lt.writeable? \ 00001	IF		(lt.add.char)	ELSE		drop	THEN;28 constant LEFT_CHAR29 constant RIGHT_CHAR31 constant DOWN_CHAR30 constant UP_CHAR: LT.REDRAW  ( -- , force redraw of screen)	lt.display lt.highlight;: LT.REDRAW.CUR.LINE  ( -- , redraws current line )	lt.cur.line lt.update.line lt.highlight;: LT.FORCE.VISIBLE  ( line# -- , force to center if not visible )	dup	lt.where.line  dup lt.lines.vis 1- + within? not	IF  \ move to new top of line		8 - 0 max lt.goto.line lt.invalrect	ELSE drop	THEN;\ UNDO buffervariable LT-UNDO-BUFFERvariable LT-UNDO-SIZEvariable LT-UNDO-MAXvariable LT-UNDO-POS: LT.UNDO.FREE ( -- )	lt-undo-buffer @ ?dup	IF		mm.free	THEN	lt-undo-max off	lt-undo-buffer off	lt-undo-size off;: LT.UNDO.ALLOC ( nbytes -- )	lt.undo.free	dup mm.alloc?  \ try to alloc space	dup lt-undo-buffer ! \ save 0 or address	IF		lt-undo-max !	ELSE		drop	THEN;	: LT.LOAD.UNDO { start end | nchars -- }	end start - -> nchars	nchars 1 >	IF		lt-undo-max @ nchars <		IF			nchars lt.undo.alloc  \ allocate space if needed		THEN		lt-undo-max @ nchars >=  \ do we have room?		IF			start lt.char#>addr			lt-undo-buffer @			nchars move  \ copy text to undo buffer			nchars lt-undo-size !			start lt-undo-pos !		THEN	ELSE\ move position down if cut from below		nchars 1 =		IF			start lt-undo-pos @ <			IF				lt-undo-pos @ 1- 0 max lt-undo-pos !			THEN		THEN	THEN;\ Text deletion --------------------------------------\ chop multi lines\ merge lines8 constant BS_CHAR: LT.CHOP.REGION { start end | nchars ifredraw -- , chop specified part of text }	start end <>	lt.writeable? AND \ 00001	IF	end start - -> nchars\ copy text down		end lt.char#>addr		start lt.char#>addr		dup nchars EOL count.chars 0> -> ifredraw  \ redraw if chop CR		lt_header ..@ lth_nchars end - move\		lt_header ..@ lth_nchars nchars - lt_header ..! lth_nchars\		lt.recalc.lines		ifredraw		IF			lt.redraw		ELSE			lt.redraw.cur.line		THEN		lt.mark.change	THEN;: LT.CHOP  (   -- , chop out selected region )	lt.writeable? \ 00001	IF		lt.get.select		2dup lt.load.undo		over dup lt.put.select		lt.chop.region	THEN;: LT.BACKSPACE  ( -- , replace selected area with char )	lt.get.select =	IF lt_header ..@ lth_selstart 1- 0 max lt_header ..! lth_selstart	THEN	lt.chop;: LT.REFRESH.LINE  { line# | line char# selstart selend -- , draw and highlight a line }	line# lt.move	line# lt.line#>char# -> char#	line# lt.draw.line	char# lt.get.select >r max -> selstart	char# line# lt.line#>nchars + r> min -> selend	selstart selend <	IF selstart selend lt.high.sel	THEN;: LT.SCROLL.UP  ( -- if-moved , scroll towards top of file )	lt.where.line 1- dup 0<	IF	drop false	ELSE	dup lt.goto.line		lt_header .. lth_dest  ( rect to move )		0  lt_lheight		lt.get.update ScrollRect()\ now fill in line		lt.refresh.line		true	THEN;: LT.AUTO.UP  ( line# -- , scroll display up one line )	lt.where.line <	IF	lt.scroll.up drop	THEN;: LT.MOVE.UP  { oldsel | line# offset -- newsel , move cursor UP one line }	oldsel lt.char#>line#off  ( line line# offset )	-> offset -> line#	line# 1- dup 0<	IF drop oldsel	ELSE -> line#		line# lt.auto.up		line# lt.line#>char#  ( char#  )		line# lt.line#>nchars 1- offset min +	THEN;: LT.SCROLL.DOWN  ( -- if-moved , scroll towards bottom of file )	lt.where.line 1+ dup lt_header ..@ lth_nlines		lt.lines.vis -  1+ <	IF	dup lt.goto.line		lt_header .. lth_dest  ( rect to move )		0  lt_lheight negate		lt.get.update ScrollRect()\ now fill in line		lt.lines.vis 1- +  ( calc line# of bottom )		lt.refresh.line		true	ELSE drop		false	THEN;: LT.AUTO.DOWN  ( line# -- )	lt.where.line lt.lines.vis + 1- >	IF lt.scroll.down drop	THEN;: LT.MOVE.DOWN  { oldsel | line# offset -- newsel , move cursor DOWN one line }	oldsel lt.char#>line#off  ( line line# offset )	-> offset -> line#	line# 1+ dup lt_header ..@ lth_nlines <	IF		-> line#		line# lt.auto.down		line# lt.line#>char#  ( char#  )		line# lt.line#>nchars 1- offset min +	ELSE		drop oldsel	THEN;: COUNT.TABS { addr nchars | ntabs -- ntabs }\ simply count tabs at beginning of string	0 -> ntabs	nchars 0	DO addr i + c@ tab_char =		IF i 1+ -> ntabs		ELSE LEAVE		THEN	LOOP	ntabs;: GRAB.WORD ( addr count -- addr' count' )	2dup bl scan nip -;: AC$=  ( addr count $string -- flag )	count 2 pick =	IF swap text=	ELSE 2drop drop false	THEN;: CALC.INDENT { addr nchars | ntabs --> ntabs }	addr c@ ascii : =  \ starting a definition	IF 1 -> ntabs	ELSE addr nchars count.tabs -> ntabs		addr ntabs + c@ ascii ; =		IF 0 -> ntabs   \ end of definition		ELSE addr ntabs +   nchars ntabs - grab.word			ntabs 1+ -> ntabs			2dup " IF" ac$= not			IF 2dup " ELSE" ac$= not				IF 2dup " BEGIN" ac$= not					IF 2dup " WHILE" ac$= not						IF 2dup " DO" ac$= not							IF ntabs 1- -> ntabs							THEN						THEN					THEN				THEN			THEN 2drop		THEN	THEN;: CALC.UNDENT { addr nchars | ntabs --> ntabs }\ check for keywords that cause UNindent	addr nchars bl skip -> nchars -> addr	addr c@ ascii ; =  \ starting a definition	IF 99 -> ntabs	ELSE  addr nchars grab.word		1 -> ntabs		2dup " THEN" ac$= not		IF 2dup " UNTIL" ac$= not			IF 2dup " ELSE" ac$= not				IF 2dup " WHILE" ac$= not					IF 2dup " REPEAT" ac$= not						IF 2dup " LOOP" ac$= not							IF 0 -> ntabs							THEN						THEN					THEN				THEN			THEN		THEN 2drop	THEN;: LT.SMART.FORMAT  ( -- , handle smart formatting and indenting ){ | line# l1off ntabs ncut nadd -- , process return key , split current line }	lt_header ..@ lth_curline# -> line#	lt_header ..@ lth_curcol   -> l1off	line# 0>	l1off 0> AND	IF	line# lt.line#>text drop l1off \ look at line up to cursor		2dup calc.UNdent -> ncut  ( #tocut )  \ should we remove characters for THEN or ;		count.tabs -> ntabs		line# 1- lt.line#>text calc.indent -> nadd\\ cut tabs from beginning of line if needed		ncut 0>		IF			nadd ncut -	 0 max ( suggested #tabs )			ntabs swap - 0 max -> ncut ( number of tabs we need to cut )			ncut 0>			IF	line# lt.line#>char# dup ncut + lt.chop.region				ncut negate lt.move.cursor				l1off ncut - -> l1off				nadd ncut - 0 max -> nadd			THEN		ELSE  0 -> ncut		THEN\\ Add CR and some tabs to current position		line# lt.line#>text calc.indent -> nadd		lt-&0D nadd 1+  lt.add.text	ELSE lt-&0D 1 lt.add.text	THEN;variable LT-SMART-FORMATlt-smart-format on: LT.RETURN  ( -- )	lt.chop	lt-smart-format @	IF		lt.smart.format	ELSE		lt-&0D 1 lt.add.text	THEN\\ scroll automatically when hitting return if needed	lt.cur.line 2+ lt.where.line lt.lines.vis  + 1- >	IF lt.where.line 1+ lt.goto.line	THEN	lt.redraw;3 constant ENTER_CHAR: LT.TYPE  ( addr nchars -- )	lt.add.text	lt.redraw.cur.line;defer LT.OLD.TYPEdefer LT.OLD.CRvariable LT-TYPE-ON: LT.INSTALL.TYPE  ( --  , %Q %Q )	LT-TYPE-ON @ 0=	IF	what's type is lt.old.type		'c lt.type is type		what's cr is lt.old.cr		'c lt.return is cr		lt-type-on on	THEN;: LT.DEINSTALL.TYPE  ( --  %Q %Q )	LT-TYPE-ON @	IF	what's lt.old.type is type		what's lt.old.cr is cr		lt-type-on off	THEN;variable TX-EVENT-RECURSEvariable LT-DOWN-RECURSEdefer LT.OLD.ABORTvariable lt-ABORT-ON: lt.ABORT.OFF  ( -- )	lt-abort-on @	IF		what's lt.old.abort is abort		lt-abort-on off	THEN;: lt.ABORT  ( -- )	lt.deinstall.type	main_window SelectWindow()	." LT.ABORT - check edit window for messages!" cr	lt-down-recurse off	tx-event-recurse off	lt.abort.off	lt.old.abort;: lt.ABORT.ON  ( -- )	lt-abort-on @ 0=	IF		what's abort is lt.old.abort		' lt.abort is abort		lt-abort-on on	THEN;: LT.DO.ENTER { | line# offset -- , execute selected region or line }	depth >r	11111 22222 33333 44444   \ in case we eat some from stack	lt.get.select <>	IF		lt.abort.on		lt.get.start lt.start.read		BEGIN lt.read.sel		WHILE  ( -- addr count )  $interpret		REPEAT		lt.abort.off	ELSE \ do current line		lt.abort.on		lt_header ..@ lth_curcol -> offset		lt.cur.line -> line#		line# lt.line#>nchars 1- offset - lt.move.cursor lt.return		line# lt.line#>text		lt.install.type		lt-show-status @ >r  lt-show-status off		$interpret		r> lt-show-status !  lt.update.status		lt.deinstall.type		lt.abort.off	THEN	depth r> - 0 max xdrop   \ clean stack;: LT.ARROW.UP ( -- )	lt.get.start lt.move.up dup lt.change.high 	lt.update.status;: LT.ARROW.DOWN ( -- )	lt.get.start lt.move.down dup lt.change.high 	lt.update.status;: LT.FIX.HORIZONTAL  { |  col -- , adjust horizontal scroll if needed }	lt.cur.line lt.line#>text drop lt_header ..@ lth_curcol  ( addr count )	expand.tabs nip -> col	col lt_header ..@ lth_leftcol <	IF col 4- 0 max lt_header ..! lth_leftcol		lt.redraw	ELSE  col lt.columns.vis (  #cols-across )		lt_header ..@ lth_leftcol +  >		IF  col lt.columns.vis - 4+ lt_header ..! lth_leftcol			lt.redraw		THEN	THEN;: LT.NEW.POSITION  ( -- , update position and display if needed )	lt.cur.line lt.force.visible	lt.fix.horizontal;: LT.KEY  { char -- , replace selected area with char }	lt.setport	char	CASE		BS_CHAR		OF lt.backspace ENDOF		LEFT_CHAR	OF -1 lt.move.cursor ENDOF		RIGHT_CHAR	OF 1 lt.move.cursor ENDOF		UP_CHAR		OF lt.arrow.up ENDOF		DOWN_CHAR	OF lt.arrow.down  ENDOF		ENTER_CHAR	OF lt.do.enter ENDOF		$ 0D		OF lt.return ENDOF\ default operation		lt.chop lt.cursor.off		char lt.add.char		lt.redraw.cur.line	ENDCASE	lt.new.position;\ ----------------------------------------: POINT>XY  ( point -- x y , unpack xy )	dup $ FFFF and w->s	swap -16 shift w->s;: XY>POINT  ( x y -- point )	16 shift OR	swap $ FFFF and;variable LT-POINT: LT.POLL.MOUSE ( -- point , get current point from window )    lt-point Getmouse()    lt-point @;: LT.POLL.XY ( -- x y , get current x y from window )    lt.poll.mouse point>xy;: BUTTON()  ( -- flag , true if down )	0w>r trap: a974 wr>;variable LT-UP-TIME: LT.CLICK.DRAG { point extend | lastp newp sel_last sel_new sel_down  -- }	lt.setport	point -> lastp	point point>xy lt.xy>index -> sel_down\ if shift-click, stretch to last selection point	extend	IF lt.get.start sel_down >		IF   sel_down  lt_header ..@ lth_selend			dup -> sel_down		ELSE lt.get.start sel_down			over -> sel_down		THEN	ELSE sel_down dup	THEN lt.change.high	lt.update.status	sel_down dup -> sel_new -> sel_last\	BEGIN button()	WHILE lt.poll.mouse -> newp\ decide whether above or below rectangle, or if moved		newp point>xy nip\ above rectangle?		dup lt_header .. lth_dest ..@ rect_top <		IF	drop sel_last lt.move.up\ below retangle?		ELSE lt_header .. lth_dest ..@ rect_bottom >			IF	sel_last lt.move.down\ moved?			ELSE newp lastp <>				IF	newp point>xy					lt.xy>index				ELSE sel_last				THEN			THEN		THEN -> sel_new		newp -> lastp			\ now highlight new region		sel_last sel_new <>		IF	sel_down sel_new 2sort lt.change.high			sel_new -> sel_last			lt.update.status		THEN	REPEAT;: LT.CHAR#>WORD { ndex | line# offset selstart selend nchars addr -- selstart selend }\ give back whole word	ndex lt.char#>line#off -> offset -> line#	line# lt.line#>text -> nchars -> addr\ scan forwards for next whitespace	nchars offset	DO i addr + c@ BL <=		IF i offset - ndex + -> selend			LEAVE		THEN	LOOP\ scan forwards for last whitespace	ndex offset - -> selstart   \ default if not found	offset 0	DO addr offset + 1- i - c@ BL <=		IF ndex i - -> selstart			LEAVE		THEN	LOOP	selstart selend 2sort;: LT.DOUBLE.CLICK  ( point extend  -- )	drop point>xy lt.xy>index	lt.char#>word lt.change.high;: LT.CLICK  { point extend  -- }	TickCount() lt-up-time @ -	GetDblTime() <	IF point point>xy lt.xy>index lt.get.start =		IF point extend lt.double.click		ELSE point extend lt.click.drag		THEN	ELSE point extend lt.click.drag	THEN	TickCount() lt-up-time !;: LT.INSERT { addr nchars -- }	lt.chop	addr nchars lt.add.text;: LT.NEW.HEADER  ( -- header )	sizeof() lt_head mm.zalloc? dup 	IF		dup lt.set.current		dup lt.init.header		lt-&0D 1 lt.set.text 0= abort" LT.NEW.HEADER - no mem!"		0 lt.goto.line		lt_header lt.check.valid	THEN;\ -------------------------------------------variable LT-CLIPBOARD   \ 0 or allocated memory pointervariable LT-CLIPSIZE	\ 0 or size of clipped text: LT.FREE.CLIP  ( -- free any allocated clipped text )	lt-clipboard @ ?dup	IF mm.free lt-clipsize off		lt-clipboard off	THEN;: LT.GET.SELTEXT { | addr nchars start end -- addr count }\ return text of selected region as one block	lt.get.select over - >r	lt.char#>addr r>;: LT.COPY  { | addr nchars -- }	lt.free.clip	lt.get.seltext  -> nchars -> addr	nchars 0>	IF	nchars mm.alloc? ?dup		IF	lt-clipboard !			nchars lt-clipsize !			addr lt-clipboard @ nchars cmove  \ copy to past buffer		ELSE lt.no.memory abort		THEN	THEN;: LT.UNDO  ( -- , undo last edit )	lt-undo-size @ 0>	IF		lt-undo-pos @ dup lt.put.select		lt-undo-buffer @ lt-undo-size @		lt.insert		lt.redraw		lt.undo.free	THEN;: LT.CUT ( -- )	lt.copy lt.chop lt.redraw;: LT.PASTE ( -- )	lt-clipsize @ 0>	IF	lt-clipboard @ lt-clipsize @ lt.insert lt.redraw	THEN;: LT.INIT ( -- );: LT.TERM ( -- )	lt.free.clip;if.forgotten lt.term