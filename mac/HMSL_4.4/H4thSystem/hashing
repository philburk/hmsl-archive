\ Hash Forth Dictionary to speed compilation.\\ Hashing converts a name to a fairly unique\ number.  This number is used as an index into\ a hash table containing NFAs.  This is faster\ than doing a linear search through the linked\ fields of a normal forth dictionary.\\ Hashing can be turned on or off with HASH.ON\ or HASH.OFF .\\ Author: Phil Burk\ Copyright 1987 Phil Burk\ MOD: mdh 06/15/88 rewrote 'SAVE-FORTH', implemented 'HASH.COLD'\ MOD: PLB 08/08/88 Fix Increment=0 bug in HASH.SEARCH.LL\ MOD: mdh 08/28/88 added ASMHASH;\ MOD: PLB 9/9/88\ MOD: PLB 11/15/88 Removed FULL message. Added REALLOCATE msg.\ MOD: PLB 12/10/88 Added proper SMUDGE and UNSMUDGE\ MOD: PLB 1/11/89 Don't add to hash table if smudged.\      Check for vocabulary collisions.\ MOD: MDH 1/17/89 Add include? for ASM for builds with no modules\ MOD: MDH 1/22/89 Add flushemit after Rehashing...\ MOD: PLB 2/23/89 Move HASH.NEW.VOC call after HASH.EXPAND to\      avoid 1/2048 chance of recursion in a redefinition.\\ MOD: PLB 8/14/89 Converted to HMSL4th\ MOD: PLB 6/24/91 Make FINDNFA return 0,1,-1 flags\ 00001 PLB 2/21/92 FINDNFA return proper 1 for IMMEDIATE, -1 if NOT\ 00002 PLB 5/2/92 Deferred words for later assembly.\ 00003 PLB 7/6/92 Added HASH.USE.FORTH, see the file HASHING_PLUSANEW TASK-HASHINGdecimaltrue constant H4thH4th .IF\ These were defined lower down in JForthvariable HASH-STATEdefer REHASHdefer HASH.OFFdefer HASH.ONvariable TIBENDdefer HASH.COLD.THENEXISTS? HASH;.IF ." Don't redefine HASHING, FORGET old code or GURU!" cr    abort.THENdefer HASH-OLD-:CREATEdefer HASH-OLD-FINDdefer HASH-OLD-SMUDGEdefer HASH-OLD-UNSMUDGEvariable HASH-TABLE-PTR  \ hold address of tablevariable HASH-TABLE-SIZE \ maximum number of entriesvariable HASH-MANY       \ current number of entriesvariable HASH-DISPLACED  \ bumped word for smudgevariable HASH-#K         \ initial hash table sizevariable HASH-VOC-OFFSETvariable HASH-#COLLISIONSvariable HASH-FOUND?variable HASH-STOPPEDvariable HASH-REDEF      \ Set if word is overwritten.: .VAR ( addr -- , print nicely )    BL 16 emit-to-column ? cr;: HASH.DUMP  ( -- ) cr    ." Address = " hash-table-ptr .var    ." Maxentries = " hash-table-size .var    ." Many = " hash-many .var    ." Hash-#K = " hash-#k .var    ." Hash-State = " hash-state .var    ." #Collisions = " hash-#collisions .var    ." FINDNFA is " what's findnfa >name id. cr;\ Compile Time Initialization8 hash-#k !\ Create table of prime pairs near 1000sCREATE PRIMEK-PAIRS        1 ,  1009 ,  2027 ,  2999 ,  4001 ,     5009 ,  6089 ,  6959 ,  8009 ,  8999 ,     10007 , 11069 , 12041 , 13001 , 14009 ,     15137 , 16061 , 17027 , 18041 , 19079 ,    20021 , 21011 , 22037 , 23027 , 24107 ,    25031 , 26111 , 27059 , 28097 , 29021 ,     30011 , 31079 , 32027 , 33071 , 34031 ,    35081 , 36011 , 37019 , 37991 ,39 constant PRIMEK_MANY: PRIMEK ( N -- P , lowest of nearest prime pair )    dup primek_many <    IF cells primek-pairs + @    ELSE ." Past Prime Pair Table!" cr        1000 * 1-    THEN;: HASH.FREE ( -- , free space for table )    hash-table-ptr @ ?dup    IF ( -- addr )\ %H       freeblock		mm.free       hash-table-ptr off       hash-table-size off       hash-many off    THEN;: HASH.ALLOC  ( #K -- error , allocate space for table )    hash.free    primek 2+    dup hash-table-size !  ( set max )    cells ( -- #bytes )\ %H    memf_clear swap allocblock ?dup ( -- addr , zeroed RAM)	mm.zalloc ?dup	    IF hash-table-ptr ! false    ELSE true    THEN;\ Functions for generating Hash Keys.DEFER NAME>KEY   ( nfa -- key )defer name.4n+ \ 00002: NAME.4N+.F   ( nfa -- key , add characters )    0 swap  ( sum )    dup 1+ swap c@ 31 and 0  ( -- 0 addr count 0 )     DO ( -- sum addr )        i over + c@  \  dup cr emit space .s ( get char )        rot cells + swap    LOOP drop abs	$ FFFFFF and   \ %H added;exists? VOCABULARY .IF: NAME+VOC>KEY   ( nfa -- key )    name.4n+    hash-voc-offset @ +;' NAME+VOC>KEY is NAME>KEY.ELSE' NAME.4N+ is name>key.THEN: HASH.CHECK  ( hash# -- hash# , check for overflow or underflow )    dup hash-table-size @ 1- 0 swap within? not    IF . ." hash# out of range!" abort cr    THEN;: HASH>ADDR ( hash# -- addr , calc addr in table )    hash.check cells    hash-table-ptr @ + ( allocated array base );: HASH>NAME ( hash# -- nfa )    hash>addr @;false .IF: MATCH.NAMES.HIGH { nfa1 nfa2 | flag -- flag }    nfa1 c@ 31 and    nfa2 c@ 31 and =    IF  ( same length )        true -> flag        nfa1 nfa2 dup c@ 31 and 0        DO 1+ dup c@ >r           swap 1+ dup c@ r> -           IF false -> flag           THEN        LOOP 2drop flag    ELSE false    THEN;.THENtrue .IF: MATCH.NAMES  ( nfa1 nfa2 -- same? )    match.nfas  \ defined in kernel;.THENfalse .IFASM MATCH.NAMES ( nfa0 nfa1 -- if_equal )	movem.l		d0-d2/a0-a1,-(a7)	move.l		(a6)+,a0	adda.l		org,a0	move.b		$0(a4,tos)+,d1	move.b		(a0)+,d0	moveq.l		#$1f,d2	and.l		d2,d0	beq		2$	and.l		d2,d1	cmp.b		d0,d1	bne		2$	addq.l		#1,tos	move.l		tos,a1		\ nfa1+1	adda.l		org,a1	subq.l		#1,d11$:	cmpm.b		(a0)+,(a1)+	dbne.w		d1,1$	bne		2$	moveq.l		#$-1,tos	movem.l		(a7)+,d0-d2/a0-a1	rts2$:	moveq.l		#0,tos	movem.l		(a7)+,d0-d2/a0-a1	rtsEND-CODE.THEN: INCNUMCOL ( -- )    hash-#collisions @ 1+ hash-#collisions !;defer HASH.SEARCH.ARRAY \ 00002\ Return match or empty slot.: HASH.SEARCH.ARRAY.F { table modulus name | key hash# incr  -- hash# flag }    name name>key dup -> key    modulus  mod dup -> hash#\    ." Key = " key . ."  , hash# = " hash# . cr\    ." Modulus = " modulus . cr .s    hash>name ?dup     IF  name match.names        IF  true        ELSE key modulus mod 1 max -> incr  ( calculate increment )\            ." incr = " incr . cr            ( scan for match or empty slot )            false modulus 0            DO  1 hash-#collisions +!                 hash# incr + modulus mod   ( -- new_hash# )                dup -> hash#                hash>name ?dup                IF  name match.names                    IF drop true leave THEN                ELSE leave                THEN            LOOP        THEN    ELSE false    THEN    hash# swap;: HASH.USE.FORTH  ( -- , use Forth language for critical words )	hash.off	' hash.search.array.f is hash.search.array	' name.4n+.f is name.4n+	hash.on;\ set deferred words to use Forth based high level.' hash.search.array.f is hash.search.array' name.4n+.f is name.4n+\ Assembly language versions are defined in the file HASHING_PLUS: HASH.SEARCH ( name -- hash#matched true | hash#empty false )    >r hash-table-ptr @ hash-table-size @ r>    hash.search.array;: HASH.FIND.NAME ( name --  nfa true | oldname false )    dup hash.search ( -- name hash# flag )    IF  nip hash>name true    ELSE drop false    THEN;exists? vocabulary not .IF: HASH.NEW.VOC  ( voc-addr -- )	drop;.ELSE: HASH.NEW.VOC ( voc-addr -- )   vlink>' >name \ dup id. cr   name.4n+ hash-voc-offset !   ( set voc offset );: HASH.SEARCH.CONTEXT ( name --  nfa true | oldname false )    hash-found? off    hash-voc-offset @ >r    context maxvocs  cnt>range    DO  ( -- name )        i @  ?dup  0= ?LEAVE        hash.new.voc        dup hash.find.name        IF  ( -- name nfa )            nip hash-found? on leave        ELSE drop        THEN    CELL +LOOP    r> hash-voc-offset !    hash-found? @;  : HASH.SEARCH.VOCS ( name --  nfa true | oldname false )  hash.search.context dup 0=  IF     SEARCH-CURRENT @     IF        drop  CURRENT @ hash.new.voc        hash.find.name     THEN  THEN;: HASH.FIND ( name -- $name 0 | cfa_imm 1 | cfa -1 )\ Rehash if dictionary changed by modules, forget, etc.    hash-damaged @    IF rehash    THEN    hash.search.vocs    IF  dup name> swap immediate?        IF 1        ELSE -1        THEN    ELSE false    THEN;.THENH4th .IF: HASH.FINDNFA ( name -- $name 0 | nfa_imm 1 | nfa -1 )\ Rehash if dictionary changed by modules, forget, etc.    hash-damaged @    IF rehash    THEN	hash.find.name	IF	dup immediate?        IF 1   \ 00001 Return 1 for IMMEDIATE, -1 if not        ELSE -1        THEN	ELSE false	THEN;.THEN: HASH.FULL? ( -- if_half_full , check table for overflow )    hash-table-size @ 2/    hash-many @ <;: HASH.(SMUDGE)  ( -- , replace latest entry )    hash-old-smudge    current @ hash.new.voc    latest hash.search    IF  hash-displaced @ swap        hash>addr !    ELSE drop    THEN    -1 hash-many +!\    >newline latest id. ."  smudged" cr;: HASH.(UNSMUDGE) ( -- , restore latest )    hash-old-unsmudge    current @ hash.new.voc    latest dup hash.search drop hash>addr !    1 hash-many +!\    >newline latest id. ."  unsmudged" cr;: HASH.ADD.NAME ( nfa hash# -- , force add and update counter )    hash>addr dup @ hash-displaced ! !  ( save previous occupant )    1 hash-many +!;: HASH.ADD.IFROOM  ( nfa hash# -- )    hash.full?    IF  ( -- n h )        2drop        hash-stopped on\        ." Hash table full!" cr    ELSE        hash.add.name    THEN;: HASH.ADD.IFNEW ( name -- )    dup hash.search ( -- name hash# flag )    IF 2drop    ELSE ( -- n h# )        hash.add.ifroom    THEN;: HASH.ADD.REHASH ( nfa -- , add to hash table during rehash)    dup c@ 31 and    IF  dup c@ $ 20 AND  ( hidden? )        hash-stopped @ OR        IF drop        ELSE hash.add.ifnew        THEN    ELSE drop cr ." HASH.ADD.REHASH Name field is zero!"    THEN;: HASH.CLEAR ( -- )    0 hash-many !    hash-table-ptr @    hash-table-size @ cells    0 fill;H4th .IF: <HASH.OFF> ( -- , turn hashing off )    hash-state @    IF         what's hash-old-:create  is :create        what's hash-old-find     is findnfa        what's hash-old-smudge   is smudge        what's hash-old-unsmudge is unsmudge        hash-state off    THEN;' <hash.off> is hash.off.ELSE: <HASH.OFF> ( -- , turn hashing off )    hash-state @    IF         what's hash-old-:create  is :create        what's hash-old-find     is find        what's hash-old-smudge   is smudge        what's hash-old-unsmudge is unsmudge        ['] noop dup   is rehash   is hash.cold        hash-state off    THEN;' <hash.off> is hash.off.THEN: HASH.TERM  ( -- )    hash.off    hash.free;: HASH.ABORT ( -- )    hash.term    abort;exists? vocabulary .IF\ Check for vocabulary collisions.variable HASH-VOC-KEYvariable HASH-VOC-LINKvariable HASH-VOC-ERROR: HASH.VOC.ERROR ( nfa -- , report collision )    >newline ." WARNING! - Possible HASHING conflict between " id.    ."  and " hash-voc-link @ vlink>' >name id. cr    hash-voc-error on;: HASH.TEST.VOC  ( -- , compare each vocab against one )    voc-link    BEGIN @ dup    WHILE dup hash-voc-link @ -        IF ( different vocabulary )            dup vlink>' >name dup name.4n+ hash-voc-key @ =            IF hash.voc.error            ELSE drop            THEN        THEN    REPEAT drop;: HASH.CHECK.VOCS  ( -- , check vocabularies for collision )    hash-voc-error off    voc-link    BEGIN @ dup    WHILE dup hash-voc-link !        dup vlink>' >name name.4n+ hash-voc-key !        hash.test.voc    REPEAT drop    hash-voc-error @    IF  ." Please rename the new vocabulary!"  7 emit cr    THEN;redef? off: VOCABULARY  ( <name> -- , check after defining )    vocabulary    hash.check.vocs;redef? on.ELSE: HASH.CHECK.VOCS  ( -- ) ;.THEN: <HASH.REALLOC> ( #K -- )    dup hash.alloc    IF drop ." Could not allocate hash table!" cr       hash.abort    ELSE  hash-#k !    THEN;: HASH.EXPAND  ( -- , increase size of hash table )    hash-#k @ 4 +    <hash.realloc>\    ." Hash table reallocated - successfully!" cr;: <REHASH>  ( -- , hash all vocs )    hash.check.vocs    ."   Rehashing..." flushemit    BEGIN        0 hash-stopped !        hash.clear        hash-#collisions off        ['] hash.add.rehash is when-scanned        ['] hash.new.voc is when-voc-scanned        scan-all-vocs        hash-stopped @    WHILE        hash.expand    REPEAT    hash-damaged off    hash-redef off    14 0 DO backspace space backspace    LOOP    flushemit;\ Substitute words.: HASH.ADD.NEW ( nfa -- )    hash.full?    IF  hash.expand        rehash    THEN    current @ hash.new.voc  ( do this after hash.expand )    dup hash.search    IF hash-redef on ( mark as redefined for fast forget )    THEN    hash.add.name;: HASH.(CREATE)  ( -- , add to hash table , overwrite existing.)    HASH-OLD-:CREATE    latest hash.add.new;: CHECK.TIB.END  ( nfa -- , set TIBEND if NUL string )    c@ 0= tibend !;H4th .IF: HASH.FORTH.FINDNFA  ( name -- name 0 | nfa 1 | nfa -1 )    dup c@ dup 0= tibend ! \ check for null word at EOL    31 and    IF hash.findnfa    ELSE 0    THEN;.ELSE: HASH.FORTH.FIND  ( nfa -- nfa 0 | cfa 1 | cfa -1 )    dup c@ dup 0= tibend !    31 and    IF hash.find    ELSE 0    THEN;.THEN: HASH.INIT ( -- )    hash-#k @ hash.alloc    IF  ." No Room for hash Table!" cr        hash.abort    THEN    hash-voc-offset off    hash-state off;: <HASH.COLD>  cr ." Initializing HASHED Vocabulary Search..." flushemit cr  HASH.ON;h4th .IF: <HASH.ON> ( -- , start using hashing )    hash-table-ptr @ 0=    IF hash.init     THEN    hash-state @    IF \ ." Hashing already on!"    ELSE         what's :create is hash-old-:create        what's findnfa is hash-old-find        what's smudge is hash-old-smudge        what's unsmudge is hash-old-unsmudge        hash-state on    THEN    ['] hash.(create)    is :create    ['] hash.forth.findnfa  is findnfa    ['] hash.(smudge)    is smudge    ['] hash.(unsmudge)  is unsmudge	['] <rehash> is rehash    rehash;' <hash.on> is hash.on.ELSE: <HASH.ON> ( -- , start using hashing )    hash-table-ptr @ 0=    IF hash.init     THEN    hash-state @    IF \ ." Hashing already on!"    ELSE         what's :create is hash-old-:create        what's find is hash-old-find        what's smudge is hash-old-smudge        what's unsmudge is hash-old-unsmudge        hash-state on    THEN    ['] hash.(create)    is :create    ['] hash.forth.find  is find    ['] hash.(smudge)    is smudge    ['] hash.(unsmudge)  is unsmudge    ['] <rehash>         is rehash    ['] <hash.cold>      is hash.cold    rehash;' <hash.on> is hash.on.THEN: HASH.REALLOC ( #K -- , reallocate different size)    hash.off    <hash.realloc>    hash.on;: AUTO.INIT  ( -- )    auto.init    ." Initialize Hashing!" cr    hash.on;: AUTO.TERM  ( -- )	hash.term	auto.term;false .IF  \ not needed since SAVE-FORTH does DO.AUTO.TERM: SAVE-FORTH  ( -- , save in TERM state )  hash-state @ >r   hash.term  r@  IF     ['] <hash.cold>  ELSE     ['] noop  THEN  is hash.cold    save-forth  r@  IF     <hash.on>  ELSE     ['] noop is hash.cold  THEN  rdrop;.THENH4th NOT .IF: SAVE-FORTH  ( -- , save in TERM state )  hash-state @ >r   hash.term  r@  IF     ' <hash.cold>  ELSE     ' noop  THEN  is hash.cold    save-forth  r@  IF     <hash.on>  ELSE     ' noop is hash.cold  THEN  rdrop;.THENif.forgotten hash.term