\ STRUCTUREs are for interfacing with 'C' programs.\ Structures are created using :STRUCT and ;STRUCT\\ This file must be loaded before loading any .J files.\\ Author: Phil Burk\ Copyright 1986 Phil Burk\\ MOD: PLB 1/16/87 Use abort" instead of er.report\      MDH 4/14/87 Added sign-extend words to ..@\ MOD: PLB 9/1/87 Add pointer to last member for debug.\ MOD: MDH 4/30/88 Use fast addressing for ..@ and ..!\ MOD: PLB/MDH 9/30/88 Fixed offsets for 16@+long and 8@+long\        fixed OB.COMPILE.+@/! for 0 offset\ MOD: PLB 1/11/89 Added EVEN-UP in case of last member BYTE\ MOD: RDG 9/19/90 Added floating point member support\ MOD: PLB 12/21/90 Optimized ..@ and ..!\ 00001 PLB 11/20/91 Make structures IMMEDIATE with ALITERAL for speed\           Don't need MOVEQ.L  #0,D0 for 16@+WORD and 8@+WORD\ 00002 PLB 8/3/92 Added S@ and S!, and support for RPTR\\ This version for the H4th system.ANEW TASK-C_STRUCTdecimal\ STRUCT ======================================================: <:STRUCT> ( pfa -- , run time action for a structure)    [COMPILE] CREATE          @ even-up here swap dup ( -- here # # )        allot  ( make room for ivars )        erase  ( initialize to zero )		immediate \ 00001	DOES> [compile] aliteral \ 00001;\ Contents of a structure definition.\    CELL 0 = size of instantiated structures\    CELL 1 = #bytes to last member name in dictionary.\             this is relative so it will work with structure\             relocation schemes like MODULE: :STRUCT (  -- , Create a 'C' structure )\ Check pairs   ob-state @   warning" :STRUCT - Previous :STRUCT or :CLASS unfinished!"   ob_def_struct ob-state !     ( set pair flags )\\ Create new struct defining word.  CREATE      here ob-current-class !  ( set current )      0 ,        ( initial ivar offset )      0 ,        ( location for #byte to last )   DOES>  <:STRUCT>;: ;STRUCT ( -- , terminate structure )   ob-state @ ob_def_struct = NOT   abort" ;STRUCT - Missing :STRUCT above!"   false ob-state !\ Point to last member.   latest ob-current-class @ pfa->nfa -  ( byte difference  , for H4th )   ob-current-class @ cell+ !\\ Even up byte offset in case last member was BYTE.   ob-current-class @ dup @ even-up swap !;\ Member reference words.: ..   ( object <member> -- member_address , calc addr of member )    ob.stats? drop state @    IF   ?dup         IF   [compile] literal compile +         THEN    ELSE +    THEN; immediate-1 .IFHEX: 32@+WORD [ 205e w, 2028 w, 0000 w, 2d00 w, ] ;FORCE.INLINE SET.HEAD SET.TAIL: 32@+WORD.REL [ 205e w, 2028 w, 0000 w, 6702 w, D08C w, 2d00 w, ] ;FORCE.INLINE SET.HEAD SET.TAIL: 16U@+WORD [ 205e w, 7000 w, 3028 w, 0000 w, 2d00 w, ] ;FORCE.INLINE SET.HEAD SET.TAIL: 8U@+WORD [ 205e w, 7000 w, 1028 w, 0000 w, 2d00 w, ] ;FORCE.INLINE SET.HEAD SET.TAIL: 16@+WORD [ 205e w, ( 7000 w, ) 3028 w, 0000 w, 48c0 w, 2d00 w, ] ;   \ 00001FORCE.INLINE SET.HEAD SET.TAIL: 8@+WORD [ 205e w, ( 7000 w, ) 1028 w, 0000 w, 4880 w, 48c0 w, 2d00 w, ] ; \ 00001FORCE.INLINE SET.HEAD SET.TAIL: 32!+WORD [ 205e w, 215E w, 0000 w, ] ;FORCE.INLINE SET.HEAD: 32!+WORD.REL [ 205e w, 201E w, 6702 w, 908C w, 2140 w, 0000 w, ] ;FORCE.INLINE SET.HEAD: 16!+WORD [ 205e w, 201E w, 3140 w, 0000 w, ] ;FORCE.INLINE SET.HEAD: 8!+WORD [ 205e w, 201E w, 1140 w, 0000 w, ] ;FORCE.INLINE SET.HEADDECIMAL.ELSE   \ ASM versionCODE 32@+word	move.l	(a6)+,a0    move.l	$0(a0),d0	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAIL\ @ relocatable address, make it absolute 00002CODE 32@+word.rel	move.l	(a6)+,a0    move.l	$0(a0),d0	beq.s	@1	adda.l	a4,d0@1	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAILCODE 16U@+WORD	move.l	(a6)+,a0	DC.W	$7000	move.w	$0(a0),d0	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAILCODE 8U@+WORD	move.l	(a6)+,a0	DC.W	$7000	move.b	$0(a0),d0	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAILCODE 16@+WORD	move.l	(a6)+,a0	move.w	$0(a0),d0	ext.l	d0	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAILCODE 8@+WORD	move.l	(a6)+,a0	move.b	$0(a0),d0	ext.w	d0	ext.l	d0	move.l	d0,-(a6)END-CODE FORCE.INLINE SET.HEAD SET.TAILCODE 32!+word  ( val addr -- )	move.l	(a6)+,a0	move.l	(a6)+,$0(a0)END-CODE FORCE.INLINE SET.HEAD	CODE 32!+word.rel   ( val addr -- , store in relocatable form 00002 )	move.l	(a6)+,a0	move.l	(a6)+,d0	beq.s	@1	sub.l	a4,d0@1	move.l	d0,$0(a0)END-CODE FORCE.INLINE SET.HEADCODE 16!+word  ( val addr -- )	move.l	(a6)+,a0	move.l	(a6)+,d0	move.w	d0,$0(a0)END-CODE FORCE.INLINE SET.HEADCODE 8!+word  ( val addr -- )	move.l	(a6)+,a0	move.l	(a6)+,d0	move.b	d0,$0(a0)END-CODE FORCE.INLINE SET.HEAD.THENvariable OB-nfavariable OB-nfa-POKEvariable OB-nfa-0: OB.COMPILE.+@/! ( offset nfa pokeat nfa-0 -- )    ob-nfa-0 !    ob-nfa-poke ! ob-nfa !    dup 32767 >  abort" Structure member offset > 32767!"     ?dup	IF ob-nfa @ nfacall, (here)  \ use (here) to keep optimizer on		ob-nfa-poke @ - w!	ELSE ob-nfa-0 @ nfacall,    THEN;: !BYTES ( value address size -- )    CASE    cell OF ! ENDOF	-4 OF if.use->rel ! ENDOF \ 00002	ABS       2 OF w! ENDOF       1 OF c! ENDOF       true abort" ..! -  Not 1,2 or 4 bytes!"    ENDCASE;\ Compile old fashioned way.\ Use defered F! and F@ so floating point members can be supported when the\  FP module is later in the dictionary.defer S.F!defer S.F@: COMPILE+!BYTES ( [ value address ] offset size -- )    CASE    cell OF 'n 32!+word 2			'n !            ob.compile.+@/!         ENDOF	-4 OF 'n 32!+word.rel 2 \ 00002			'n A!            ob.compile.+@/!		ENDOF	ABS       2 OF 'n 16!+word 2			'n w!            ob.compile.+@/!         ENDOF       1 OF 'n 8!+word  2			'n c!            ob.compile.+@/!         ENDOF       10 OF [compile] literal compile + compile s.f!		 ENDOF       true abort" ..! -  Not 1,2 or 4 bytes!"    ENDCASE;\ These provide ways of setting and reading members values\ without knowing their size in bytes.: (S!) ( offset size -- , compile proper fetch )	state @    IF  compile+!bytes     ELSE ( -- value addr off size )        >r + r> !bytes    THEN;: S! ( value object <member> -- , store value in member )    ob.stats?	(s!); immediate: ..! ( value object <member> -- , store value in member )    ob.stats?	dup -4 =  \ don't convert relative for ..!	IF drop 4	THEN	(s!); immediatevariable SIGNED-MEMBERS  ( if true, sign extend signed members )signed-members ON  ( default ): @BYTES ( addr +/-size -- value )    CASE    cell OF @  ENDOF       2 OF w@      ENDOF       1 OF c@      ENDOF      -4 OF @ if.rel->use      ENDOF \ 00002      -2 OF w@ w->s     ENDOF      -1 OF c@ b->s     ENDOF      10 OF s.f@	ENDOF       true abort" ..@ -  Not 1,2 or 4 bytes!"    ENDCASE;: COMPILE+@BYTES ( [ value address ] offset +/-size -- )    CASE    cell OF 'n 32@+word  4			'n @            ob.compile.+@/!         ENDOF       2 OF 'n 16u@+word 4			'n w@            ob.compile.+@/!         ENDOF       1 OF 'n 8u@+word  4			'n c@            ob.compile.+@/!         ENDOF    -4 OF 'n 32@+word.rel  8 \ 00002			'n a@            ob.compile.+@/!         ENDOF	    signed-members @ 0=	    IF ABS  ( ignore sign of member )	    THEN      -2 OF 'n 16@+word  6			'n 16@+word \ !!            ob.compile.+@/!         ENDOF      -1 OF 'n 8@+word   8			'n 8@+word \ !!            ob.compile.+@/!         ENDOF       10 OF [compile] literal compile + compile s.f@         ENDOF       true abort" COMPILE@BYTES -  Not 1,2 , -1,-2 or 4 bytes!"    ENDCASE;: (S@) ( offset size -- , compile proper fetch )	state @    IF compile+@bytes    ELSE >r + r> @bytes    THEN;: S@ ( object <member> -- value , fetch value from member )    ob.stats?	(s@); immediate: ..@ ( object <member> -- value , fetch value from member )    ob.stats?	dup -4 =   \ don't do it for ..@	IF drop 4	THEN	(s@); immediate\ These are aliases for use in reading AMIGA .J files.: | ( n m -- n|m , for easy AMIGA calls )   ORinline ;: << ( n m -- n<<m , shift left n by m )   ashift;\ NULL pointer for 'C'0 constant NULL\ Allocate a structure, state sensitive: (ALLOCSTRUCT)  ( size -- addr | 0 , allocate clear )    NewPtr();: ALLOCSTRUCT ( <structure> -- , allocate a structure )    [compile] sizeof()    state @    IF compile (allocstruct)    ELSE (allocstruct)    THEN; immediate