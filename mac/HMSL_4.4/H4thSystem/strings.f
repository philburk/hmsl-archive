\ STring support for H4th\\ MOD: PLB 11/5/90 Add coded version of $= to speed up local variable compilation\ MOD: PLB 10/7/91 Added $ROM and TEXTROM\ *********************************************************************\ * HMSL Forth System                                                 *\ * Author: Phil Burk                                                 *\ * Copyright 1989 Phil Burk , All Rights Reserved                    *\ *********************************************************************ANEW TASK-STRINGS.F\ Structure of string table: $ARRAY  (  )    CREATE  ( #strings #chars_max --  )         dup ,        2+ * even-up allot    DOES>    ( index -- $addr )        dup @  ( get #chars )        rot * + 4 +;\ Useful for alphabetical sorting or exact compare. Case sensitive.: COMPARE ( addr1 addr2 count -- flag , 0:equal, 1:s1>s2, -1:s1<s2 )	>r 0 -rot  ( default result ) r>    0    DO  dup c@		2 pick c@ - ?dup        IF	0>			IF rot drop 1 -rot			ELSE rot drop -1 -rot			THEN leave        THEN		1+ swap 1+ swap    LOOP 2drop;\ Compare two strings\ : $= ( $1 $2 -- flag , true if equal )\    -1 -rot\    dup c@ 1+ 0\    DO  dup c@ tolower\        2 pick c@ tolower -\        IF rot drop 0 -rot LEAVE\        THEN\		1+ swap 1+ swap\    LOOP 2drop\ ;\ use assembly version for locals: $=  ( $1 $2 -- flag , true if equal )	[	hex		205e w,  \    move    (dsp)+,a0		225e w,  \    move    (dsp)+,a1		4280 w,  \    clr.l   d0		1010 w,  \    move.b  (a0),d0		b308 w,  \ @1 cmpm.b  (a0)+,(a1)+		56c8 w, FFFC w, \    dbne.s  d0,@1		57c0 w,  \    seq     d0        4880 w,  \    ext.w   d0		48c0 w,  \    ext.l   d0        2d00 w,  \    move.l  d0,-(dsp)		decimal	];: TEXT=  ( addr1 addr2 count -- flag )    >r -1 -rot	r> 0    DO  dup c@ tolower        2 pick c@ tolower -        IF rot drop 0 -rot LEAVE        THEN		1+ swap 1+ swap    LOOP 2drop;: TEXT=?  ( addr1 count addr2 -- flag , for JForth compatibility )	swap text=;: $MATCH?  ( $string1 $string2 -- flag , case INsensitive )	dup c@ 1+ text=;: INDEX ( $string char -- false | address_char true , search for char in string )    >r >r 0 r> r>    over c@ 1+ 1    DO  over i + c@ over =        IF  rot drop            over i + rot rot LEAVE        THEN    LOOP 2drop    ?dup 0= 0=;: $APPEND.CHAR  ( $string char -- ) \ ugly stack diagram    over count + c!    dup c@ 1+ swap c!;\ ----------------------------------------------: ($ROM)  ( index address -- $string )    ( -- index address )    swap 0    DO dup c@ 1+ + even-up    LOOP;: $ROM ( packed array of strings, unalterable )    CREATE ( <name> -- )    DOES> ( index -- $string )  ($rom);: TEXTROM ( packed array of strings, unalterable )    CREATE ( <name> -- )    DOES> ( index -- address count )  ($rom) count;\ -----------------------------------------------