\ Low level I/O support for MIDI manager.\ This file was split from the file HH:H4th_MIDI+RTC so that the TIME\ file could be sandwiched between.\\ Author: Phil Burk\ Copyright 1989 Phil Burk, Larry Polansky, David Rosenboom\\ MOD: PLB 10/8/90 Make MIDIM.SEND more patient and forgiving.\ MOD: PLB 11/26/90 Reset MIDI.WRITE when Terminated\ MOD: PLB 6/24/91 Add MIDI.FIX.SPCONFIGANEW TASK-H4TH_MIDI_IOdecimalMIDIPacket MIDIM-OutPacket	\ For writing.variable MIDIM-NUMBYTES		\ number of bytes currently in packet from MIDI.XMIT248 constant MIDIM_MAX_BYTES: MIDIM.RESET  ( -- )	midim-numbytes off;: (MIDIM.SEND)  ( -- error , write packet with everything already set )    midim.outport.refnum	MIDIM-OutPacket MIDIWritePacket();: MIDIM.SEND ( -- , try to write, keep trying if no luck )	(midim.send)  ?dup	IF  w->s dup -258 =  ( could not write packets ?)		IF  true  ( flag for bad )			BEGIN 100 0				DO 100 msec (midim.send) 0=					IF drop false leave  ( change flag to true )					THEN				LOOP ( nosend? )				IF	." MIDIM.SEND - Tried to XMIT for 10 seconds and failed!" cr					." There may be too many MIDI events in the driver's buffer!?" cr					." To abort: Hit 'q' and wait !" cr					?terminal					IF key tolower ascii q = abort" MIDIM.SEND"					THEN false				ELSE true				THEN			UNTIL		ELSE ." MIDIM.SEND - Error = " dup .hex cr		THEN drop	THEN;: MIDIM.WRITE  ( addr count -- )\ Set length in packet	dup 6 + MIDIM-OutPacket ..! mp_length\\ Time stamp packet	vtime@ rtc.time@ max	midim-outpacket ..! mp_tStamp\\ Check to see if already in packet.	over midim-outpacket .. mp_data -  ( data not in OutPacket! )	IF  ( -- addr count , copy it there )		midim-outpacket .. mp_data swap cmove	ELSE 2drop	THEN	midim.send;variable MIDIM-CONTINUE  ( count of how many continuation packets )variable MIDIM-TIMEFLAG  ( set to midiTimeStampValid or midiTimeStampCurrent )midiTimeStampValid midim-timeflag !: MIDIM.FLUSH.PACKET ( -- , Send Packet to MIDI Manager )	midim-numbytes @ ?dup	IF	midim-OutPacket .. mp_data  ( addr )		swap midi.write		midim-numbytes off	THEN;: MIDIM.FLUSH  ( -- , called explicitly when a MIDI packet is finished )\ Set continuation bits as needed.\ If continuing, this will End Continuation	midim-continue @	IF midiEndCont  0 midim-continue !	ELSE midiNoCont	THEN	midim-timeflag @ + MIDIM-OutPacket ..! mp_flags	midim.flush.packet;: MIDIM.FLUSH.FULL  ( -- , flush because of full packet )	midim-continue @	IF midiMidCont	ELSE midiStartCont	THEN	midim-timeflag @ + MIDIM-OutPacket ..! mp_flags	1 midim-continue +!	midim.flush.packet;: MIDIM.XMIT  ( byte -- , tramsmit byte on current port )	midim-numbytes @ dup midim_max_bytes >	IF drop 0 midim.flush.full	THEN dup>r	MIDIM-OutPacket .. mp_data + c!	r> 1+ midim-numbytes !;: MIDIM.RTC.TIME@   ( -- recv.time , time packet received )	midi-port @ midim-inpackets ..@ mp_tStamp;: MIDIM.POLL ( port-id# -- , poll input port for bytes )	dup midim-inports w@   midiGetCurrent  midiPoll()	midim-inpackets >r\ Check for error flags	r@ ..@ mp_flags $ 70 and	IF ( MIDI manager error message packet )		r@ .. mp_data w@ midi-error !		midi.check.errors		0 r@ ..! mp_flags	ELSE  ( MIDI data packet )		r@ ..@ mp_length		6 - 0 max r@ ..! mp_length  ( subtract header length )		r@ .. mp_data r@ ..! mp_next_byte  ( reset pointer )	THEN	rdrop;: MIDIM.#INPACKET?  ( -- num_bytes )	midi-port @ midim-inpackets ..@ mp_length;: MIDIM.RECV.NEXT  ( -- byte , get next byte, no checking )	midi-port @ midim-inpackets	dup ..@ mp_length 1- over ..! mp_length   ( subtract count )	dup ..@ mp_next_byte dup c@ >r   ( -- packet next , get byte and save it )	1+ swap ..! mp_next_byte r>;	: MIDIM.RECV  ( -- byte true | false )	MIDIM.#INPACKET? 0=	IF  midi-port @ midim.poll		MIDIM.#INPACKET? 0>		IF midim.recv.next true		ELSE false		THEN	ELSE midim.recv.next true	THEN;: MIDIM.SER.INIT  ( -- )	midi-warnings on	midim.ports.init	midim.reset	'c midim.recv is midi.recv	'c midim.rtc.time@ is midi.rtc.time@	'c midim.write is midi.write	time.init;: MIDIM.SER.TERM ( -- )	time.term  ( turn off first since Timer uses ports )	midim.ports.term	midi.reset.vectors	." HMSL <-> MIDI Manager interface terminated." cr;: MIDI.FIX.SPCONFIG  ( -- , deallocate serial phone port )	$ 1FB c@ \ get value of SPCONFIG register	$ 40 COMP AND  \ turn off that bit	$ 1FB C!;: USE.MIDI.MANAGER ( -- , use MIDI Manager vectors )	midi.ser.term	'c midim.ser.init is midi.ser.init	'c midim.ser.term is midi.ser.term;use.midi.manager