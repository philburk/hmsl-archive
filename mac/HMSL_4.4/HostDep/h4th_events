\ O- Fix Drag Hooks so they preserve GraphPorts, temporarily disabled\\ Host dependant EVENT support.\\ Most modern interactive systems are event driven.\ This means that the top loop of the code gets events\ from the operating system and acts on them.  This gives the\ user more control over the application. \ \ The event types that are supported are:\    NULL - nothing happened\    MOUSE UP or DOWN\    MOUSE MOVE - optional, slows down system if used all the time.\    MENU events.\    WINDOWCLOSE\    REFRESH       same as UPDATE\\ Author: Phil Burk\ Copyright 1986  Phil Burk, Larry Polansky, David Rosenboom\\ MOD: PLB 12/4/86 Use create variable for EV-IF-INIT\ MOD: PLB 12/14/86 Base events on traps of MOUSEDOWN primitives.\ MOD: PLB 4/29/87 Force draw of HMSL menubar on activate.\ MOD: PLB 5/5/87 Setport for consistent GLOBALTOLOCAL call.\ MOD: PLB 7/1-8/87 Added menu trapping, SYS.INIT\ MOD: PLB 4/13/88 Add code for giving x,y for mousedown.\ MOD: PLB 8/7/91 Expand Grow and DragRects\ 00001 PLB 10/7/91 Add KEY Events\ 00002 PLB 10/24/91 Fix SHIFT_RIGHT_ARROW , was $ 0D = EOL !!!\ 00003 PLB 7/8/92 Allow variable size HMSL window default, save GROW and DRAG result.\ 00004 PLB 8/3/92 Add EV.2CLICK?ANEW TASK-H4TH_EVENTSdecimalvariable HMSL-MENUBAR\ Define device resolution 00003  0 value GR_XMIN490 value GR_XMAX  4 value GR_YMIN  ( Leave room at top for window bar. )290 value GR_YMAX\ Define default window 0000310 value GR_WINDOW_LEFT40 value GR_WINDOW_TOPgr_xmax value GR_WINDOW_WIDTHgr_ymax value GR_WINDOW_HEIGHT\ 00001variable IF-KEYS-ACTIVE  \ if true, allows key: input to screens, CTRL_TEXT, etc.IF-KEYS-ACTIVE ON$ 1D constant right_arrow$ 1C constant left_arrow$ 1E constant shift_right_arrow \ 00002$ 1F constant shift_left_arrowV: EV-LAST-CODEV: EV-LAST-MOUSE	\ Set by MOUSEDOWN handler, contains global x,yV: EV-LAST-DATA		\ Set by EV.GET.EVENTV: EV-LAST-TICKS    \ Saved for detecting double clicks.V: EV-PREV-TICKS    \ Time before for detecting double clicks.: EV.GET.MENUITEM  ( -- menu# item#)    ev-last-data @    dup -16 ashift $ FFFF and    swap $ FFFF and;V: POINT-REC: EV.GETXY  ( -- x y , get X,Y from previous mouse event)    ev-last-data 2+ w@ w->s	ev-last-data w@ w->s;: EV.GET.KEY  ( -- char , get key data saved by EV.GET.CLASS )	ev-last-data @ $ FF and;\ Mouse Tracking for tracked controls.CREATE EV-IF-TRACK-MOUSE 0 , ( true if tracking on )VARIABLE EV-LAST-MOUSEXVARIABLE EV-LAST-MOUSEY: EV.POLL.XY ( -- x y , get current x y from window )    hmsl-window @ Setport()    ev-last-data Getmouse()    ev.getxy;: EV.UPDATE.TRACK ( -- , update mouse tracking position )    ev.poll.xy ev-last-mousey !    ev-last-mousex !;: EV.TRACK.ON ( -- , turn on mouse tracking )    true ev-if-track-mouse !    ev.update.track;: EV.TRACK.OFF    false ev-if-track-mouse !;: EV.MOUSE.MOVED? ( -- flag , has mouse moved a significant ammount )    ev.poll.xy  ev-last-mousey @ =    IF ( -- x )        ev-last-mousex @ = 0=    ELSE drop true    THEN;\ Start code necessary for HMSL ---------------------------\ Define Mouse Event Codes in a host independant fashion.0 dup  constant EV_NULL1+ dup constant EV_MOUSE_DOWN1+ dup constant EV_MOUSE_UP1+ dup constant EV_MOUSE_MOVE1+ dup constant EV_MENU_PICK1+ dup constant EV_CLOSE_WINDOW1+ dup constant EV_REFRESH1+ dup constant EV_KEY   \ 00001drop\ Simple event queue for HMSL events. ----------------------\ We need a separate event queue because the I/O task must process\ all events ASAP to keep the windows alive.  HMSL, however,\ only wants certain events and only on demand.\ This makes it somewhat more like the Amiga OS.\ This queue is for events that occur in the HMSL-WINDOW which\ is the graphics window where HMSL screens are.16 constant EV_MAX_QUEUE6 constant EV_EVENT_SIZE\ Each event in HMSLs event queue has:\   Word 0 = event code\   Cell 1 = event data , xy or menu-item.VARIABLE EV-QUEUE  EV_MAX_QUEUE EV_EVENT_SIZE * VALLOT   ( byte array )VARIABLE EV-QMANY  ( number in queue, also index of next empty slot ): EV.REMOVE ( -- , remove head of queue )   -1 ev-qmany +!   ev-qmany @ 0>   IF  ( move others up )       ev-queue ev_event_size +  ( source address )       ev-queue ( destination ) ev-qmany @ ev_event_size * cmove   THEN;: EV.ADD.QUEUE   ( code data -- , add event code to event queue)    ev-qmany @  ev_max_queue >=    IF ev.remove    THEN    ev-queue ev-qmany @ ev_event_size * + ( address of event )    tuck 2+ !    w!    1 ev-qmany +!;: EV.FLUSH  ( -- , flush events from queue )    0 ev-qmany !;\ ----------------------------------------------------------------\ Install vectors that put the event in the HMSL event queue. -----V: EV-MOUSEDOWN?\ Macintosh Event What codes1 constant mButDwnEvt2 constant mButUpEvt3 constant keyDwnEvt4 constant keyUpEvt5 constant AutoKeyEvt6 constant updatEvt8 constant activateEvt15 constant app4Evt1 constant InMenubar2 constant InSysWindow3 constant INContent4 constant InDrag5 constant InGrow6 constant InGoaway1 constant ACTIVATEMASK: EV.MENU.FUNC!  ( cfa menuid -- , set menu handler table )	128 -	dup 0 15 within?	IF cell* menu-handlers + !	ELSE ." EV.MENU.FUNC! - Menu IDs must be 128-143" abort	THEN;: EV.MENUPICK  ( --  , Process menu selection. )	ev_menu_pick   \ get packed menu result	which-part @ ev.add.queue;: EV.WINDOW.CONTENT ( -- )	FrontWindow() which-window @ -	IF which-window @ SelectWindow()	ELSE    	last-event ..@ er_where  ( -- location )    	ev-last-mouse !		hmsl-window @ Setport()    	ev_mouse_down		ev-last-mouse 	GlobalToLocal()		ev-last-mouse @ ev.add.queue    ( add global coordinates )    	true ev-mousedown? !\\ save time of mouse down for double click		ev-last-ticks @ ev-prev-ticks !		TickCount() ev-last-ticks !	THEN;: EV.2CLICK? ( -- flag , true if last was double click )	ev-last-ticks @	ev-prev-ticks @ -	GetDblTime() <;: EV.WINDOW.GOAWAY  ( -- )    which-window @	last-event ..@ er_where	TrackGoAway()	IF	ev_close_window 0 ev.add.queue	THEN;Rect DragRectRect GrowRect28 DragRect ..! rect_top10 DragRect ..! rect_left2048 DragRect ..! rect_bottom2048 DragRect ..! rect_right\100 GrowRect ..! rect_top100 GrowRect ..! rect_left2048 GrowRect ..! rect_bottom2048 GrowRect ..! rect_right	: EV.WINDOW.DRAG  ( -- , drag window )	set.drag.hooks	which-window @	last-event ..@ er_where	DragRect DragWindow()	reset.drag.hooks\\ set default window position\	0 SP@ GetPort()		which-window @ SetPort()		0 sp@ LocalToGlobal()   \ find position of window		dup $ FFFF and -> gr_window_left		-16 shift $ FFFF and -> gr_window_top\	SetPort();: EV.WINDOW.GROW  ( -- , grow a window )	set.drag.hooks    which-window @	last-event ..@ er_where	GrowRect GrowWindow() ?dup	IF	which-window @ swap 		dup $ FFFF and dup -> gr_window_width   \ save as new default		swap -16 shift  dup -> gr_window_height ( unpack low and high x,y )		-1 SizeWindow()	THEN	reset.drag.hooks;: EV.MOUSEUP  ( -- , Act on Mouse UP )    ev-mousedown? @    IF  ev_mouse_up		last-event ..@ er_where   ev-last-mouse ! ( -- code location )        hmsl-window @ Setport()		ev-last-mouse 	GlobalToLocal()		ev-last-mouse @ ev.add.queue    ( add global coordinates )        false ev-mousedown? !    THEN;: EV.KEYDOWN  ( --  , Process key if in HMSL-window.)	last-event ..@ er_message $ FF and \ determine key hit	if-keys-active @	IF		ev_key swap ev.add.queue \ 00001	ELSE		key-holder !		if-key on	THEN;: EV.UPDATE  ( -- , UPDATE event handler )	last-event ..@ er_message BeginUpdate()	ev_refresh 0 ev.add.queue	last-event ..@ er_message EndUpdate();defer DRAW.HMSL.MENUSdefer UNDRAW.HMSL.MENUS'c noop is draw.hmsl.menus'c noop is undraw.hmsl.menus: EV.ACTIVATE ( -- )\\ Is this an activate event or deactivate event.    last-event ..@ er_modifiers activatemask AND    IF draw.hmsl.menus    ELSE undraw.hmsl.menus    THEN;: EV.APP4EVT  ( -- , respond to app4evt, probably a Suspend/Resume event )    last-event ..@ er_message dup $ FF000000 and $ 01000000 =	IF  ( -- msg , Suspend/Resume event )		dup 1 and		IF ." Resume Event!" cr		ELSE ." Suspend Event!" cr		THEN drop	ELSE drop	THEN;: DUMP.EVENT  ( -- )	." What    = " last-event ..@ er_what .hex	." , Message = " last-event ..@ er_message .hex	." , When    = " last-event ..@ er_when .hex	." , Where   = " last-event ..@ er_where .hex	." , Modifiers = " last-event ..@ er_modifiers .hex cr;: TEST  ( -- flag )    -1 last-event eventavail()	IF dump.event ?terminal	ELSE false	THEN;: TESTL  BEGIN TEST UNTIL ;: WAITNEXTEVENT?  ( -- flag , true if implemented )    $ 60 GetTrapAddress()   ( WaitNextEvent )    $ 9F GetTrapAddress()   ( Unimplemented Trap )    = NOT;: EV.HANDLE.EVENT ( -- )	last-event ..@ er_what	CASE		0 OF ( null event ) ENDOF		mButUpEvt  OF ev.mouseup ENDOF		keyDwnEvt	OF ev.keydown ENDOF		keyUpEvt	OF noop ENDOF						autokeyEvt	OF ev.keydown ENDOF		updatEvt OF ev.update ENDOF		activateEvt OF ev.activate ENDOF		app4Evt OF ev.app4evt ENDOF		IF-DEBUG @		IF	." EV - Unrecognized Event = " dup . cr		THEN	ENDCASE;: EV.HANDLE.DOWN ( -- )	which-part @	CASE		INContent	OF Ev.window.Content ENDOF		InDrag	OF	ev.window.Drag ENDOF		InGrow	OF	ev.window.Grow ENDOF		InGoaway	OF ev.window.goaway ENDOF		." Unrecognized FindWIndow() Result = " dup . cr	ENDCASE;\ Open a window:STRUCT WindowTracker	aptr	wt_EVHandler	aptr	wt_MDHandler	aptr	wt_Window;STRUCTWindowTracker  HMSL-Tracker: LINK.WINDOW<->TRACKER  ( window tracker -- )	2dup swap wRefCon + !  ( store in wRefCon )	..! wt_Window;\ Use Create so that value is preserved.CREATE EV-IF-INIT 0 ,: EV.INIT ( -- )    ev-if-init  @ 0=    IF        ev.flush        true ev-if-init !        false ev-mousedown? !\ Check to see if MultiFinder is active		WaitNextEvent? IFMULTI !\\ Initialize Tracker for events		'c ev.handle.event HMSL-tracker ..! wt_EVHandler		'c ev.handle.down HMSL-tracker ..! wt_MDHandler    THEN;: EV.TERM ( -- ,);: EV.GET.EVENT ( -- event_code , usage is host independant )	ev-qmany @ 0=	IF	?terminal drop  ( run check for events )	THEN\    ev-qmany @ 0> ( any events? )    IF ev-queue w@  ( take from head )       ev-queue 2+ @ ( get data and save )  ev-last-data !       ev.remove    ELSE\ Generate fake MOUSE event.        ev-if-track-mouse @        IF  ev.mouse.moved?            IF ev.update.track ev_mouse_move            ELSE ev_null            THEN        ELSE  ev_null        THEN    THEN;: EV.WATCH ( N -- , loop while real busy )	depth 0= abort" EV.WATCH takes N )	1 max 2000 min    0 DO        ev.get.event ?dup	IF  .  ev.get.menuitem swap . . cr	THEN		?terminal IF key emit THEN    LOOP;: SYS.INIT sys.init " ev.init" debug.type ev.init ;: SYS.TERM ev.term sys.term ;if.forgotten ev.term