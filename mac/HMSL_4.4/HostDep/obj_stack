\ OBJECT Stack =========================================\ This stack is used for storing the current object address.\ Access to instance variables is based on that address.\ This code is a good candidate for optimization.\\ Author: Phil Burk\ Copyright 1986 Delta Research\\ MOD: PLB 1/21/87 Add OS.DEPTH\ MOD: PLB 2/10/87 Assemble and optimize OS.PUSH and OS.DROP\ MOD: PLB 4/19/87 Optimize for Mac too.\ MOD: PLB 4/25/88 Add OS_MAX_DEPTH and expand to 256 bytes.\ MOD: PLB 8/21/89  This version specific to H4th.ANEW TASK-OBJ_STACK256 constant OS_SIZEos_size cell/ constant OS_MAX_DEPTHVARIABLE OBJECT-STACK os_size VALLOT\ VARIABLE OSSTACKPTR  ( defined in kernel ): OS.SP!  ( -- , SET USER STACK POINTERS )     object-stack os_size + osstackptr !; OS.SP!false .IF\ defined in kernelCODE OS.PUSH  ( N -- , Push onto object stack )   MOVE.L OSSTACKPTR,A0   MOVE.L  (A6)+,-(A0)   MOVE.L A0,OSSTACKPTR   RTSEND-CODECODE OS.DROP  ( -- , drop top of object stack )    ADDQ.L #$4,OSSTACKPTR    RTSEND-CODECODE OS.COPY  ( -- N , make copy of top of object stack )    MOVE.L OSSTACKPTR,A0    MOVE.L (A0),-(A6)    RTSEND-CODEONLY MAC ALSO FORTHCODE OS+ ( M -- N+M , add top of object stack )    MOVE.L OSSTACKPTR,A0    MOVE.L (A6),D0    ADD.L  (A0),D0    MOVE.L D0,(A6)    RTSEND-CODECODE OS+PUSH  ( N -- , Add to OS TOP and push onto object stack )   MOVE.L OSSTACKPTR,A0   MOVE.L (A0),D0  ( Get top. )   ADD.L  (A6)+,D0   MOVE.L D0,-(A0)   MOVE.L A0,OSSTACKPTR   RTSEND-CODE.THEN: OS.POP  ( -- N , pop from object stack )    os.copy  os.drop;: OS.DEPTH ( -- #cells , depth of object stack )    object-stack os_size +    osstackptr @ - cell/;: OS.PICK ( n -- Vn , pick value off object stack )    cell* osstackptr @ + @;\ Benchmarkif-testing @ .IFVARIABLE #OS.BENCH1000 #OS.BENCH !: OS.BENCH  123 #OS.BENCH @ 0    DO  os.push os.copy os.drop    LOOP drop;.THEN