\ Interrupt driven clock used to drive Apple MIDI Manager Clock\\ Based loosely on code provided by Joel Ryan of SteimANEW TASK-H4TH_IRQ_TIMERcreate IRQT-SAVE-REGS  5 cells allot64 constant IRQT_STACK_SIZEcreate IRQT-STACK irqt_stack_size cells allot \ make room for interrupt stack	4 cells allot \ a little safety from underflow: SETUP.IRQT.REGS  ( -- , setup registers for callback )	0 0 0 0   ( pad stack )	[	$ 41FA w, irqt-save-regs here - w,						\ lea		*-irqt-save-regs,a0		$ 48D07C00 ,	\ movem.l	a2-a6,(a0)	]	2drop 2drop	irqt-stack irqt_stack_size cells +  ( address for temp stack )	irqt-save-regs 4 cells + !  ( save in the right spot !! );setup.irqt.regsdefer service.timer' noop is service.timer: TIME.SERVER.ENTRY  ( -- )\ Setup H4th Registers for high level calls.	[	$ 48E7FFFE ,	\ movem.l   d0-d7/a0-a6,-(a7)		$ 41FA w, irqt-save-regs here - w,						\ lea		*-irqt-save-regs,a0		$ 4CD07C00 ,	\ movem.l	(a0),a2-a6	]	service.timer	[		$ 4cDF7FFF ,	\ movem.l   (a7)+,d0-d7/a0-a6	];\ Use Timer 1 for the real time clock. ---------------------------variable TIME-CURRENT  0 , \ timer incremented each interruptvariable OLD-VT1IRQ$ 1D4 constant VIA			( mac sys equ table handle for via base addr)$ 800 constant vT1C			( offsets to via base... TIMER1 COUNTER lo)$ A00 constant vT1CH	 	( timer1 counter hi)$ C00 constant vT1L			( timer 1 latch lo)$ E00 constant vT1LH	 	( timer 1 latch hi)$ 1600 constant vACR		( aux ctl reg)$ 1C00 constant vIER		( irq enable reg)$ 192 constant LVL1DT		( LEVEL 1 IRQ DISPATCH TABLE HANDLE)( ******************** via timer1 interrupt handler ******************** )EXISTS? ASM .IF\ irqhandler for via timer1; lower priority than midi\ A1= viabase at entry A0-A3,D0-D3  preservedASM IRQ.INC.TIMER.SERVE  ( -- , interrupt handler, just timer increment )		LEA		TIME-CURRENT,A0			\ address of special timer t1		ADDQ.L	#1,(A0)		\ increment T1 timer variable		BSR		TIME.SERVER.ENTRY		MOVE.L	via,A1		MOVE.B 	vT1C(A1),D0		\ a read clears via irq flagEND-CODE.ELSE: IRQ.INC.TIMER.SERVE2 ( -- , interrupt handler, just timer increment )\ irqhandler for via timer1; lower priority than midi\ A1= viabase at entry A0-A3,D0-D3  preserved	[ HEX		41FA W, TIME-CURRENT HERE - W,    \ LEA	TIME-CURRENT,A0  ( address of special timer t1)		5290 W,			                  \ ADDQ.L	#1,(A0)      ( increment T1 timer variable)		6100 W, ' TIME.SERVER.ENTRY HERE - W, \  BSR  TIME.SERVER.ENTRY		2278 W,  VIA W,	      \ MOVE.L	via,A1		1029 W,  VT1C W,	  \ MOVE.B 	vT1C(A1),D0		( a read clears via irq flag)	DECIMAL	];.THEN: IRQ.INC.TIMER  ( -- , interrupt handler, just timer increment , OBSOLETE)\ irqhandler for via timer1; lower priority than midi\ A1= viabase at entry A0-A3,D0-D3  preserved	[ HEX		41FA W, TIME-CURRENT HERE - W, \ LEA	TIME-CURRENT,A0			( address of special timer t1)		5290 W,			\ ADDQ.L	#1,(A0)			( increment T1 timer variable)		2278 W,  VIA W,	\ MOVE.L	via,A1		1029 W,  VT1C W,	\ MOVE.B 	vT1C(A1),D0		( a read clears via irq flag)	DECIMAL	];.THEN: IRQ.INC.MIDI  ( -- , interrupt handler, increment time and MIDI )\ irqhandler for via timer1; lower priority than midi\ A1= viabase at entry A0-A3,D0-D3  preserved	[ HEX		41FA W, TIME-CURRENT HERE - W, \ LEA	TEATIMER,A0			( address of special timer t1)		2010 W,			\ MOVE.L	(A0),D0		5280 W,			\ ADDQ.L	#1,D0			( increment time)		2080 W,			\ MOVE.L	D0,(A0)		3F3A W,	MIDIM-TimePort HERE - W,	\ MOVE.W	MIDIMTIME,-(A7)		2F00 W,			\ MOVE.L	D0,-(A7)		203C W,  5C0004 ,	\ MOVE.L	$5C0004,D0  ( code for SetCurTime )		A800 W,			\ Trap for package		6100 W, ' TIME.SERVER.ENTRY HERE - W, \  BSR  TIME.SERVER.ENTRY		2278 W,  VIA W,	\ MOVE.L	via,A1		1029 W,  VT1C W,	\ MOVE.B 	vT1C(A1),D0		( a read clears via irq flag)	DECIMAL	];\ VIA Support -----------------------: VIA.REG!  ( reg-offset -- , write to VIA chip register )	via @	\ get via base address from global variable	+ c!;: VIA.REG@  ( reg-offset -- , write to VIA chip register )	via @	\ get via base address from global variable	+ c@;: DISABLE.TIMER1.IRQ  ( -- , disable 6522  )	$ 40	\ mask for disabling interrupt	vier via.reg!	\ disable timer1 irq;: ENABLE.TIMER1.IRQ  (  -- , enable interrupts )	$ C0  ( enable mask )	vIER via.reg!;: GET.T1.HANDLER  ( -- cfa )	[ lvl1DT 24 + ] literal @;: SAVE.T1.HANDLER  ( -- , save old handler for T1 interrupt )	get.t1.handler old-vt1irq !;: SET.T1.HANDLER  ( cfa -- )	[ lvl1dt 24 + ] literal !;: RESTORE.T1.HANDLER ( -- )	old-vt1irq @  set.t1.handler ( restore old handler );: START.TIMER1  ( -- start timer1 running )	vACR via.reg@	$ 40 OR vACR via.reg! ( freerun mode );: STOP.TIMER1  ( -- start timer1 running )	vACR via.reg@	$ BF AND vACR via.reg! ( turn off freerun mode );: TIMER1.START.LATCH ( latch-period -- , turned on when latch values written )	dup $ FF and   ( low byte )	vT1L via.reg!  ( set low byte of latch )\ Interrupts will begin when counter hi written\ copies value to latch hi	-8 shift vT1CH via.reg!;: TIMER1.SET.LATCH  ( latch-period -- , set for timer rate )	dup $ FF and   ( low byte )	vT1L via.reg!  ( set low byte of latch )	-8 shift  vT1LH via.reg!;: TIMER1@  ( -- time )	vt1c via.reg@	vt1ch via.reg@ 8 shift or;: TPS->LATCH  ( ticks/second -- latch value )    782000 swap /;variable TIMER1-LATCH: TIMER1.LATCH!  ( latch-value  -- , countdown value )    dup TIMER1-latch !    timer1.set.latch;: TIMER1.RATE!   ( ticks/second -- )    tps->latch    dup $ FFFF >    IF drop $ FFFF dup tps->latch . ." is minimum for TIMER1.RATE!" cr    ELSE dup $ 300 <        IF  drop $ 300 dup tps->latch . ." is maximum for TIMER1.RATE!" cr        THEN    THEN	TIMER1.latch!;: TIMER1.RATE@ ( -- ticks/second )    TIMER1-latch @ ?dup    IF tps->latch    ELSE 60   ( default answer )    THEN;$ 208 constant SpVolCtl  ( saved volume control byte )$ 260 constant SdVolume  ( current volume ): TIMER1.CHECK.VOL  ( -- , abort if non zero )    SdVolume c@ 7 and    IF cr ." Sound volume forced to zero!!!" cr       ." The Mac local sound uses the same timer as the real time clock" cr       ." and will interfere with HMSL's timing in a serious way!" cr       ." I have set the volume to zero, and will restore it when HMSL is done." cr       0 SdVOlume c!    THEN;: TIMER1.RESTORE.VOL  ( -- )    SpVOlCtl c@ 7 and SdVolume c!;variable IF-TIMER-ON: TIMER1.TERM  ( -- , terminate timer system )    if-timer-on @    IF 	disable.timer1.irq		restore.t1.handler        0 if-timer-on !		timer1.restore.vol		midim.unconnect.time    THEN;: TIMER1.INIT	( -- , start Timer1 based Real Time clock )	if-timer-on @ 0=	IF	setup.irqt.regs		timer1.check.vol		disable.timer1.irq		save.t1.handler		midim-timeport w@		IF			'c irq.inc.midi		ELSE			'c irq.inc.timer.serve		THEN		set.t1.handler		start.timer1		enable.timer1.irq 		60 tps->latch dup timer1-latch !		timer1.start.latch		time-current off		if-timer-on on	THEN;: TIMER1.STOP ( -- )	timer1.term;: TIMER1.START ( -- )	timer1.init;: TIMER1.TIME@  ( -- time )	TIME-CURRENT @;: TIMER1.TIME!  ( time -- )	dup TIME-CURRENT ! midim.time!;: TIMER1.TIME+!  ( delta -- )	TIME-CURRENT @ + timer1.time!;: RTC.USE.TIMER1 ( -- )	rtc.term	'c timer1.start is RTC.START ( -- )	'c timer1.stop is RTC.STOP ( -- )	'c timer1.rate! is RTC.RATE! ( ticks/second -- )	'c timer1.rate@ is RTC.RATE@ ( -- ticks/second )	'c timer1.time! is RTC.TIME! ( time -- )	'c timer1.time+! is RTC.TIME+! ( time -- )	'c timer1.time@ is RTC.TIME@ ( -- time )	'c timer1.init is RTC.INIT  ( -- )	'c timer1.term is RTC.TERM ( -- )	rtc-use-midi off;rtc.use.timer1   ( Default Timer System ): USE.TIMER1.TIMING ( -- )	rtc.use.timer1 rtc.init;if.forgotten rtc.term