\ Basic Host Dependant Forth words.\ These are provided to make H4th into a generic Forth.\\ Author: Phil Burk\ Copyright 1989 Phil Burk\ All Rights Reserved\\ MOD: PLB 2/13/91 c/ashift/shift/ in CHOOSE for 62000 CHOOSE\ MOD: PLB 6/24/91 Add WARRAY BARRAY\ 00001 PLB 11/20/91 New EXIT, better DUP>RANEW TASK-H4TH_BASEdecimal:  N>TEXT ( number -- addr count , convert number to text )    (.);: TEXT>STRING ( address count -- $string , convert to string on pad )    dup pad c!  ( set count )    pad 1+ swap cmove    pad;: H. ( N -- , print a number in HEX )    base @ swap hex . base !;: BELL  ( -- , ring bell )    10 sysbeep();decimalCREATE MSEC-DELAY 257 ,  ( Default for Mac+ ): MSEC ( #msecs -- )    0    DO  msec-delay @ 0        DO LOOP    LOOP;: CALIBRATE.MSEC  ( -- , Calibrate millisecond timer )    800 msec-delay !    Tickcount()    [ 5 1000 * ] literal msec    Tickcount()    swap - dup . ."  ticks" cr  ( -- #ticks )    [ 5 60 *  800 * ] literal swap /    dup ." MSEC-DELAY now set to " . cr    msec-delay !;cr .( Now calibrating MSEC , the millisecond timer. ) crcalibrate.msec: NOTYET  ( -- )    ." NOT YET IMPLEMENTED!!" cr;decimal\ Many FORTHS differ in the way that they implement -FIND\ ' CFA PFA etc.  These should be avoided.\ For the sake of consistency I shall define how I am using these terms:\    CFA = address that can be passed to EXECUTE\    PFA = address of data in a create does word.\    LFA = address of backward link for dictionary.\    NFA = address of count byte for word name.HEX    : CFA->PFA  ( cfa -- pfa )	>body;DECIMAL: CFA->NFA  ( cfa -- nfa )	>name;: LFA->NFA  ( lfa -- nfa )    10 +;: LFA->CFA  ( lfa -- cfa )    lfa->nfa nfa->cfa;: CFA->LFA  ( cfa -- lfa )    cfa->nfa nfa->lfa;    : PFA->NFA   ( pfa -- nfa , convert )     [ 0 >body ] literal - cfa->nfa;: NFA->PFA ( nfa -- pfa )    name> >body;: HO.FIND.PFA   ( -- , pfa true | false , look for word in dict. )\ Return address of parameter data.     32 word find     IF  >body true     ELSE drop false     THEN;: HO.FIND.CFA   ( -- , cfa true | 0 , look for word in dict. )\ Return address of identifying address\ Returns code address for dumping or comparison.     32 word find     IF  true     ELSE ." Couldn't find " id. false     THEN;: V: ( -- , declare variable and set to zero )    variable;\ H4th uses absolute addresses.: USE->ABS; immediate: ABS->USE; immediate-1 u2/ constant HO_MAX_INTHO_MAX_INT 1+ CONSTANT HO_MIN_INTV: RAND-SEED here rand-seed !: RANDOM ( -- random_number )    rand-seed @    31421 * 6927 +     65535 and dup rand-seed !;: CHOOSE  ( range -- random_number , in range )    random * -16 shift;: WCHOOSE ( hi lo -- random_number )    tuck - choose +;\ Used for debugging.: WORD.DUMP ( -- , print the last word read from input )     here id.;: TIB.DUMP ( -- , Dump current line )     tib  #tib @ type;\ ======= ====== ARITHMETIC GOODIES ======== ========: | ( n m -- n|m , for easy AMIGA calls )	OR;\ ======= ====== Memory Access ==== ======== =========\ These words are used for accessing absolute memory locations\ like registers, etc.: ABS!   ( value absolute_address -- , store value )    !;: ABSW!   ( value absolute_address -- , store value )    w!;: ABSC!   ( value absolute_address -- , store value )    c!;: ABS@   ( absolute_address -- value , fetch value )    @;: ABSW@   ( absolute_address -- value , fetch value )    w@;: ABSC@   ( absolute_address -- value , fetch value )    c@;\ FORTH83 uses a different system for PICK !!!\ Mach2 conforms to Forth83, -> PICK is 0 based.: PICK83 PICK ;: PICK79 1- PICK ;0 constant NULL  ( for pointers ): HOST"  ( <text>" -- , compile a host string )    [compile] "  ( Mac uses count byte like Forth ); immediate." Declaring fake user variable!" cr: U: ( <name> -- , Make a variable )	V:;: XDUP ( x1 x2 x3 .. xN N -- x1 x2 .. x1 x2  , duplicate N items )    dup 1+ swap 0    DO dup pick79 swap    LOOP drop    ;\ Sort top two items on stack.: 2SORT ( a b -- a<b | b<a , largest on top of stack)    2dup >    IF swap    THEN;\ Sort top two items on stack.: -2SORT ( a b -- a>b | b>a , smallest on top of stack)    2dup <    IF swap    THEN;: WITHIN? ( N LO HI -- flag , true if within range )    2 pick <    IF 2drop false    ELSE < not    THEN;: FLUSHEMIT  ( -- , flush pending output, used in JForth's FASTIO );\ Stubs for JForth words..NEED INLINE: INLINE ; IMMEDIATE.THEN.NEED BOTH: BOTH ;   IMMEDIATE.THEN: ERASE ( addr count -- , clear memory )    0 fill;: DUP>R ( -- , must be inline , 00001 )	[ $ 2F16 w, ] \		move.l	(a6),-(a7); set.inline: BARRAY  ( #bytes -- ) ( index -- addr )    CREATE allot    DOES>  +;: WARRAY  ( #words -- ) ( index -- addr )    CREATE 2* allot    DOES> swap 2* +;: ARRAY  ( #cells -- ) ( index -- addr )    CREATE cell* allot    DOES> swap cell* +;\ Benchmark Forth words.: PRINT.TIME  ( #ticks -- , print as seconds )    100 *    60 /mod    swap 60 / + 0    <# # # ascii . hold #s #> type space;: MEASURE ( <tib> -- , benchmark whatever follows )    Tickcount() >r interpret Tickcount()    r> -     cr ." That took " print.time ." seconds." cr;V: MAX-INLINE   ( stub for JForth compatibility ): RDEPTH ( -- return_stack_depth )    r0 @ rp@ - cell/;: VALLOT ALLOT ;: RECURSIVE UNSMUDGE ; IMMEDIATE: RO.EXECUTE  ( rel_cfa -- )	rel->use execute;: RECURSE  ( -?- , compile call to self )    latest nfacall,; IMMEDIATE\ Support to allow the debugger to work with ODE.variable CURRENT-METHOD\ Initialization needed for all variables!!!: BASE.INIT      8 tab-width !      here rand-seed !;: BASE.TERM ;: S->D  ( s -- d  )    dup 0<	IF -1	ELSE 0	THEN;: 2**N  ( n -- 2**n )    1 swap shift;: .BIN  ( n -- )    base @ binary swap . base !;HEX: ODD@  ( addr -- val , fetch from an odd address )	[	5896 w,   \   addq.l  #4,(a6)		205e w,   \   move.l  (a6)+,a0		1d20 w,	  \   move.l  -(a0),-(a6)		1d20 w, 1d20 w, 1d20 w,	];." Fix RETURN so that it works with DO LOOPs" cr bell: RETURN ( -- )	compile exit; immediate\ Root definitions: SYS.INIT ( -- , Initialize system with chain of SYS.INIT definitions. )    ." Start of SYS.INIT chain." cr base.init ;: SYS.RESET ;: SYS.TERM ." End of SYS.TERM chain." cr ;