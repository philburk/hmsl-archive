\ Custom MIDI Interface\ This is sometimes needed because the MIDI manager is slow.\\ The direct use of the SCC chip is based on an article by Kirk Austin in MacTutor\ Author: Phil Burk\ Copyright 1990 Phil Burk\ All Rights Reserved\\ 00001 10/7/91 Check for 0= in MC.RUN.STATUS, was dropping 0s in sysex.\ 00002 10/7/91 Fix bug in MC.RECV, was getting from buffer A for B\ 00003 10/7/91 Disable Port if it could not be initialized.include? cb.ll.in hh:circbuffdecimalANEW TASK-H4th_Custom_MIDI\ Mac Addresses$ 1B2 constant Lvl2DT$ 1D8 constant SCC_RD_PTR \ SCCRd$ 1DC constant SCC_WR_PTR \ SCCWr\ SCC register offsets6 constant AData2 constant ACtl4 constant BData0 constant BCtl4 constant DataOffset2 constant TBE$ 80 constant ChnResetA$ 40 constant ChnResetB\ Lvl2DT interrupt offsets24 constant RxIntOffsetA16 constant TxIntOffsetA28 constant SpecRecOffsetA8 constant RxIntOffsetB0 constant TxIntOffsetB12 constant SpecRecOffsetBvariable PRxIntHandAvariable PRxIntHandBvariable PTxIntHandAvariable PTxIntHandBvariable PSpecRecOffsetAvariable PSpecRecOffsetBvariable MIDIERRORSAvariable MIDIERRORSBvariable MC-A-OPEN  \ is the serial port open for MIDI?variable MC-B-OPEN\ Test whether serial Port A or B is in use before taking.$ 1FB constant SPCONFIG$ 40 constant SPCONFIG_A_MASK$ 01 constant SPCONFIG_B_MASK\ Circular buffers for MIDI datacircular.buffer  mc-xmit-BUF-Acircular.buffer  mc-recv-BUF-Acircular.buffer  mc-xmit-BUF-Bcircular.buffer  mc-recv-BUF-B\ These point to MIDI Time stamp buffersvariable RX-STAMPS-Avariable RX-STAMPS-BASM	SpecRecHandA	MOVE.B	#%00110000,(A1) ;  reset error condition	move.l	(a7),(a7)	LEA		MIDIERRORSA,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets	RTSEND-CODEASM SpecRecHandB	MOVE.B	#%00110000,(A1) ;  reset error condition	move.l	(a7),(a7)	LEA		MIDIERRORSB,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets	RTSEND-CODEASM (MC.XMIT.A)  ( byte -- , send out serial port or stick in buffer)		DC.W	%0100000011100111	\ MOVE.W	SR,-(A7)	;  Save priority level		DC.W	%0000000001111100		DC.W	$0700	;	ORI.W	#$0700,SR	;  Disable interrupts completely		MOVE.L	(A6)+,D1	;  Get byte from Forth Stack		MOVE.L	[ mc-xmit-BUF-A .. cb_count here - 2- ](pc),D0 \ A!		BNE		@1			;  if not empty, add to queue\\ Queue must be empty, check for readiness of SCC chip		MOVE.L	SCC_RD_PTR,A0	;  get SCC Read Address		MOVE.L	SCC_WR_PTR,A1	;  get SCC Write address		MOVE.L	#aCtl,D0		;  get index for Ctl			\ A!		BTST	#TBE,0(A0,D0)	;  chip transmit buffer empty?		BEQ		@1			;  if chip not ready,  add to queue\\ FirstByte		MOVE.L	#aData,D0	;  get index to data				\ A!		MOVE.L	(A7),(A7)	;  delay		MOVE.B	D1,0(A1,D0)	;  write data to SCC		MOVE.L	(A7),(A7)	;  Delay		BRA		@2\\ Add byte to queue.@1		LEA		mc-xmit-BUF-A,A0	;  get the address			\ A!		MOVE.L	D1,D0		BSR		CB.LL.IN\@2		DC.W	%0100011011011111 ; MOVE.W	(A7)+,SR	;  Restore interrupts		RTS			;  and returnEND-CODEASM (MC.XMIT.B)  ( byte -- , send out serial port or stick in buffer)		DC.W	%0100000011100111	\ MOVE.W	SR,-(A7)	;  Save priority level		DC.W	%0000000001111100		DC.W	$0700	;	ORI.W	#$0700,SR	;  Disable interrupts completely		MOVE.L	(A6)+,D1	;  Get byte from Forth Stack		MOVE.L	[ mc-xmit-BUF-B .. cb_count here - 2- ](pc),D0 \ B!		BNE		@1			;  if not empty, add to queue\\ Queue must be empty, check for readiness of SCC chip		MOVE.L	SCC_RD_PTR,A0	;  get SCC Read Address		MOVE.L	SCC_WR_PTR,A1	;  get SCC Write address		MOVE.L	#bCtl,D0		;  get index for Ctl		\ B!		BTST	#TBE,0(A0,D0)	;  chip transmit buffer empty?		BEQ		@1			;  if chip not ready,  add to queue\\ FirstByte		MOVE.L	#bData,D0	;  get index to data		\ B!		MOVE.L	(A7),(A7)	;  delay		MOVE.B	D1,0(A1,D0)	;  write data to SCC		MOVE.L	(A7),(A7)	;  Delay		BRA		@2\\ Add byte to queue.@1		LEA		mc-xmit-BUF-B,A0	;  get the address	\ B!		MOVE.L	D1,D0		BSR		CB.LL.IN\@2		DC.W	%0100011011011111 ; MOVE.W	(A7)+,SR	;  Restore interrupts		RTS			;  and returnEND-CODE\ ----------------------------------------------------------------------\  This is the interrupt routine for receiving a byte of MIDI data.  It\  places the received byte in a circular queue to be accessed later by\  the application.ASM RX.INT.HAND.A\ A0 = address of SCC, don't touch!\ Get byte from port@1	MOVE.L	#DataOffset,D1	;  get data offset	CLR.L	D0		;  prepare for data	MOVE.B	0(A0,D1),D0	;  read data from SCC	CMP.B	#$FE,D0		;  check for Active Sensing, reject if = $FE	BEQ		@2\\ Put data in buffer	MOVE.L	A0,-(A7)	; save address of SCC	LEA		mc-recv-BUF-A,A0					\ A!	BSR		CB.LL.IN\\ Put TIME STAMP in buffer\ D0 = index into buffer	LEA		TIME-CURRENT,A2	MOVE.L	(A2),D1			; get time	MOVE.L	[ mc-recv-BUF-A .. cb_in here - 2- ](pc),D0		\ A!	ASL.L	#2,D0			; convert index to cell offset	MOVE.L	RX-STAMPS-A,A2	; get address of queue			\ A!	MOVE.L	D1,0(A2,D0)		; put time in buffer	MOVE.L	(A7)+,A0		; restore address of SCC\@2	BTST	#0,(A0)		;  is there more data?	BNE	@1		;  do again if there is	RTS		;  and returnEND-CODEASM RX.INT.HAND.B\ A0 = address of SCC, don't touch!\ Get byte from port@1	MOVE.L	#DataOffset,D1	;  get data offset	CLR.L	D0		;  prepare for data	MOVE.B	0(A0,D1),D0	;  read data from SCC	CMP.B	#$FE,D0		;  check for Active Sensing, reject if = $FE	BEQ		@2\\ Put data in buffer	MOVE.L	A0,-(A7)	; save address of SCC	LEA		mc-recv-BUF-B,A0					\ B!	BSR		CB.LL.IN\\ Put TIME STAMP in buffer\ D0 = index into buffer	LEA		TIME-CURRENT,A2	MOVE.L	(A2),D1			; get time	MOVE.L	[ mc-recv-BUF-B .. cb_in here - 2- ](pc),D0		\ B!	ASL.L	#2,D0			; convert index to cell offset	MOVE.L	RX-STAMPS-B,A2	; get address of queue			\ B!	MOVE.L	D1,0(A2,D0)		; put time in buffer	MOVE.L	(A7)+,A0		; restore address of SCC\@2	BTST	#0,(A0)		;  is there more data?	BNE	@1		;  do again if there is	RTS		;  and returnEND-CODE\ ----------------------------------------------------------------------\  TxIntHand  - Transmit Interrupt Handler\\  It checks to see if there is any data to send.  If there is it sends it to\  the SCC.  If there isn't it resets the TBE interrupt in the SCC and exits.\  There's one routine for each output buffer.\  This is called when the previous byte is finished transmitting.\ ----------------------------------------------------------------------ASM TX.INT.HAND.A	MOVE.L	[ mc-xmit-buf-A .. cb_count here - 2-](pc),D0	;  point to queue A!	BEQ		@1				;  if so, turn off interrupts	MOVE.L	A1,-(a7)		; save address of SCCr	move.l	a0,-(a7)	LEA		mc-xmit-buf-A,A0							\ A!	BSR		CB.LL.OUT		; get byte in D0	move.l	(a7)+,a0	MOVE	(a7)+,A1	MOVE.L	#DataOffset,D1	;  get data offset	MOVE.B	D0,0(A1,D1)		;  write data to SCC	move.l	(a7),(a7)	RTS@1		MOVE.B	#$28,(A1)	;  if so, reset TBE interrupt	move.l	(a7),(a7)	RTS			;  and returnEND-CODEASM TX.INT.HAND.B	MOVE.L	[ mc-xmit-buf-B .. cb_count here - 2-](pc),D0	;  point to queue B!	BEQ		@1				;  if so, turn off interrupts	MOVE.L	A1,-(a7)		; save address of SCCr	move.l	a0,-(a7)	LEA		mc-xmit-buf-B,A0							\ B!	BSR		CB.LL.OUT		; get byte in D0	move.l	(a7)+,a0	MOVE	(a7)+,A1	MOVE.L	#DataOffset,D1	;  get data offset	MOVE.B	D0,0(A1,D1)		;  write data to SCC	move.l	(a7),(a7)	RTS@1		MOVE.B	#$28,(A1)	;  if so, reset TBE interrupt	move.l	(a7),(a7)	RTS			;  and returnEND-CODE\ ------------------------------: SERIAL.A.FREE?  ( -- flag )	spconfig c@ spconfig_a_mask and 0=;: SERIAL.A.ALLOC  ( -- )	spconfig c@ spconfig_a_mask OR	spconfig c!;: SERIAL.A.UNALLOC  ( -- )	spconfig c@ spconfig_a_mask COMP AND	spconfig c!;\ ------------------------------: SERIAL.B.FREE?  ( -- flag )	spconfig c@ spconfig_b_mask and 0=;: SERIAL.B.ALLOC  ( -- )	spconfig c@ spconfig_b_mask OR	spconfig c!;: SERIAL.B.UNALLOC  ( -- )	spconfig c@ spconfig_b_mask COMP AND	spconfig c!;\ Wait for room in MIDI queue. ----------------------------------: ?BREAK.KEY ( -- )    MIDI-WARNINGS @    IF  ?terminal      IF  key ascii q =        IF ." Process aborted by 'q'" cr abort        ELSE ." Hit 'q' to abort" cr        THEN      THEN    THEN;\: MC.XFULL?.A  ( -- full? )	mc-xmit-buf-a ..@ cb_count	mc-xmit-buf-a ..@ cb_size >=;: MC.XFULL?.B  ( -- full? )	mc-xmit-buf-b ..@ cb_count	mc-xmit-buf-b ..@ cb_size >=;: MC.XWAIT.A  ( -- )    mc.xfull?.a    IF  MIDI-WARNINGS @        IF  ." MIDI out queue A is temporarily full!!!" cr        THEN        BEGIN            mc.xfull?.a 0= ?break.key        UNTIL    THEN;: MC.RUN.STATUS { newbyte &lastcom | lastcom result -- byte true | false }	&lastcom c@ dup -> lastcom	newbyte =	lastcom 0> AND   \ 00001	IF		\ same as previous command byte so forget it		false	ELSE		newbyte $ 80 and ( byte last mask )		IF		\ it is a new command byte?			newbyte $ F0 >=			IF				\ it is a real time message so do not optimize				0 &lastcom c!			ELSE				\ it is a new command				newbyte &lastcom c!			THEN		THEN		newbyte true	THEN;variable MC-LAST-A \ last byte sentvariable MC-LAST-B \ last byte sent: MC.XMIT.A  ( byte -- , send data byte without overflowing buffer )	mc-a-open @ \ 00003	IF		mc-last-a mc.run.status		IF    		mc.xwait.a (mc.xmit.a)		THEN	ELSE		drop	THEN;: MC.XWAIT.B  ( -- )    mc.xfull?.b    IF  MIDI-WARNINGS @        IF  ." MIDI out queue B is temporarily full!!!" cr        THEN        BEGIN            mc.xfull?.b 0= ?break.key        UNTIL    THEN;: MC.XMIT.B  ( byte -- , send data byte without overflowing buffer )	mc-b-open @ \ 00003	IF		mc-last-b mc.run.status		IF    		mc.xwait.b (mc.xmit.b)		THEN	ELSE		drop	THEN;: MC.CHECK.SPecRec    midierrorsa @ ?dup IF . ." errors on port A!! hit key:" cr key drop THEN    midierrorsb @ ?dup IF . ." errors on port B!! hit key:" cr key drop THEN    0 midierrorsa !    0 midierrorsb !;: MC.XMIT  ( byte -- , tramsmit byte on current port )	midi-port @ modem_port =	IF		mc.XMIT.A	ELSE		mc.XMIT.B	THEN;: MC.WRITE  ( addr count -- , write those MIDI bytes )	0	DO		dup c@ mc.xmit		1+	LOOP	drop;: (MC.CHECK.ERRORS) ( buffer -- , report errors if any )    dup ..@ cb_overflowed    IF  false swap ..! cb_overflowed        ." MIDI Input Overflowed Buffer." cr	ELSE drop    THEN;: MC.CHECK.ERRORS ( -- )	midi-port @ modem_port =	IF mc-recv-buf-a	ELSE mc-recv-buf-b	THEN	(mc.check.errors);: MC.RECV.X ( cbuf -- data true | false )    dup ..@ cb_count    IF cb.out  true\ We don't need to turn off interrupts because the\ CB.OUT.LL routine only shares one value with CB.IN.LL\ and it is decremented in one instruction.  If we turn\ off interrupts, then we get more Byte OverRuns!!\ Check for errors.       midi-warnings @       IF  mc.check.errors       THEN    ELSE drop false    THEN;: MC.RECV  ( -- byte true | false , receive byte if available )	midi-port @ modem_port =	IF	mc-recv-buf-a	ELSE mc-recv-buf-b \ 00002	THEN	mc.recv.x;: MC.RTC.TIME@.A ( -- time , last byte was received )	mc-recv-buf-a ..@ cb_out 1- dup 0<	IF drop mc-recv-buf-a ..@ cb_size 1-	THEN cells	rx-stamps-a @ + @;: MC.RTC.TIME@.B ( -- time , last byte was received )	mc-recv-buf-b ..@ cb_out 1- dup 0<	IF drop mc-recv-buf-b ..@ cb_size 1-	THEN cells	rx-stamps-b @ + @;: MC.RTC.TIME@ ( -- time , last byte was received )	midi-port @ modem_port =	IF	MC.RTC.TIME@.A	ELSE MC.RTC.TIME@.B	THEN;\ ------------------------------------------------------------------: SCC.REG! ( byte reg# ctrl-addr -- )	tuck c! c!;: SCCInit ( ctrl-addr -- , NOT CALLED DIRECTLY, USE SCCInitA or SCCInitB )	>r	% 1000,0100 4	r@ scc.reg!  \  32x clock, 1 stop bit	0 1		r@ scc.reg!  \  No W/Req	0 3		r@ scc.reg!  \  Turn off Rx	0 5		r@ scc.reg!  \  Turn off Tx	% 0010,1000 11	r@ scc.reg!  \ Make TRxC clock source	0 14  	r@ scc.reg!  \  Disable BRGen	% 1100,0001 3	r@ scc.reg!  \  Enable Rx	% 0110,1010 5	r@ scc.reg!  \  Enable Tx and drivers	% 0000,1000 15	r@ scc.reg!  \  Enable DCD int for mouse	% 0001,0000 0	r@ scc.reg!  \  Reset EXT/STATUS	% 0001,0000 0	r@ scc.reg!  \  Reset EXT/STATUS again	% 0001,0011 1	r@ scc.reg!  \  Enable interrupts	% 0000,1010 9	r@ scc.reg!  \  Set master int enable	rdrop;: SCCInitA	( -- , Initialize MIDI Output Port A )\ Initialize circular buffers for Xmit and Recv	midi-xmit-size @ mc-xmit-buf-a cb.alloc	midi-recv-size @ mc-recv-buf-a cb.alloc	midi-recv-size @ cells mm.alloc rx-stamps-a !\\ disable interrupts	disable.scc ( -- sr )	\ setup SCC chips	scc_rd_ptr @ \ get address of SCC chip	actl + c@ drop \ dummy read to setup control register\	scc_wr_ptr @ \ get address of SCC chip	actl + \ offset to control register	dup>r ChnResetA 9 r> scc.reg!  \  Reset channel	SCCInit		\ Branch to common init routine\\ set interrupts	lvl2DT RxIntOffsetA + dup @ PRxIntHandA !	' RX.Int.Hand.A swap !		lvl2DT TxIntOffsetA + dup @ PTxIntHandA !	' Tx.Int.Hand.A swap !		lvl2DT SpecRecOffsetA + dup @ PSpecRecOffsetA !	' SpecRecHandA swap !\\ restore status register	restore.sr;: SCCInitB	( -- , Initialize MIDI Output Port B )\ Initialize circular buffers for Xmit and Recv	midi-xmit-size @ mc-xmit-buf-b cb.alloc	midi-recv-size @ mc-recv-buf-b cb.alloc	midi-recv-size @ cells mm.alloc rx-stamps-b !\\ disable interrupts	disable.scc ( -- sr )	\ setup SCC chips	scc_rd_ptr @ \ get address of SCC chip	bctl +  c@ drop		scc_wr_ptr @ \ get address of SCC chip	bctl +  \ Add offset for control	dup>r ChnResetB 9 r> scc.reg!  \  Reset channel	SCCInit		\ Branch to common init routine\\ set interrupts	lvl2DT RxIntOffsetB + dup @ PRxIntHandB !	' Rx.Int.Hand.B swap !		lvl2DT TxIntOffsetB + dup @ PTxIntHandB !	' Tx.Int.Hand.B swap !		lvl2DT SpecRecOffsetB + dup @ PSpecRecOffsetB !	' SpecRecHandB swap !\\ restore status register	restore.sr;\ ------------------------------------------------------------------\ This routine must be called when the application quits or the system will\ crash due to the interrupt handling pointers becoming invalid.: SCCReset 	( ctrl-addr -- )	>r	$ 08 15	r@ scc.reg!  \  Enable DCD int	$ 10 0	r@ scc.reg!  \  Reset EXT/STATUS	$ 10 0	r@ scc.reg!  \  Reset EXT/STATUS again	$ 01 1	r@ scc.reg!  \  Enable mouse interrupts	$ 0A 9	r@ scc.reg!  \  Set master int enable	rdrop;: SCCResetA  ( -- )	disable.scc  ( -- sr )\\ reset SCC	scc_wr_ptr @ \ get address of SCC chip	actl +	\ offset to control	dup>r ChnResetA 9 r>	scc.reg!  \  Reset channel	SCCReset	\ Branch to common reset routine\\ restore original interupts	PTxIntHandA @ lvl2DT TxIntOffsetA + !	PRxIntHandA @ lvl2DT RxIntOffsetA + !	PSpecRecOffsetA @ lvl2DT SpecRecOffsetA + !\	restore.sr\\ free buffers	mc-xmit-buf-a cb.free	mc-recv-buf-a cb.free	rx-stamps-a @ ?dup	IF mm.free rx-stamps-a off	THEN;: SCCResetB  ( -- )	disable.scc  ( -- sr )\\ reset SCC	scc_wr_ptr @ \ get address of SCC chip	bCtl +	dup>r ChnResetB 9 r> scc.reg!  \  Reset channel	SCCReset	\ Branch to common reset routine\\ restore original interupts	PTxIntHandB @ lvl2DT TxIntOffsetB + !	PRxIntHandB @ lvl2DT RxIntOffsetB + !	PSpecRecOffsetB @ lvl2DT SpecRecOffsetB + !\	restore.sr\\ free buffers	mc-xmit-buf-b cb.free	mc-recv-buf-b cb.free	rx-stamps-b @ ?dup	IF mm.free rx-stamps-b off	THEN;: MC.SER.INIT.A ( -- , init A side )	." Serial Port A "	mc-a-open @ 0=	IF  serial.a.free?		IF SccInitA mc-a-open on ." open for MIDI" cr		ELSE ." in use!" cr		THEN	THEN;: MC.SER.INIT.B ( -- , init B side )	." Serial Port B "	mc-b-open @ 0=	IF  serial.b.free?		IF SccInitB mc-b-open on ." open for MIDI" cr		ELSE  ." in use! Probably by Appletalk." cr		THEN	THEN;: MC.SER.INIT  ( -- , Initialize Port A for MIDI )	modem_port midi-port !	mc.ser.init.a	mc.ser.init.b\	mc.check.errors	'c mc.recv is midi.recv	'c mc.rtc.time@ is midi.rtc.time@	'c mc.write is midi.write\	time.init	midi.eb.on   \ turn on event buffering	." HMSL <-> Custom MIDI interface initialized." cr;: MC.SER.TERM  ( -- , Close MIDI communications channel )	midi.eb.off	time.term	mc.check.specrec	modem_port midi-port !	mc-a-open @	IF		SccResetA mc-a-open off	THEN	mc-b-open @	IF		SccResetB mc-b-open off	THEN	mc.check.errors	midi.reset.vectors;if.forgotten MC.SER.TERM: USE.CUSTOM.MIDI ( -- , use custom MIDI vectors )	midi.ser.term  \ whatever is current MIDI	'c mc.ser.init is midi.ser.init	'c mc.ser.term is midi.ser.term;use.custom.midiif.forgotten use.midi.manager\ tests: XMITA  ( byte -- , write byte directly to serial data register )	scc_wr_ptr @ adata + c!;