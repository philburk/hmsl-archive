\ :MODULE dismmod\ btd sept 30 86.  fixed odd adr crash, tabs, added cycle calc.\ 36 sec to compiler from floppy, 28 sec from ram disk.  14,200 bytes. \ 02-jan-87  mdh  for 1.1 ... NIB4:14 checks if calling thru +64k or ORG before\                 deciding it is calling within the kernal.  Also, modified\                 to decode both in DEF.  Also, DEF resets DISM-ORIGIN.\ 05-oct-87  mdh  fixed many problems...relative branch addresses now show\                 correct value based on DISM-ORIGIN...added RELDISM so that\                 an address can be DISM'ed relative to another address...\                 fixed JSR ABS.L to print the called name, if appropriate...\                 dc.w? was not being initialized correctly; if seen, could\                 screw up next opcode.\ ********************** OK, lets get all our tools  ***********************\    known bugs: - some timings are inexact. off by as much as 4 cycles.\ 00001 PLB 11/20/91 Added 0CR\ FORTH DEFINITIONSDECIMALanew TASK-DISM: 0CR CR 0 out ! ; \ doesn't CR do this anyway? 00001: @BITS ( n offset bits --- bit-of-n )     >R -SHIFT  -1 R> +SHIFT  COMP AND ;: !BITS  ( n n1 offset bits --- n'-or-bits-of-n1  )   >r >r   -1 2 RPICK  +SHIFT DUP >R COMP AND   2 RPICK  +SHIFT   ( n  n1-bits-in-position  )  ( bits offset bits-of-0's -R-)   SWAP  R> COMP R> +SHIFT COMP AND OR r> drop ;: ?EVEN  ( ADR --- EVEN-ADR )  ( and a warning if odd ) DUP 1 AND        IF   0CR ." garbage odd address.  incrementing to even" 1+ 0CR        THEN ;: COLUMN ( column --- )  dup out @ <  IF   0CR  THEN OUT @ - ABS SPACES ; \ ********************** ready to start for real! ***********************\ ONLY FORTH DEFINITIONS \ VOCABULARY UNCODE IMMEDIATE\ ALSO  FORTH\ UNCODE DEFINITIONSDECIMAL0 fig-var DISM-ADR0 fig-var  DISM-SIZE      0 fig-var  DISM-DONE0 fig-var  HIGH-BRANCH    0 fig-var  START-ADR$ 7fff 16 +shift   $ ffff or   constant $7fffffff$7fffffff fig-var  LOW-BRANCH0 fig-var  NEW-DISM-ADR 6 fig-var   ADR.R 8 fig-var   OPCODE-COL   16 fig-var   ARG-COL 43 fig-var   CODE-COL 60 fig-var   CYCLE-COL 74 fig-var   FINAL-COL : >ARG  ( --- )  ARG-COL @ COLUMN ;0 fig-var  #CYCLES0 fig-var  #CYCLES/: +CYCLES  ( N --- )  #CYCLES +! ;: +LONG  ( N --- )  ( add 4 cycles if size long )  DISM-SIZE @ 2 =       IF 4 +  THEN +CYCLES ;: LONG?  ( --- FLAG ) DISM-SIZE @ 2 = ; : +CYCLES/  ( N --- ) #CYCLES/ +! ;: +IF-LONG ( CYCLES +IF-LONG --- )  LONG?       IF    +       ELSE  DROP      THEN  +CYCLES ;0 fig-var  MEM: IS-MEM  ( --- )  MEM ON ;0 fig-var  APPROX: +MEM  ( CYCLE --- )  MEM @ IF DUP +CYCLES THEN DROP  ;: DONE? ( -- )  HIGH-BRANCH @    DISM-ADR @ >  NOT  DISM-DONE !  ;DECIMAL0 fig-var  OPCODE: OPP  ( --- OPP-WORD )  OPCODE @ ;: @OPP-BITS  ( OFF #BITS--- N ) >R >R OPP R> R> @BITS ;: OPP-BIT?  ( BIT# --- FLAG ) OPP SWAP BIT-SET? >FIG-FLAG  ;: OPP-BITS?   CREATE ( BIT# --- )  ,        DOES>  ( <PFA> --- FLAG )    @ OPP-BIT?  ;8   OPP-BITS?    8?6   OPP-BITS?    6?7   OPP-BITS?    7?5   OPP-BITS?    5?3   OPP-BITS?    3?: 6&7   ( --- VAL )  6 2 @OPP-BITS ;: 6&7?   ( --- FLAG )  6&7 3 = ;: OPP/9  ( --- OPP/9  )  OPP 9 -shift ;: OPP/6  ( --- OPP/6  )  OPP 6 -shift ;: OPP/3  ( --- OPP/3  )  OPP 3 -shift ;: A2+  ( --- ) 2 DISM-ADR @ + ?EVEN DISM-ADR ! ;: PAR1 ( --- paramter1 )  DISM-ADR @ 2+ W@ W->S ;: .#  ." #" ;: BIN.#  ( --- )  ( binary .IMM , byte-size )    ." #%" PAR1   1 .R        A2+   ;: .,  ( --- )  ." ," ;DECIMAL: SET-SIZE  ( --- ) 6 2 @OPP-BITS  DISM-SIZE ! ;\ 4 $TABLE SIZE-TEXT  ".b" ".w" ".l" "?": SIZE-TEXT    case     0 of " .b"  endof     1 of " .w"  endof     2 of " .l"  endof     3 of " ?"   endof  endcase $type ;: SIZE$  SIZE-TEXT  >ARG  ;: .SIZE  ( --- ) DISM-SIZE @ 3 MIN SIZE$  ;: .LONG  2 SIZE$  ;: .WORD  1 SIZE$  ;: .BYTE  0 SIZE$  ;FALSE fig-var  DC.W?: .DW   ( --- )  BEGIN  out @ opcode-col @ >  WHILE  backspace  \ bsout @ emit  REPEAT ." dc.w" >ARG  OPP .   DC.W? ON    ;DECIMAL: .BASE-CHAR  ( --- )  BASE @    CASE   16  OF ." $"   endof            2  OF ." %"   endof    ENDCASE  ;: .IMM  ( --- )  .#   .BASE-CHAR     DISM-ADR @ 2+  DISM-SIZE @     CASE   0   OF  1+   C@    B->S   endof            1   OF  W@   W->S         endof            2   OF  @    A2+          endof     ENDCASE  A2+  1 .R    4 +LONG       ;DECIMAL\ 8 $TABLE AREGS: AREGS  case     0 of " a0" endof         1 of " a1" endof     2 of " a2" endof         3 of " a3" endof     4 of " a4" endof         5 of " a5" endof     6 of " a6" endof         7 of " a7" endof   >r " ??" r>  endcase $type  ;\ 8 $TABLE AREGS-68K: AREGS-68K  case     0 of " a0" endof         1 of " a1" endof     2 of " a2" endof         3 of " a3" endof     4 of " a4" endof         5 of " a5" endof     6 of " a6" endof         7 of " a7" endof   >r " ??" r>  endcase $type  ;\ 8 $TABLE DREGS: DREGS  case     0 of " d0" endof         1 of " d1" endof     2 of " d2" endof         3 of " d3" endof     4 of " d4" endof         5 of " d5" endof     6 of " d6" endof         7 of " d7" endof   >r " ??" r>  endcase $type  ;\ 8 $TABLE DREGS-68K: DREGS-68K  case     0 of " d0" endof         1 of " d1" endof     2 of " d2" endof         3 of " d3" endof     4 of " d4" endof         5 of " d5" endof     6 of " d6" endof         7 of " d7" endof   >r " ??" r>  endcase $type  ;DECIMALtrue fig-var  .REGNAMES?: .AREG  ( opp --- )   7 AND  .REGNAMES? @  IF   AREGS  ELSE AREGS-68K  THEN  ;: .DREG  ( opp --- )   7 AND  .REGNAMES? @  IF   DREGS  ELSE DREGS-68K  THEN  ;: .((  ." ("  ;: .)  ." )"  ;: .AN     ( opp --- )  .AREG     ;: .A@     ( opp --- )  .(( .AREG .)      4 +CYCLES IS-MEM  ;: .A@+    ( opp --- )  .(( .AREG ." )+"  4 +CYCLES IS-MEM  ;: .-A@   ( opp --  )  ." -(" .AREG .)   6 +CYCLES IS-MEM  ;: .NUM ( n --- )   .BASE-CHAR  1 .R     ;: .PAR1-SIZE ( --- )   PAR1 11 BIT-SET?   IF    ." .l"   ELSE  ." .w"   THEN    ;DECIMAL0 fig-var   DISM-ORIGIN: IN-DICT?   ( adr -- flag , true if in side image and valid nfa )  drop false ;\  >R  R 0< NOT   R HERE <     AND\  R>  >NAME   VALID-NAME? AND   ;: .ADR  ( ADR --- )  ( ." ADR" )  DISM-ORIGIN  @ -  ADR.R @ .R   ;FALSE fig-var  DOING-CALL: .CALLED-NAME?  ( cfa -- , IF calling a cfa, print name )  drop ;\   DOING-CALL @  .REGNAMES? @ AND  DISM-ORIGIN @ 0= AND\   IF   OPP JSR+64K-CODE =\        IF  $ 10000 +\        THEN DUP IN-DICT?\        IF   DUP ."  = " >NAME ID.\        THEN\   THEN DROP  ;: .ARGS-ADR  ( ADR -- )   \  (this is ABSOLUTE!)  DISM-ORIGIN @ -  BL  ARG-COL @  EMIT-TO-COLUMN DUP .NUM  dism-origin @ -  .CALLED-NAME?   ;   : .ARGS-RELADR  ( ADR -- )    DISM-ORIGIN @ -  BL  ARG-COL @  EMIT-TO-COLUMN DUP .NUM  dism-origin @ -  .CALLED-NAME?   ;   DECIMAL: .,R)  ( --- )  .,  PAR1 12 3 @BITS  PAR1 15 BIT-SET? ( OPP-BIT?  )    IF    .AREG   ELSE  .DREG   THEN  .PAR1-SIZE  .)  ;: .AN+W    ( opp --- )   PAR1  .NUM  .A@   DISM-ADR @ 2+ W@ W->S    .CALLED-NAME?  A2+  4 +LONG  IS-MEM  ;: .PAR1   ( --- )  PAR1  B->S .NUM ;: .AN+R+B  ( opp--- ) .PAR1  .(( .AREG   .,R)  A2+  10 +CYCLES IS-MEM  ;: .PC+R+B  (  --- )   .PAR1  ." (pc"    .,r)    A2+  10 +CYCLES IS-MEM ;: .PC+W (  --- )    PAR1 .NUM  ." (pc)"   A2+   8 +CYCLES IS-MEM ;: .ABS.W  ( --- )  PAR1  .ARGS-ADR  ( ." .w" )  A2+   8 +CYCLES IS-MEM ;: .ABS.L ( --- )  DISM-ADR @ 2+ @ dup >rel .CALLED-NAME?  .ARGS-ADR  4 DISM-ADR +!  12 +CYCLES  ;: .EXT   ( OPP --- )   7  AND  case     0 of  .ABS.W    endof     1 of  .ABS.L    endof     2 of  .PC+W     endof     3 of  .PC+R+B   endof     4 of  .IMM      endof     5 of  .DW       endof     6 of  .DW       endof     7 of  .DW       endof  endcase   ( --- )  ;: .SOURCE  ( --- )  OPP     3 3  @OPP-BITS  case     0 of  .DREG     endof     1 of  .AN       endof     2 of  .A@       endof     3 of  .A@+      endof     4 of  .-A@      endof     5 of  .AN+W     endof     6 of  .AN+R+B   endof     7 of  .EXT      endof  endcase  ( opp selector--- )  ;: ,SOURCE  ., .SOURCE ;: ,AREG    ., .AREG  ;: ,DREG    ., .DREG  ;FALSE fig-var  .ED-M: ?., (  --- )  .ED-M @ IF .,      THEN .ED-M  ON  ;: ?./ (  --- )  .ED-M @ IF   ." /" THEN .ED-M  ON  ;DECIMAL : dismCR?  ( --- )   OUT  @ CODE-COL @ 3 - >     IF    0CR  ARG-COL @ COLUMN       THEN ; 0 fig-var laston   0 fig-var lastoff   0 fig-var leadchar 0 fig-var #seq     0 fig-var rtype     0 fig-var #mcyc 0 fig-var dstart   0 fig-var astart: .MOVR  ( reg# -- )  rtype @ ascii A -  IF   .dreg  ELSE .areg  THEN dismcr? ;: .on  ( #b -- ) dup laston @ - 1 -  IF   leadchar @ emit  dup .movr  ascii - leadchar !  #seq off  ELSE 1 #seq +!  THEN laston !  #mcyc @ dup +IF-LONG  ;: .off ( #b -- )  dup lastoff @ - 1-  IF   #seq @       IF   leadchar @ emit  laston @ .movr       THEN   ascii / leadchar !  THEN lastoff !  0 #seq !  ;: initmovm   ( char -- )  rtype !  -10 laston !  -1 lastoff !  leadchar off #seq off  ;: ?last  lastoff @ 2+ .off   ;: .REGLIST  ( par #cycles A-start D-start --- ) dstart !  astart !  #mcyc !       ascii D  initmovm   8 0         DO   dup  dstart @ i - abs bit-set?  i swap            IF    .on            ELSE  .off            THEN       LOOP ?last  8 0  Ascii A initmovm  ascii / leadchar !       DO   dup  astart @ i - abs bit-set?  i swap            IF    .on            ELSE  .off            THEN       LOOP ?last  DROP    ;   DECIMAL: .MOVEM  ( --- )  .ED-M OFF  PAR1  3 3 @OPP-BITS 4 =  IF   ( A7-A0,D7-D0 )  4  7 15  ELSE ( d0-d7,a0-a7 )  5 -8  0  THEN .reglist  a2+  ;: NIB4:0   ( --- )   6&7?     IF     ." move"  .WORD   ." sr,"   6   +CYCLES      ELSE   ." negx"  .SIZE             4 2 +IF-LONG      THEN  .SOURCE  ;: DISM-CLR  (  --- )  ." clr"  .SIZE  .SOURCE  4 2 +IF-LONG ;: NIB4:4  (  --- )    6&7?     IF     ." move" .WORD  ." ccr,"  ( WRONG? ) 12 +CYCLES     ELSE   ." neg"  .SIZE  4 2 +IF-LONG      THEN    .SOURCE   ;: NIB4:6   ( --- )   6&7?     IF      ." move"  .WORD  .SOURCE  ." ,sr"  12 +CYCLES     ELSE    ." not"   .LONG  .SOURCE           6  +CYCLES  2 +MEM        THEN      ;: NIB4:8  ( --- )  6&7  CASE   0  OF     ." nbcd"   .BYTE   .SOURCE 6 +CYCLES   2 +MEM  endof   1  OF     ." pea"  ( .LONG ) >arg .SOURCE 4 +CYCLES           endof   ." movem" 6? 1+  SIZE$          .MOVEM  ., .SOURCE         12   +CYCLES       ENDCASE     ;: NIB4:10  (  --- )   6&7?    IF      ." tas"  .BYTE       6 +MEM      ELSE    ." tst"  6&7 SIZE$        THEN  .SOURCE   4 +CYCLES ;: NIB4:14   (  --- )  7?   IF  6?   2 DISM-SIZE !        IF    ." jmp"   DONE?   APPROX ON         ELSE  ." jsr"   8 +CYCLES             \ check if doing a call thru +64k or ORG             3 3 @OPP-BITS 5 =             0 3 @OPP-BITS dup 3 = swap 4 = or  ( -- an+w-flag a3-or-a4-flag )             AND opp $ 4eb9 = or  DOING-CALL !       THEN  ( .LONG ) >arg .SOURCE   ELSE   0 4 @OPP-BITS      ." trap"  >ARG  .#  .NUM   THEN  ;: NIB4:12  (  --- ) ( opp,movem-mask,ext)   ." movem"  6?  1+   SIZE$    8 +CYCLES     DISM-ADR @ >R    (   6?  )  A2+ .SOURCE   R> DISM-ADR @ >R DISM-ADR !  .,    .MOVEM     R> DISM-ADR !  ;: NIB4-UNIQUE  (  --- )    OPP/9 6?  IF      ." lea"  >ARG    .SOURCE ,AREG    APPROX ON   ELSE    ." chk"  >ARG     .SOURCE ,DREG   8 +CYCLES  THEN   ;: NIB4-SPECIAL ( --- )    OPP $ 100  AND   IF    NIB4-UNIQUE   ELSE  ( JMP )  9 3 @OPP-BITS         case   0 of  NIB4:0  endof    1 of  DISM-CLR  endof                2 of  NIB4:4  endof    3 of  NIB4:6    endof                4 of  NIB4:8  endof    5 of  NIB4:10   endof                6 of  NIB4:12 endof    7 of  NIB4:14   endof         endcase   THEN ;DECIMAL: .NIB4-REG     ( --- )  OPP DUP   $ FFF8 AND CASE  $ 4E68  OF    ." move"  >ARG  ." usp,"   .AREG   6 +CYCLES 2 +MEM  endof  $ 4E60  OF    ." move"  >ARG  .AREG    ." ,usp"  4 +CYCLES         endof  $ 4E58  OF    ." unlk"  >ARG  .AREG             12 +CYCLES         endof  $ 4880  OF    ." ext"  .WORD .DREG              4 +CYCLES         endof  $ 4E50  OF    ." link"  >ARG  .AREG ., .IMM A2+ 18 +CYCLES         endof  $ 4840  OF    ." swap"  >ARG  .DREG              4 +CYCLES         endof  $ 48C0  OF    ." ext"  .LONG .DREG              4 +CYCLES         endof     DROP  NIB4-SPECIAL  ENDCASE  ;DECIMALDECIMAL: NIB4  ( --- )   OPPCASE    $ 4E76  OF  ." trapv"         DONE?  4 +CYCLES  ( 34 +IF )  endof  $ 4E75  OF  ." rts"           DONE? 16 +CYCLES          endof  $ 4E73  OF  ." rte"           DONE? 20 +CYCLES          endof  $ 4E72  OF  ." stop"   BIN.#  DONE?  4 +CYCLES          endof  $ 4E70  OF  ." reset"              123 +CYCLES          endof  $ 4E71  OF  ." nop"                  4 +CYCLES          endof  $ 4E77  OF  ." rtr"           DONE? 20 +CYCLES          endof  $ 4A7C  OF  ." illegal"             34 +CYCLES          endof      .NIB4-REGENDCASE  ;: .DEST  ( --- )  OPP  >R       9 3 @OPP-BITS    OPP/3  $ 38 AND     OR       OPCODE !   ,SOURCE R> OPCODE  !  ;DECIMAL: NIB1-3   ( --- )  12 2 @OPP-BITS  4 +CYCLES    CASE  1 OF  0  endof           2 OF  2  endof         3 OF  1  endof       ." illegal move size "  QUIT   ENDCASE   DISM-SIZE !         ." move"  .SIZE   .SOURCE DC.W? @ NOT   IF  .DEST     THEN   4 +MEM    ;\ 4 $TABLE  DYN$  "BTST"   "BCHG"  "BCLR"  "BSET": DYN$  case     0 of " btst" endof         1 of " bchg" endof     2 of " bclr" endof         3 of " bset" endof   >r " ????" r>  endcase $type ;: .STAT-BIT  ( --)  0 dism-size !  6&7  DYN$ >ARG  .IMM ( A2+ -- removed 1/24/87 mdh )  ,SOURCE ;: NIB0-UNIQUE  ( --- )     3 3 @OPP-BITS 1 =      IF    ." movep"   OPP/9  OPP 6? 1+  DISM-SIZE ! .SIZE 7?            IF    ( REG=>MEM )  .DREG  .,  .AN+W            ELSE    .AN+W  ,DREG            THEN   16 8 +IF-LONG       ELSE  8?      IF    6&7 DYN$ >ARG OPP/9 .DREG ,SOURCE  6 2 +IF-LONG  2 +CYCLES/      ELSE   ."  EORI"  .SIZE  .IMM ,SOURCE  8 8 +IF-LONG  4 +MEM    then then  ;\ 7 $TABLE   NIB0$    "OR"  "AND"  "SUB"   "ADD"  "BULL"  "EOR"  "CMP": NIB0$  case     0 of " or" endof         1 of " and" endof     2 of " sub" endof        3 of " add" endof     4 of " ???" endof        5 of " eor" endof     6 of " cmp" endof   >r " ???" r>  endcase $type  ;: NIB0-DEST  ( --- )  9 3 @OPP-BITS  NIB0$   .SIZE  .IMM    ,SOURCE  8 8 +IF-LONG  4 +MEM    ;: NIB0   ( --- )   -1 >r  OPP   CASE      $  3C  OF    ." or"    .BYTE   BIN.# ." ,ccr" endof   $  7C  OF    ." or"    .WORD   BIN.# ." ,sr"  endof   $ 23C  OF    ." and"   .BYTE   BIN.# ." ,ccr" endof   $ 27C  OF    ." and"   .WORD   BIN.# ." ,sr"  endof   $ A3C  OF    ." eor"   .BYTE   BIN.# ." ,ccr" endof   $ A7C  OF    ." eor"   .WORD   BIN.# ." ,sr"  endof     8 4 @OPP-BITS     case        0 of NIB0-DEST   endof      1 of NIB0-UNIQUE   endof        2 of NIB0-DEST   endof      3 of NIB0-UNIQUE   endof        4 of NIB0-DEST   endof      5 of NIB0-DEST     endof        6 of NIB0-DEST   endof      7 of NIB0-UNIQUE   endof        8 of .STAT-BIT   endof      9 of NIB0-UNIQUE   endof       10 of NIB0-UNIQUE endof     11 of NIB0-UNIQUE   endof       12 of NIB0-DEST   endof     13 of NIB0-UNIQUE   endof       14 of NIB0-UNIQUE endof     15 of NIB0-UNIQUE   endof      endcase  ( DROP )  r> drop  0 >r   ENDCASE  r>  IF   20 +CYCLES  THEN ;DECIMAL \ 16 $TABLE .COND$  "RA" "F" "HI" "LS" "CC" "CS" "NE" "EQ" "VC" "VS" "PL" "MI"\ "GE" "LT" "GT" "LE": .COND$  case     0 of " ra" endof         1 of " f" endof     2 of " hi" endof         3 of " ls" endof     4 of " cc" endof         5 of " cs" endof     6 of " ne" endof         7 of " eq" endof     8 of " vc" endof         9 of " vs" endof    10 of " pl" endof        11 of " mi" endof    12 of " ge" endof        13 of " lt" endof    14 of " gt" endof        15 of " le" endof   >r " ??" r>  endcase $type  ;: .COND  ( --- )  8 4 @OPP-BITS  .COND$  ;: SET-HIGH-BRANCH ( ADR --- )  HIGH-BRANCH @ MAX HIGH-BRANCH ! ; : UNCOND-BRA?  ( ADR --- ) >R R@  DISM-ADR @ - 50 >    DONE?  DISM-DONE @   AND  DISM-DONE !    r@  START-ADR @ < DISM-DONE !  R> SET-HIGH-BRANCH  ;: COND-BRA?  ( ADDR --- )   8 4 @OPP-BITS  IF     SET-HIGH-BRANCH  ELSE   UNCOND-BRA?  THEN ;: NIB5   ( --- )   6&7?  IF   ( DBCC OR SCC ) OPP  $ 38 AND 8 =         IF    ." db" .COND  .WORD  OPP .DREG                PAR1  DISM-ADR @  +  2+  DUP COND-BRA? ., .ARGS-RELADR               A2+     10 +CYCLES ( 4 +DID'NT )          ELSE  ." s" .COND >ARG  .SOURCE 4 2 +IF-LONG  APPROX ON         THEN  ELSE  ( QUICK )  8?        IF    ." subq"           ELSE  ." addq"          THEN  .SIZE  9 3 @OPP-BITS DUP 0=        IF      8 +        THEN    .# .NUM   ,SOURCE   4 +LONG  4 +MEM  ( +4 AN ) APPROX ON          ( : 2 +MEM-IF-LONG  4 +IF-AN )   THEN  ;: NIB6   ( --- )   OPP 255 AND 0=   IF    PAR1   A2+  1 DISM-SIZE !   ELSE  OPP B->S 2+  0 DISM-SIZE !   THEN   ( bra-offset )  DISM-ADR @ +  ( DISM-SIZE @ 2* + )   ( ABS-ADR )   8 4 @OPP-BITS  1 =   IF    ." bsr"       DOING-CALL ON        18 +CYCLES   ELSE  ." b" .COND   DUP    COND-BRA?     10 +CYCLES  ( -2 +2 IF-LONG-DID'T)   THEN  DISM-SIZE @    IF    ." .l"   ELSE  ." .s"   THEN  .ARGS-RELADR  ;: .MOVEQ  ( --- )  ." moveq.l" >ARG OPP 255 AND B->S ascii # emit .NUM     OPP/9  ,DREG  4 +CYCLES    ;DECIMAL: NIB8  ( --- )   6&7?   IF     8?  ." div"           IF    ASCII S 158 +CYCLES            ELSE  ASCII U 140 +CYCLES           THEN  EMIT >ARG .SOURCE  OPP/9  ,DREG      ELSE    OPP $ 1F0 AND $ 100 =           IF    ." sbcd"  .BYTE OPP/9 OPP  3?                IF     .-A@  .,  .-A@ 18                 ELSE  .DREG  ,DREG     8                THEN  +CYCLES           ELSE  ." or" .SIZE   OPP/9   8?                IF     .DREG    ,SOURCE   8 2                 ELSE   .SOURCE  ,DREG     4 2                 THEN   +IF-LONG           THEN   THEN     ;: NIB9  ( --- ) OPP/9   OPP $ C0 AND $ C0 =  ( OPP/9  FLAG )    IF    ." suba"   8?  1+ DISM-SIZE ! .SIZE  .SOURCE ,AREG           8 +CYCLES  -2 +MEM         ELSE  OPP $ 130 AND $ 100 =  ( OP/9 FLAG )    8 +CYCLES  APPROX ON     IF   ." subx" .SIZE   OPP  3?         IF      .-A@   .,   .-A@      18 12           ELSE   .DREG ,DREG                         4 4           THEN   +IF-LONG     ELSE   ." sub" .SIZE     8? NOT           IF   ( => EA )  .SOURCE  ,DREG  4 2                ELSE  ( ->DN )  .DREG  ,SOURCE  4 2  ( +2 IF DN )  APPROX ON           THEN  +IF-LONG   then then   ;: NIB11  ( --- ) OPP/9   6 2 @OPP-BITS  3 =     IF    ." cmpa"  8? 1+ DISM-SIZE ! .SIZE  .SOURCE ,AREG  6 +CYCLES      ELSE  8?   NOT     IF    ." cmp"  .SIZE .SOURCE  ,DREG   4 2 +IF-LONG     ELSE  3 3 @OPP-BITS 4 =     IF    ." cmpm"  .SIZE  OPP   .A@+  .,  .A@+  12 8 +IF-LONG         ELSE   ." eor"  .SIZE .DREG ,SOURCE    8 4 +IF-LONG  then then then ;DECIMAL: .MUL  (  --- )  OPP/9   6&7?    IF    8?         IF     ." muls"            ELSE   ." mulu"         THEN    >ARG .SOURCE ,DREG  70 +CYCLES    ELSE  8?  ." and"  .SIZE        IF     .DREG  ,SOURCE  8 4         ELSE   .SOURCE ,DREG   4 2          THEN   +IF-LONG     THEN  ;: .EXG    ." exg" >ARG ;: NIB12  ( --- ) -1 >r  OPP/9 OPP   DUP $ 1F8 AND  CASE    $ 188  OF  .EXG  .AREG ,DREG  endof    $ 148  OF  .EXG  .AREG ,AREG  endof    $ 140  OF  .EXG  .DREG ,DREG  endof      >R  ( OP-9-ROT OPP  )  OPP   $ 1F0 AND $ 100 =      IF   3?    ." abcd"  .BYTE  ( ... op9-rot opp flag )           IF      .-A@ .,  .-A@    18            ELSE  .DREG ,DREG  8              THEN  +CYCLES       ELSE  2dROP .MUL      THEN  R>    r> drop 0 >r    ENDCASE   r> IF  6 +CYCLES THEN ;\ 4 $TABLE  .ROT$  "AS"  "LS" "ROX" "ROT": .ROT$  case     0 of " as" endof          1 of " ls" endof     2 of " rox" endof         3 of " rot" endof   >r " ??" r>  endcase $type  ;: .ROTLR  ( --- )   3 AND  .ROT$  8?    IF    ASCII l      ELSE  ASCII r@      THEN  EMIT  ;: NIB14 (  --- ) 6&7?    IF    OPP/9  .ROTLR  .SOURCE  .BYTE   8 +CYCLES    ELSE  OPP/3  .ROTLR  .SIZE  ( REG )  OPP/9  5?          IF    .DREG                       ELSE  7 AND  .#  .NUM             THEN   OPP ,DREG   6 2 +IF-LONG    THEN   ;DECIMAL: NIB13  ( --- ) OPP/9   OPP $ C0 AND $ C0 =  ( OPP/9  FLAG )   IF    ." adda"  8? 1+ DISM-SIZE ! .SIZE  .SOURCE ,AREG           8 +CYCLES  -2 +MEM    ELSE  OPP  $ 130 AND $ 100 =   IF      ." addx"  .SIZE  ( OP/9 ) OPP  3?           IF      .-A@  .,   .-A@   18 12            ELSE  .DREG ,DREG         4   4            THEN   +IF-LONG    ELSE    ." add"  .SIZE   8?           IF    ( ->DN )   .DREG   ,SOURCE  4 2 ( +2 IF DN )  APPROX ON            ELSE  ( => EA )  .SOURCE ,DREG    4 2             THEN   +IF-LONG    then then  ;DECIMAL 16 fig-var  DISM-BASE\ UNCODE DEFINITIONSTRUE fig-var  .DISM#: .ADDRESS   ( --- ) ( .DISM# @ )    ( IF )   BASE @ >R  DISM-BASE @  BASE !  0CR             DISM-ADR @ .ADR    R> BASE !    ( THEN ) OPCODE-COL @ COLUMN  ;: .16bit ( n1 -- )  4 0  DO    dup $ f000 and  12 -shift .hx  4 +shift  LOOP  drop  ;: .CODES ( ADR --- )  .DISM# @\    IF    CODE-COL @ COLUMN     DISM-ADR @ SWAP\          DO       I W@  ( 5 .R )  space .16bit\          2 +LOOP      IF    CODE-COL @ COLUMN     DISM-ADR @ over - 2/ 0          DO       dup W@  ( 5 .R )  space .16bit 2+          LOOP drop     ELSE DROP    THEN  ;: .colon   ( --- )  ." :" ;0 fig-var  CLOCK 7 CLOCK ! 0 fig-var  TOTAL-CYCLES 0 fig-var  SHOW-CYCLES  SHOW-CYCLES ON: .CYCLES  ( --- ) SHOW-CYCLES @    IF     CYCLE-COL @ COLUMN  .((  #CYCLES @ 2 .R  #CYCLES/ @ DUP          IF   DUP  ." +" 1 .R ." /"          THEN DROP .colon #CYCLES @ TOTAL-CYCLES @ +          DUP TOTAL-CYCLES !    3 .R   TOTAL-CYCLES @ CLOCK @ / .colon 2 .R           .) APPROX @ IF   ASCII ? EMIT                   THEN ( FINAL-COL @ COLUMN )     THEN   ;\ ONLY FORTH ALSO UNCODE DEFINITIONS \ DECIMAL: INIT-DISM-WORD  ( ADR --- )  DISM-ADR !    .ADDRESS     DISM-ADR @ ?EVEN W@ OPCODE !   NEW-DISM-ADR OFF   #CYCLES      OFF   #CYCLES/     OFF   APPROX       OFF   MEM          OFF   DOING-CALL   OFF   dc.w?        off   ;\ ONLY FORTH UNCODE ALSO FORTH DEFINITIONS: DISM-DONE? ( --- FLAG )   NEW-DISM-ADR @     IF   NEW-DISM-ADR @  ?EVEN DISM-ADR     !            NEW-DISM-ADR OFF     THEN  DISM-DONE @  ;: DISM-WORD?  ( Adr --- Adr+ Flag )  INIT-DISM-WORD   ( -- )  BASE @ >R  DISM-BASE @ BASE !   DISM-ADR @  >R      SET-SIZE  12 4 @OPP-BITS    case       0 of  NIB0    endof  1 of  NIB1-3    endof   2 of  NIB1-3    endof       3 of  NIB1-3  endof  4 of  NIB4      endof   5 of  NIB5      endof       6 of  NIB6    endof  7 of  .MOVEQ    endof   8 of  NIB8      endof       9 of  NIB9    endof 10 of  .DW       endof  11 of  NIB11     endof      12 of  NIB12   endof 13 of  NIB13     endof  14 of  NIB14     endof      15 of  .DW     endof    endcase  A2+   R> .CODES DECIMAL .CYCLES  R> BASE !   DISM-ADR @ DISM-DONE?   >r >r  ?PAUSE  r> r> ;: INIT-DISM ( FROM --- ) ?EVEN  START-ADR !     ( $ -80000000 )  [ $7fffffff 1+ ] literal   HIGH-BRANCH !   DISM-DONE     OFF    TOTAL-CYCLES  OFF  ;\ ONLY FORTH DEFINITIONS0 fig-var  DISM-CYCLES     TRUE fig-var  DISM-NAMES: SELECT-DISM-DEFAULTS  ( -- , select the system default dism state )  ( [ ALSO UNCODE ] )  DISM-CYCLES @ SHOW-CYCLES !  DISM-NAMES  @ .REGNAMES?  !   ( [ PREVIOUS ] ) ;\ ONLY FORTH ALSO UNCODE DEFINITIONS: <DISM>  ( ADR --- )  0 out !  DUP INIT-DISM    SELECT-DISM-DEFAULTS    BEGIN   DISM-WORD?    UNTIL   DROP  0CR  ;\ ONLY FORTH UNCODE ALSO FORTH DEFINITIONS: DISM  ( ADR --- )  DISM-ORIGIN OFF  <DISM> ;: RELDISM  ( origin-adr dism-adr -- )  swap DISM-ORIGIN !  <DISM>  ;: RISM  ( ADR --- ) ( * RELATIVE DISM )  DUP DISM-ORIGIN !  <DISM> ;: ADISM  ( abs-adr --- )  DUP >REL SWAP OVER - NEGATE DISM-ORIGIN ! <DISM> ;\ .NEED $SKIP\ : $SKIP  ( ADR --- ADR' )  DUP $SIZE + ;\ .THEN\ \ 0 fig-var THE-CFA\ DECIMAL \ \ : DEF  ( --- )  BASE @ >R  HEX  SELECT-DISM-DEFAULTS\     DISM-ORIGIN OFF\     [COMPILE]  '  DUP   DUP>R     DUP INIT-DISM \     BEGIN  DUP   W@ ( adr opcode )  \  \             DUP BSR-CODE =\                IF   drop dup 2+ dup w@ w->s + THE-CFA !\                ELSE DUP  jsr-code  =\                IF   drop dup 2+ @ >rel THE-CFA !\                ELSE DUP JSR+64K-CODE =\                IF   drop dup 2+ w@ w->s $ 1,0000 + THE-CFA !\                ELSE DUP JSR+ORG-CODE =\                IF   drop dup 2+ w@ w->s THE-CFA !\                ELSE drop THE-CFA OFF\            then then then then  \  \              DISM-WORD?  \  \              >R  THE-CFA @ ' (.")       = \                  THE-CFA @ ' ($")       =  OR \                  THE-CFA @ ' (?ABORT")  =  OR\            IF       cr CR  ." '"  DUP $TYPE $SKIP ." '"  CR\            THEN R> \     UNTIL 2DROP r@ >NAME  \     >newline  cr dup id. ."  is "  IMMEDIATE?  \     IF    ." IMMEDIATE, "\     THEN  r> r> base !   \     dup  DISM-ADR @ - ABS  dup 1 .r ."  bytes long ("  \           CELL/ .  ." cells), defined as '"\           CELL- @\           CONDITION\             dup 0<              IF   drop ." inline'"  ELSE\             dup $ 4000,0000 and IF   drop ." called'"  ELSE\             drop ." both'"\           ENDCOND\     CR CR   ;\ \ : SEE DEF ;\ only forth definitionsDECIMAL\ ;MODULE: DEF ( <name> -- )	[compile] ' dism ;