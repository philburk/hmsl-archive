* Low level MIDI driver for Macintosh** Authors: Phil Burk* Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.** The direct use of the SCC chip is based on an article by Kirk Austin in MacTutor* Define offsets to match Forth definition of circular buffer.cb_base		EQU		0	; ABSOLUTE base address of buffercb_size		EQU		4	; number of bytes allocatedcb_count	EQU		8	; number of bytes incb_in		EQU		12	; index of next empty bytecb_out		EQU		16	; index of next byte outcb_overflowed	EQU	20	; true if overcb_underflowed	EQU	21	; true if underflowedcb_overrun	EQU		22	; true if buffer overruncb_pad		EQU		23	; to align addressesCircularBufferSize	EQU	24	; size of circular buffer control structure* -------------------------------MIDI Globals--------------------------------CM_XMIT_BUF_A	DS.L	CircularBufferSizeCM_RECV_BUF_A	DS.L	CircularBufferSizeCM_XMIT_BUF_B	DS.L	CircularBufferSizeCM_RECV_BUF_B	DS.L	CircularBufferSizeAddrOfTime		DC.L	0	; address of where time can be foundRX_STAMP_A		DS.L	1	; time stamps for incoming dataRX_STAMP_B		DS.L	1	; time stamps for incoming data*  Serial Chip AddressesSCCRd			EQU		$1D8  ( these are pointers to scc addresses )SCCWr			EQU		$1DCAData			EQU		6ACtl			EQU		2BData			EQU		4BCtl			EQU		0DataOffset		EQU 	4TBE				EQU		2*  Interrupt Vector Addresses- now constants for both portsLvl1DT			EQU		$192Lvl2DT			EQU		$1B2RxIntOffsetA	EQU		24TxIntOffsetA	EQU		16SpecRecCondA	EQU		28RxIntOffsetB	EQU		8TxIntOffsetB	EQU		0SpecRecCondB	EQU		12ChnResetA		EQU		80ChnResetB		EQU		40*  this is the space for the special condition interrupt routinesMIDIERRORSA 	DS.L	1MIDIERRORSB 	DS.L	1SpecRecHandA*	MOVE.W	SR,-(A7)	;  Save status register*	ORI.W	#$0300,SR	;  Disable interrupts	MOVE.B	#%00110000,(A1) ;  reset error condition	MOVE.L	(A7),(A7)	;  Delay	LEA	MIDIERRORSA,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets*	MOVE.W	(A7)+,SR	;  Restore interrupts	RTSSpecRecHandB*	MOVE.W	SR,-(A7)	; Save status register*	ORI.W	#$0300,SR	;  Disable interrupts	MOVE.B	#%00110000,(A1) ;  reset error condition	MOVE.L	(A7),(A7)	;  Delay	LEA	MIDIERRORSB,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets*	MOVE.W	(A7)+,SR	;  Restore interrupts	RTSCB_LL_IN ; ( D0:byte A0:cbuf -- ); D0 = data byte; D1 = index; A0 = cb_absolute; A1 = scratch address    move.l  cb_base(a0),a1		; ABS base address of data    move.l  cb_in(a0),d1		; index-offset to next slot    move.b  d0,$0(a1,d1)		; store byte    addq.l  #1,d1				; incr offset    cmp.l   cb_size(a0),d1    ; wrap around if past end    blt     @1    moveq.l #0,d1@1	move.l  d1,cb_in(a0)      ; update in pointer    move.l  cb_count(a0),d0   ; check for overflow    cmp.l   cb_size(a0),d0     bge     @2    addi.l  #1,cb_count(a0)   ; incr count if room    bra     @3@2	move.b  #$FF,cb_overflowed(a0)    move.l  d1,cb_out(a0)     ; bump out to get latest data@3	rtsCB_LL_OUT ; ( A0:cb_abs -- D0:byte ); D0 = data byte; D1 = index; A0 = cb_absolute; A1 = scratch address    move.l  cb_base(a0),a1  ; base of data    move.l  cb_out(a0),d1   ; index to byte to be read    moveq.l #0,d0             ; clear reg    move.b  $0(a1,d1),d0      ; read byte to d0    addq.l  #1,d1             ; increment index    cmp.l   cb_size(a0),d1  ; wrap around ?    blt     @1    moveq.l #0,d1             ; wrap to zero if at end@1	move.l  d1,cb_out(a0)   ; update out    subi.l  #1,cb_count(a0) ; decrement count	rts*  These are the routines to transmit a MIDI byte of data.  To use this routine*  place the byte to be transmitted as the lower 8 bits of a word on the*  stack, then BSR to MIDI.XMIT.A or MIDI.XMIT.B.		MACRO		P_MIDI_XMIT 	&port  ( byte -- )		MOVE.W	SR,-(A7)	;  Save priority level		MOVEM.L	D0-D1/A0-A3,-(A7)	;  Save registers		ORI.W	#$0700,SR	;  Disable interrupts completely		MOVE.L	(A6)+,D1	;  Get byte from Forth Stack		MOVE.L	CM_XMIT_BUF_&port+cb_count,D0		BNE		@add		;  if not empty, add to queue** Queue must be empty, check for readiness of SCC chip		MOVE.L	SCCRd,A0	;  get SCC Read Address		MOVE.L	SCCWr,A1	;  get SCC Write address		MOVE.W	#&port.Ctl,D0		;  get index for Ctl		BTST	#TBE,0(A0,D0)	;  chip transmit buffer empty?		BEQ		@add			;  if chip not ready,  add to queue* FirstByte		MOVE.W	#&port.Data,D0	;  get index to data		MOVE.L	(A7),(A7)	;  delay		MOVE.B	D1,0(A1,D0)	;  write data to SCC		MOVE.L	(A7),(A7)	;  Delay		BRA		@exit* Add byte to queue.@add	LEA		CM_XMIT_BUF_&port,A0	;  get the address		MOVE.L	D1,D0		BSR		CB_LL_IN*@exit	MOVEM.L	(A7)+,D0-D1/A0-A3	;  Restore registers %M		MOVE.W	(A7)+,SR	;  Restore interrupts		RTS			;  and return		ENDMADDR_OF_TIME  ; ( -- addr , set to address of time-counter )	LEA		AddrOfTime,A0	MOVE.L	A0,-(A6)	RTS	* ----------------------------------------------------------------------*  This is the interrupt routine for receiving a byte of MIDI data.  It*  places the received byte in a circular queue to be accessed later by*  the application.*  two routines: one for each port.	MACRO	RX_INT_HAND	&port* A0 = address of SCC, don't touch!* Get byte from port@3	MOVE.W	#DataOffset,D1	;  get data offset	CLR.L	D0		;  prepare for data	MOVE.B	0(A0,D1),D0	;  read data from SCC	CMP.B	#$FE,D0		;  check for Active Sensing, reject if = $FE	BEQ		@2** Put data in buffer	MOVE.L	A0,-(A7)	; save address of SCC	LEA		CM_RECV_BUF_&port,A0	BSR		CB_LL_IN** Put TIME STAMP in buffer* D0 = index into buffer	MOVE.L	AddrOfTime,A2	MOVE.L	(A2),D1			; get time	MOVE.L	CM_RECV_BUF_&port+cb_in,D0	ASL.L	#2,D0			; convert index to cell offset	MOVE.L	RX_STAMPS_&port,A2	; get address of queue	MOVE.L	D1,0(A2,D0)		; put time in buffer	MOVE.L	(A7)+,A0		; restore address of SCC*@2	BTST	#0,(A0)		;  is there more data?	BNE	@3		;  do again if there is	RTS		;  and return	ENDM* ----------------------------------------------------------------------*  TxIntHand  - Transmit Interrupt Handler**  It checks to see if there is any data to send.  If there is it sends it to*  the SCC.  If there isn't it resets the TBE interrupt in the SCC and exits.*  There's one routine for each output buffer.*  This is called when the previous byte is finished transmitting.* ----------------------------------------------------------------------	MACRO	TX_INT_HAND	&port	MOVE.L	A1,A3		; move address of SCC to safe register	LEA		CM_XMIT_BUF_&port,A0	;  point to queue	BSR		CB_LL_OUT		; get byte in D0	MOVE.W	#DataOffset,D1	;  get data offset	MOVE.B	D0,0(A3,D1)		;  write data to SCC	MOVE.L	CM_XMIT_BUF_&port+cb_count,D0		;  Is queue empty?	BEQ	@off				;  if so, turn off interrupts	RTS@off		MOVE.B	#$28,(A3)	;  if so, reset TBE interrupt	RTS			;  and return	ENDM* ----------------------------------------------------------------* Declare routines using macrosP_MIDI_XMIT_A	P_MIDI_XMIT	ARX_INT_HAND_A	RX_INT_HAND	ATX_INT_HAND_A	TX_INT_HAND	AP_MIDI_XMIT_B	P_MIDI_XMIT	BRX_INT_HAND_B	RX_INT_HAND	BTX_INT_HAND_B	TX_INT_HAND	B			SVARIABLE	CM_XMIT_BUF_A		SVARIABLE	CM_RECV_BUF_A		SVARIABLE	CM_XMIT_BUF_B		SVARIABLE	CM_RECV_BUF_B				SVARIABLE	RX_STAMPS_A		SVARIABLE	RX_STAMPS_B		* This stuff was from H4th.a* Custom MIDI Support				NFW			'(MIDI.XMIT.A)',P_MIDI_XMIT_A				NFW			'(MIDI.XMIT.B)',P_MIDI_XMIT_B				NFW			'RX.INT.HAND.A',RX_INT_HAND_A				NFW			'RX.INT.HAND.B',RX_INT_HAND_B				NFW			'TX.INT.HAND.A',TX_INT_HAND_A				NFW			'TX.INT.HAND.B',TX_INT_HAND_B				NFW			'MIDI.TIME@.A',MIDI_GET_TIME_A				NFW			'MIDI.TIME@.B',MIDI_GET_TIME_B				NFW			'ADDR-OF-TIME',ADDR_OF_TIME				NFW			'CM-XMIT-BUF-A',SYSV_CM_XMIT_BUF_A				NFW			'CM-RECV-BUF-A',SYSV_CM_RECV_BUF_A				NFW			'CM-XMIT-BUF-B',SYSV_CM_XMIT_BUF_B				NFW			'CM-RECV-BUF-B',SYSV_CM_RECV_BUF_B				NFW			'CB.LL.IN',CB_LL_IN				NFW			'CB.LL.OUT',CB_LL_OUT				NFW			'RX-STAMPS-A',SYSV_RX_STAMPS_A				NFW			'RX-STAMPS-B',SYSV_RX_STAMPS_B* Custom MIDI support				ENTRY		P_MIDI_XMIT_A , RX_INT_HAND_A , TX_INT_HAND_A				ENTRY		P_MIDI_XMIT_B , RX_INT_HAND_B , TX_INT_HAND_B				ENTRY		ADDR_OF_TIME				ENTRY		SYSV_CM_XMIT_BUF_A , SYSV_CM_RECV_BUF_A				ENTRY		SYSV_CM_XMIT_BUF_B , SYSV_CM_RECV_BUF_B				ENTRY		CB_LL_IN, CB_LL_OUT				ENTRY		SYSV_RX_STAMPS_A, SYSV_RX_STAMPS_B