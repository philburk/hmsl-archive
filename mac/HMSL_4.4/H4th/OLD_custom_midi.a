* V3.17* Low level MIDI driver for Mac+, MAC SE and Mac II** Authors: Phil Burk, Kirk Austin and Steven Curtin* Converted to MACH2 Assembler and enhanced by Phil Burk  9/23/86* Additional enhancements by Steven Curtin   2/26/88* Converted to Motorola Assembler by Phil Burk 8/14/89* Reviced as alternative to MIDI Manager by Phil Burk 7/2/91** Copyright 1986 -  Phil Burk, Larry Polansky, David Rosenboom.** This code is based on an article by Kirk Austin in MacTutor* The call interface of the routines and the syntax was rewritten* to work with Forth.  New routines were added at the bottom.** MIDI_CODE		PROC	EXPORT* 			EXPORT	( P_MIDI_XMIT_A , MIDI_XFULL_A , MIDI_RECV_A) : CODE*			EXPORT	( SCCINITA, SCCRESETA ) : CODE*			EXPORT	( P_MIDI_XMIT_B , MIDI_XFULL_B , MIDI_RECV_B ) : CODE*			EXPORT	( SCCINITB, SCCRESETB ) : CODE*			EXPORT ( MIDI_GET_TIME_A, MIDI_GET_TIME_B , ADDR_OF_TIME) : CODE			* Set size of MIDI XMIT and RECV buffers. ----------------------------------TxQSize			EQU		1024RxQSize			EQU		1024* -------------------------------MIDI Globals--------------------------------CtlOffset		DC.W	1	;  offset for channel controlChnReset		DC.B	1	; SCC channel reset selectHMSLCounter		DC.L	0	; Current counter valueAddrOfTime		DC.L	0	; address of where time can be foundTxQueueA 		DS.B	TxQSize	; TRANSMIT data queueTxQueueB 		DS.B	TxQSize ; data queueTxQEmptyA		DC.W	$FFFF	;  Transmit queue empty flagTxQEmptyB		DC.W	$FFFF	;  Transmit queue empty flagTxByteInA		DC.W	0	;  index to next cell inTxByteInB		DC.W	0	;  index to next cell inTxByteOutA		DC.W	0	;  index to next cell outTxByteOutB		DC.W	0	;  index to next cell outPTxIntHandA 	DC.L	0	;  storage for previous handlerPTxIntHandB 	DC.L	0	;  storage for previous handlerRxQueueA 		DS.B	RxQSize	; RECEIVED data queueRxQueueB 		DS.B	RxQSize	; RECEIVED data queueRxTimesA		DS.B	RxQSize*4	; time stamps for incoming dataRxTimesB		DS.B	RxQSize*4	; time stamps for incoming dataRxQEmptyA		DC.W	$FFFF	;  receive queue empty flagRxQEmptyB		DC.W	$FFFF	;  receive queue empty flagRxByteInA		DC.W	0	;  index to next cell inRxByteInB		DC.W	0	;  index to next cell inRxByteOutA		DC.W	0	;  index to next cell outRxByteOutB		DC.W	0	;  index to next cell outPRxIntHandA 	DC.L	0	;  storage for previous handlerPRxIntHandB 	DC.L	0	;  storage for previous handlerPrevIVC			DC.L	0	;  storage for prev timer int.*  Serial Chip AddressesSCCRd			EQU		$1D8  ( these are pointers to scc addresses )SCCWr			EQU		$1DCaData			EQU		6aCtl			EQU		2bData			EQU		4bCtl			EQU		0DataOffset		EQU 	4TBE				EQU		2*  Interrupt Vector Addresses- now constants for both portsLvl1DT			EQU		$192Lvl2DT			EQU		$1B2RxIntOffsetA	EQU		24TxIntOffsetA	EQU		16SpecRecCondA	EQU		28RxIntOffsetB	EQU		8TxIntOffsetB	EQU		0SpecRecCondB	EQU		12ChnResetA		EQU		80ChnResetB		EQU		40*  6522 equatesVIA			EQU 	$1D4vT1C		EQU		$800vT1H		EQU		$A00vT1L		EQU		$C00vACR		EQU		$1600vIER		EQU		$1C00*  this is the space for the special condition interrupt routinesMIDIERRORSA 	DS.L	1MIDIERRORSB 	DS.L	1StubA*	MOVE.W	SR,-(A7)	;  Save status register*	ORI.W	#$0300,SR	;  Disable interrupts	MOVE.B	#%00110000,(A1) ;  reset error condition	MOVE.L	(A7),(A7)	;  Delay	LEA	MIDIERRORSA,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets*	MOVE.W	(A7)+,SR	;  Restore interrupts	RTSStubB*	MOVE.W	SR,-(A7)	; Save status register*	ORI.W	#$0300,SR	;  Disable interrupts	MOVE.B	#%00110000,(A1) ;  reset error condition	MOVE.L	(A7),(A7)	;  Delay	LEA	MIDIERRORSB,A0	;  Offset to data area	ADDQ.L	#1,(A0)		; Count error resets*	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS*  These are the routines to transmit a MIDI byte of data.  To use this routine*  place the byte to be transmitted as the lower 8 bits of a word on the*  stack, then BSR to MIDI.XMIT.A or MIDI.XMIT.B.P_MIDI_XMIT_A 	;  ( byte -- )	MOVE.W	SR,-(A7)	;  Save priority level	MOVEM.L	D0-D1/A0-A3,-(A7)	;  Save registers	ORI.W	#$0700,SR	;  Disable interrupts completely	MOVE.L	(A6)+,D1	;  Get byte from Forth Stack %M	CLR.L	D0		;  Clear high word for proper offsets %M!!	LEA	TxQEmptyA,A3	TST.B	(A3)	;  is TxQueue empty?	BNE	@3		;  if empty, branch %M* Add byte to queue.@1	LEA	TxByteInA,A3	;  get the address	MOVE.W	(A3),D0		;  get index of next position in queue	LEA	TxQueueA,A2	;  point to queue	MOVE.B	D1,0(A2,D0)	;  place byte in queue %M	ADDQ.W	#1,D0		;  update TxByteIn	CMP.W	#TxQSize,D0	BNE	@2	MOVEQ.L	#0,D0		; Wrap around circular buffer.@2	MOVE.W	D0,(A3)	BRA	@5		;  and exit %M* Queue must be empty, check for readiness of SCC chip@3	MOVE.L	SCCRd,A0	;  get SCC Read Address	MOVE.L	SCCWr,A1	;  get SCC Write address	MOVE.W	#aCtl,D0		;  get index for Ctl	BTST	#TBE,0(A0,D0)	;  transmit buffer empty? %M	BNE	@4		;  if chip ready,  branch to output byte	LEA	TxQEmptyA,A3	;  get the address	MOVE.W	#0,(A3)		;  reset queue empty flag	BRA	@1		;  add byte to queue* FirstByte@4	MOVE.W	#aData,D0	;  get index to data	MOVE.L	(A7),(A7)	;  delay	MOVE.B	D1,0(A1,D0)	;  write data to SCC	MOVE.L	(A7),(A7)	;  Delay* TxExit@5	MOVEM.L	(A7)+,D0-D1/A0-A3	;  Restore registers %M	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return* Return true if MIDI Xmit Queue is full.MIDI_XFULL_A ; ( -- flag )	MOVE.W	SR,-(A7)	;  Save interrupts	ORI.W	#$0700,SR	;  Disable interrupts completely*	MOVE.L	#0,D1		;  default is false	LEA	TxQEmptyA,A0	TST.B	(A0)		;  is TxQueue empty?	BNE	@1		;  if so branch	MOVE.W	TxByteInA,D0	;  are pointers at same position?!!!	CMP.W	TxByteOutA,D0	BNE	@1	MOVE.L	#-1,D1		;  if so change flag to true*@1	MOVE.L	D1,-(A6)	;  push flag to stack	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return* ----------------------------------------------------------------------*  MIDI.RECV  ( -- byte true OR false , recieve character if any )* ----------------------------------------------------------------------	MACRO	MIDI_RECV	&port	LEA	RxQEmpty&port,A0	;  get the address	TST.B	(A0)		;  any data available?	BEQ	@1		;  if so, branch	MOVE.L	#0,-(A6)	;  if not, return with false	BRA	@3** get data from buffer and place on stack@1	MOVE.W	RxByteOut&port,D0	;  get index to byte out	LEA		RxQueue&port,A0		;  point to queue	MOVE.L	#0,D1		;  clear data register	MOVE.B	0(A0,D0),D1	;  get MIDI data	MOVE.L	D1,-(A6)	;  place it on stack for return	MOVE.L	#$FFFFFFFF,-(A6)	; leave true flag** increment and wrap index	ADDQ.W	#1,D0		;  increment index	CMP.W	#RxQSize,D0	BNE	@2	MOVE.W	#0,D0@2	LEA		RxByteOut&port,A0	; save new index	MOVE.W	D0,(A0)** Check to see if queue is now empty	MOVE.W	SR,-(A7)	;  Save interrupts	ORI.W	#$0700,SR	;  disable interrupts completely	MOVE.W	RxByteIn&port,D1	CMP.W	D0,D1		;  is queue empty?	BNE	@4		;  if not exit	LEA		RxQEmpty&port,A0	;  if empty, set flag %M	MOVE.W	#$FFFF,(A0)@4	MOVE.W	(A7)+,SR	;  restore interrupts** RxExit@3	RTS		;  and return	ENDM* Declare routine using macroMIDI_RECV_A	MIDI_RECV	AADDR_OF_TIME  ; ( -- addr , set to address of time-counter )	LEA		AddrOfTime,A0	MOVE.L	A0,-(A6)	RTS	* ----------------------------------------------------------------------*  This is the interrupt routine for receiving a byte of MIDI data.  It*  places the received byte in a circular queue to be accessed later by*  the application.*  two routines: one for each port.	MACRO	RxIntHand	&port* A0 = address of SCC, don't touch!* Get byte from port@3	MOVE.W	#DataOffset,D0	;  get data offset	CLR.L	D1		;  prepare for data	MOVE.B	0(A0,D0),D1	;  read data from SCC	CMP.B	#$FE,D1		;  check for Active Sensing, reject if = $FE	BEQ		@2** Put data in buffer	LEA		RxQueue&port,A2	;  point to queue	MOVE.W	RxByteIn&port,D0	;  get offset to next cell %M	MOVE.B	D1,0(A2,D0)	;  put byte in buffer %M** Increment and wrap index	ADDQ.W	#1,D0		;  increment index	CMP.W	#RxQSize,D0 ; check for overflow	BNE	@1	MOVE.W	#0,D0		; set to 0 if wrapped@1	LEA	RxByteIn&port,A3	; get address of RxByteIn	MOVE.W	D0,(A3)		; then update memory** Put TIME STAMP in buffer* D0 = index into buffer	MOVE.L	AddrOfTime,A2	MOVE.L	(A2),D1			; get time	ASL.L	#2,D0			; convert index to cell offset	LEA		RxTimes&port,A2	;  point to queue	MOVE.L	D1,0(A2,D0)		; put time in buffer*	LEA	RxQEmpty&port,A3	;  get address	MOVE.W	#0,(A3)		;  set flag to "queue not empty"*@2	BTST	#0,(A0)		;  is there more data?	BNE	@3		;  do again if there is	RTS		;  and return	ENDM	RxIntHandA	RxIntHand	A	* ----------------------------------------------------------------------*  MIDI.RTC.TIME@  ( -- time , of last byte )* ----------------------------------------------------------------------	MACRO	MIDI_GET_TIME   &port	* Gett TIME STAMP from buffer	CLR.L	D0	MOVE.W	RxByteOut&port,D0	; get next out index, that's where time for last was stored	ASL.L	#2,D0				; convert index to cell offset	LEA		RxTimes&port,A0		;  point to buffer	MOVE.L	0(A0,D0),-(A6)		; put time on stack	RTS	ENDM	MIDI_GET_TIME_A  MIDI_GET_TIME	AMIDI_GET_TIME_B  MIDI_GET_TIME	B*  This are the interrupt routines for transmitting a byte of MIDI data.  It*  checks to see if there is any data to send.  If there is it sends it to*  the SCC.  If there isn't it resets the TBE interrupt in the SCC and exits.*  There's one routine for each output buffer.TxIntHandA*	MOVE.W	SR,-(A7)	;  Save interrupts  %M*	ORI.W	#$0300,SR	;  disable interrupts %M	LEA	TxQEmptyA,A3	;  get address	TST.B	(A3)		;  Is queue empty?	BEQ	@1		;  if not branch	MOVE.B	#$28,(A1)	;  if so, reset TBE interrupt	MOVE.L	(A7),(A7)	;  Delay	BRA	@3		;  and exit@1	MOVE.W	TxByteOutA,D0		;  get index to next data byte	LEA	TxQueueA,A2	;  point to queue	MOVE.W	#DataOffset,D1	;  get data offset	MOVE.B	0(A2,D0),0(A1,D1)	;  write data to SCC	MOVE.L	(A7),(A7)	;  Delay	ADDQ.W	#1,D0		;  update index	CMP.W	#TxQSize,D0	BNE	@2	MOVE.W	#0,D0@2	LEA	TxByteOutA,A3	;  get address	MOVE.W	D0,(A3)	MOVE.W	TxByteInA,D1	;  get index %M	CMP.W	D0,D1		;  is TxQueue empty?	BNE	@3		;  if not exit	LEA	TxQEmptyA,A3	MOVE.W	#$FFFF,(A3)	;  if empty set flag* TxIExit@3	; MOVE.W	(A7)+,SR	;  restore interrupts	RTS			;  and return; --------------------- BBBBBBBB ------------------------------------P_MIDI_XMIT_B  ;   ( byte -- )	MOVE.W	SR,-(A7)	;  Save interrupts	MOVEM.L	D0-D1/A0-A3,-(A7)	;  Save registers	ORI.W	#$0700,SR	;  Disable interrupts completely	MOVE.L	(A6)+,D1	;  Get byte from Forth Stack %M	CLR.L	D0		;  Clear high word for proper offsets %M!!	LEA	TxQEmptyB,A3	TST.B	(A3)	;  is TxQueue empty?	BNE	@3		;  if so branch %M* Add byte to queue.@1	LEA	TxByteInB,A3	;  get the address	MOVE.W	(A3),D0		;  get index of next position in queue	LEA	TxQueueB,A2	;  point to queue	MOVE.B	D1,0(A2,D0)	;  place byte in queue %M	ADDQ.W	#1,D0		;  update TxByteIn	CMP.W	#TxQSize,D0	BNE	@2	MOVEQ.L	#0,D0		; Wrap around circular buffer.@2	MOVE.W	D0,(A3)	BRA	@5		;  and exit %M@3	MOVE.L	SCCRd,A0	;  get SCC Read Address	MOVE.L	SCCWr,A1	;  get SCC Write address	MOVE.W	#bCtl,D0		;  get index for Ctl	BTST	#TBE,0(A0,D0)	;  transmit buffer empty? %M	BNE	@4		;  if so branch %M	LEA	TxQEmptyB,A3	;  get the address	MOVE.W	#0,(A3)		;  reset queue empty flag	BRA	@1		;  add byte to queue* FirstByte@4	MOVE.W	#bData,D0	;  get index to data	MOVE.L	(A7),(A7)	;  delay	MOVE.B	D1,0(A1,D0)	;  write data to SCC	MOVE.L	(A7),(A7)	;  Delay* TxExit@5	MOVEM.L	(A7)+,D0-D1/A0-A3	;  Restore registers %M	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return	* Return true if MIDI Xmit Queue is full.MIDI_XFULL_B ; ( -- flag )	MOVE.W	SR,-(A7)	;  Save interrupts	ORI.W	#$0700,SR	;  Disable interrupts completely	MOVE.L	#0,D1		;  default is false	LEA	TxQEmptyB,A0	TST.B	(A0)		;  is TxQueue empty?	BNE	@1		;  if so branch	MOVE.W	TxByteInB,D0	;  are pointers at same position?!!!	CMP.W	TxByteOutB,D0	BNE	@1	MOVE.L	#-1,D1		;  if so change flag to true@1	MOVE.L	D1,-(A6)	;  push flag to stack	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return*  These are the routines to receive a byte of MIDI data-*  One routine for each port.MIDI_RECV_B	 MIDI_RECV B*  This is the interrupt routine for receiving a byte of MIDI data.  It*  places the received byte in a circular queue to be accessed later by*  the application.*  two routines: one for each port.RxIntHandB*	MOVE.W	SR,-(A7)	;  Save interrupts %M*	ORI.W	#$0300,SR	;  disable interrupts %M@3	MOVE.W	#DataOffset,D0	;  get data offset	CLR.L	D1		;  prepare for data	MOVE.B	0(A0,D0),D1	;  read data from SCC	CMP.B	#$FE,D1		;  check for Active Sensing, reject if = $FE	BEQ		@2	LEA	RxQueueB,A2	;  point to queue	MOVE.W	RxByteInB,D0	;  get offset to next cell %M	MOVE.B	D1,0(A2,D0)	;  put byte in queue %M	LEA	RxQEmptyB,A3	;  get address	MOVE.W	#0,(A3)		;  set flag to "queue not empty"	ADDQ.W	#1,D0		;  update index	CMP.W	#RxQSize,D0	BNE	@1	MOVE.W	#0,D0@1	LEA	RxByteInB,A3	;  get address	MOVE.W	D0,(A3)@2	BTST	#0,(A0)		;  is there more data?	BNE	@3		;  do again if there is*	MOVE.W	(A7)+,SR	;  restore interrupts	RTS		;  and return*  This are the interrupt routines for transmitting a byte of MIDI data.  It*  checks to see if there is any data to send.  If there is it sends it to*  the SCC.  If there isn't it resets the TBE interrupt in the SCC and exits.*  There's one routine for each output buffer.TxIntHandB*	MOVE.W	SR,-(A7)	;  Save interrupts  %M*	ORI.W	#$0300,SR	;  disable interrupts %M	LEA	TxQEmptyB,A3	;  get address	TST.B	(A3)		;  Is queue empty?	BEQ	@1		;  if not branch	MOVE.B	#$28,(A1)	;  if so, reset TBE interrupt	MOVE.L	(A7),(A7)	;  Delay	BRA	@3		;  and exit@1	MOVE.W	TxByteOutB,D0		;  get index to next data byte	LEA	TxQueueB,A2	;  point to queue	MOVE.W	#DataOffset,D1	;  get data offset	MOVE.B	0(A2,D0),0(A1,D1)	;  write data to SCC	MOVE.L	(A7),(A7)	;  Delay	ADDQ.W	#1,D0		;  update index	CMP.W	#TxQSize,D0	BNE	@2	MOVE.W	#0,D0@2	LEA	TxByteOutB,A3	;  get address	MOVE.W	D0,(A3)	MOVE.W	TxByteInB,D1	;  get index %M	CMP.W	D0,D1		;  is TxQueue empty?	BNE	@3		;  if not exit	LEA	TxQEmptyB,A3	MOVE.W	#$FFFF,(A3)	;  if empty set flag* TxIExit@3	; MOVE.W	(A7)+,SR	;  restore interrupts	RTS			;  and return* ------------------------------------------------------------------*  These are the initialization routinesSCCInit ; ( -- , NOT CALLED DIRECTLY, USE SCCInitA or SCCInitB )	MOVE.B	#4,(A0)		;  pointer for SCC reg 4	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$84,(A0)	;  32x clock, 1 stop bit	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#1,(A0)		;  pointer for SCC reg 1	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  No W/Req	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#3,(A0)		;  pointer for SCC reg 3	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  Turn off Rx	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#5,(A0)		;  pointer for SCC reg 5	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  Turn off Tx	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#11,(A0)	;  pointer for SCC reg 11	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00101000,(A0)	;  Make TRxC clock source	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#14,(A0)	;  pointer for SCC reg 14	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  Disable BRGen	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#3,(A0)		;  pointer for SCC reg 3	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%11000001,(A0)	;  Enable Rx	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#5,(A0)		;  pointer for SCC reg 5	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%01101010,(A0)	;  Enable Tx and drivers	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#15,(A0)	;  pointer for SCC reg 15	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00001000,(A0)	;  Enable DCD int for mouse	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  pointer for SCC reg 0	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00010000,(A0)	;  Reset EXT/STATUS	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  pointer for SCC reg 0	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00010000,(A0)	;  Reset EXT/STATUS again	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#1,(A0)		;  pointer for SCC reg 1	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00010011,(A0)	;  Enable interrupts	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#9,(A0)		;  pointer for SCC reg 9	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#%00001010,(A0)	;  Set master int enable	MOVE.L	(A7),(A7)	;  Delay	RTS			;  and returnSCCInitA	;	( -- , Initialize MIDI Output Port A )	MOVE.W	SR,-(A7)	;  Save interrupts	MOVEM.L	D0/A0-A2,-(A7)	;  Save registers	ORI.W	#$0300,SR	;  Disable interrupts	MOVE.L	SCCRd,A1	;  Get base Read address	ADDA.L	#aCtl,A1		;  set up globals for Chn A	MOVE.B	(A1),D0		;  Dummy read	MOVE.L	(A7),(A7)	;  Delay	MOVE.L	SCCWr,A0	;  Get base Write address	ADDA.L	#aCtl,A0		;  Add offset for control %M	MOVE.B	#9,(A0)		;  pointer for SCC reg 9	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$80,(A0)	;  Reset channel	MOVE.L	(A7),(A7)	;  Delay	BSR		SCCInit		; Branch to common init routine	MOVE.L	#Lvl2DT,A0	;  get dispatch table pointer	MOVE.L	#RxIntOffsetA,D0	;  get offset to Rx vector	LEA		PRxIntHandA,A1	;  point to previous Rx vector storage	MOVE.L	0(A0,D0),(A1)	;  save old vector	LEA		RxIntHandA,A1	;  set Rx vector	MOVE.L	A1,0(A0,D0)	MOVE.L	#TxIntOffsetA,D0	;  get offset to Tx vector	LEA		PTxIntHandA,A1	;  save previous Tx vector	MOVE.L	0(A0,D0),(A1)	LEA		TxIntHandA,A1	;  set Tx vector	MOVE.L	A1,0(A0,D0)	MOVE.W	#SpecRecCondA,D0	;  get offset to Special vector	LEA		StubA,A1	MOVE.L	A1,0(A0,D0)	LEA		RxByteInA,A2	;  init flags & pointers	CLR.W	(A2)	LEA		RxByteOutA,A2	CLR.W	(A2)	LEA		RxQEmptyA,A2	MOVE.W	#$FFFF,(A2)	LEA		TxByteInA,A2	CLR.W	(A2)	LEA		TxByteOutA,A2	CLR.W	(A2)	LEA		TxQEmptyA,A2	MOVE.W	#$FFFF,(A2)	MOVEM.L	(A7)+,D0/A0-A2	;  Restore registers	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and returnSCCInitB	; ( -- , Initialize MIDI Output Port B)	MOVE.W	SR,-(A7)	;  Save interrupts	MOVEM.L	D0/A0-A2,-(A7)	;  Save registers	ORI.W	#$0300,SR	;  Disable interrupts %M	MOVE.L	SCCRd,A1	;  Get base Read address	ADDA.L	#bCtl,A1		;  set up globals for Chn A	MOVE.B	(A1),D0		;  Dummy read	MOVE.L	(A7),(A7)	;  Delay	MOVE.L	SCCWr,A0	;  Get base Write address	ADDA.L	#bCtl,A0		;  Add offset for control %M	MOVE.B	#9,(A0)		;  pointer for SCC reg 9 !!!!!	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$40,(A0)	;  Reset channel   !!!!	MOVE.L	(A7),(A7)	;  Delay	BSR		SCCInit		; Branch to common init routine	MOVE.L	#Lvl2DT,A0	;  get dispatch table pointer	MOVE.L	#RxIntOffsetB,D0	;  get offset to Rx vector	LEA		PRxIntHandB,A1	;  point to previous Rx vector storage	MOVE.L	0(A0,D0),(A1)	;  save old vector	LEA		RxIntHandB,A1	;  set Rx vector	MOVE.L	A1,0(A0,D0)	MOVE.L	#TxIntOffsetB,D0	;  get offset to Tx vector	LEA		PTxIntHandB,A1	;  save previous Tx vector	MOVE.L	0(A0,D0),(A1)	LEA		TxIntHandB,A1	;  set Tx vector	MOVE.L	A1,0(A0,D0)	MOVE.W	#SpecRecCondB,D0	;  get offset to Special vector	LEA		StubB,A1	MOVE.L	A1,0(A0,D0)	LEA		RxByteInB,A2	;  init flags & pointers	CLR.W	(A2)	LEA		RxByteOutB,A2	CLR.W	(A2)	LEA		RxQEmptyB,A2	MOVE.W	#$FFFF,(A2)	LEA		TxByteInB,A2	CLR.W	(A2)	LEA		TxByteOutB,A2	CLR.W	(A2)	LEA		TxQEmptyB,A2	MOVE.W	#$FFFF,(A2)	MOVEM.L	(A7)+,D0/A0-A2	;  Restore registers	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return* -------------------------------------------------------------------*  This routine must be called when the application quits or the system will*  crash due to the interrupt handling pointers becoming invalid.SCCReset  ;	( -- )	MOVE.B	#15,(A0)	;  pointer for SCC reg 15	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$08,(A0)	;  Enable DCD int	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  pointer for SCC reg 0	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$10,(A0)	;  Reset EXT/STATUS	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#0,(A0)		;  pointer for SCC reg 0	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$10,(A0)	;  Reset EXT/STATUS again	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#1,(A0)		;  pointer for SCC reg 1	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$01,(A0)	;  Enable mouse interrupts	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#9,(A0)		;  pointer for SCC reg 9	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$0A,(A0)	;  Set master int enable	MOVE.L	(A7),(A7)	;  Delay	RTS			;  and returnSCCResetA  ; ( -- )	MOVE.W	SR,-(A7)	;  Save interrupts	ORI.W	#$0300,SR	;  Disable interrupts %M	MOVE.L	SCCWr,A0	;  Get base Write address	ADDA.W	#aCtl,A0		;  Add offset for control %M	MOVE.B	#9,(A0)		;  pointer for SCC reg 9	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$80,(A0)	;  Reset channel	MOVE.L	(A7),(A7)	;  Delay	BSR		SCCReset	; Branch to common reset routine	MOVE.L	#Lvl2DT,A0	;  get dispatch table pointer	MOVE.W	#RxIntOffsetA,D0	;  get offset to Rx vector	LEA		PRxIntHandA,A1	;  restore previous Rx vector	MOVE.L	(A1),0(A0,D0)	MOVE.W	#TxIntOffsetA,D0	;  get offset to Tx vector	LEA		PTxIntHandA,A1	;  restore previous Tx vector	MOVE.L	(A1),0(A0,D0)	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and returnSCCResetB  ; ( -- )	MOVE.W	SR,-(A7)	;  Save interrupts	ORI.W	#$0300,SR	;  Disable interrupts %M	MOVE.L	SCCWr,A0	;  Get base Write address	ADDA.W	#bCtl,A0		;  Add offset for control %M	MOVE.B	#9,(A0)		;  pointer for SCC reg 9  !!!!	MOVE.L	(A7),(A7)	;  Delay	MOVE.B	#$40,(A0)	;  Reset channel	MOVE.L	(A7),(A7)	;  Delay	BSR		SCCReset	; Branch to common reset routine	MOVE.L	#Lvl2DT,A0	;  get dispatch table pointer	MOVE.W	#RxIntOffsetB,D0	;  get offset to Rx vector	LEA		PRxIntHandB,A1	;  restore previous Rx vector	MOVE.L	(A1),0(A0,D0)	MOVE.W	#TxIntOffsetB,D0	;  get offset to Tx vector	LEA		PTxIntHandB,A1	;  restore previous Tx vector	MOVE.L	(A1),0(A0,D0)	MOVE.W	(A7)+,SR	;  Restore interrupts	RTS			;  and return*		ENDP