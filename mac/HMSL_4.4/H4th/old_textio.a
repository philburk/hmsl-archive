* Handle scrolled text I/O in a Mac window using Quickdraw Text** Macintosh Specific** Required words for other systems.*	TIO_TYPE	( addr count -- , output characters at addr )*	TIO_CR		( -- , output a carriage return )*	GOTOXY		( x y -- , move cursor to column x,  row y )*	TIO_CLS		( -- , clear screen )*	TIO_INIT	( -- , initialize system )*	TIO_UPDATE	( -- , update screen if neded )** An image of the output text is kept in a buffer.* Set Port to myWindow before output.*********************************************************************** HMSL Forth System                                                 ** Author: Phil Burk                                                 ** Copyright 1989 Phil Burk , All Rights Reserved                    **********************************************************************ScreenImage	; ( x y -- addr , calc address in screen image buffer)* 	tio_max_columns * + screen_buffer +	MOVE.L		(A6)+,D0	MULU.W		#tio_max_columns,D0	ADD.L		(A6)+,D0	LEA			screen_buffer,A0	ADDA.L		D0,A0	MOVE.L		A0,-(A6)	RTSQWINDOWSIZE  ; ( -- width height , get size of Forth window)	MOVEQ.L		#0,D0	MOVE.L		myWindow,A0	MOVE.W		$16(A0),D0	SUB.W		$12(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	MOVEQ.L		#0,D0	MOVE.W		$14(A0),D0	SUB.W		$10(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	RTSTIO_Adjust_Font	; ( -- , set char_width and height based on current font )* Use SCRATCH RECTANGLE for convenience	PEA			ScratchRect	_GetFontInfo	CLR.L		D0	LEA			ScratchRect,A0	MOVE.W		$0(A0),D0	ADD.W		$2(A0),D0	ADD.W		$6(A0),D0	MOVE.L		D0,line_height	MOVE.W		$4(A0),D0	MOVE.L		D0,char_width	RTSTio_Adjust_Window	; ( -- , set limits based on window size )* qwindowsize tio_base_y - line_height / 	BSR			QWINDOWSIZE	MOVE.L		(A6)+,D0	SUB.L		#tio_base_y,D0	MOVE.L		line_height,D1	DIVU.W		D1,D0	ANDI.L		#$FFFF,D0	SUBQ.L		#1,D0* 1 max tio_max_rows min	MOVE.L		D0,tio_num_rows* tio_base_x - char_width / 2-	MOVE.L		(A6)+,D0	SUB.L		#tio_base_x,D0	MOVE.L		char_width,D1	DIVU.W		D1,D0	ANDI.L		#$FFFF,D0	SUBQ.L		#2,D0* 1 max tio_max_columns min	CMP.L		#tio_max_columns,D0	BLT			@1	MOVE.L		#tio_max_columns,D0@1	MOVE.L		D0,tio_num_columns* FV_OUT @  tio_num_columns @ 1- min FV_OUT !* current_line @ tio_num_rows @ 1- min current_line !	RTS	TIO_Adjust	; ( -- , do all necessary adjustments )	BSR			TIO_Adjust_Font	BSR			TIO_Adjust_Window	RTS	TIO_Clear_Image ; ( -- )	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)* tio_max_rows tio_max_columns *   bl fill	MOVE.L		#tio_max_rows*tio_max_columns,-(A6)	MOVE.L		#$20,-(A6)	BSR			F_FILL	RTSTEXT_CLEAR ; ( -- , clear text screen )	MOVE.L		myWindow,-(A7)	_SetPort	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)	_EraseRect	RTS	TIO_COLROW2XY  ; ( col row -- x  y , calculate pixel position for text )* line_height * tio_base_y +	MOVE.L		(A6)+,D0	MOVE.L		line_height,D1	MULU.W		D1,D0	ADD.L		#tio_base_y,D0	MOVE.L		D0,-(A7)* swap char_width * tio_base_x +	MOVE.L		(A6)+,D1	MOVE.L		char_width,D0	MULU.W		D0,D1	ADD.L		#tio_base_x,D1	PUSH		D1	PUSH		(A7)+	RTS	TIO_CurRect  ; ( -- rect_addr, rectangle that covers current position )	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIO_COLROW2XY*	POP			D0				y pos	ADDQ.W		#3,D0	MOVE.W		D0,ScratchRect.bottom	MOVE.L		line_height,D1	SUB.W		D1,D0	MOVE.W		D0,ScratchRect.top*	POP			D0				x pos	MOVE.W		D0,ScratchRect.left	MOVE.L		char_width,D1	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.right	LEA			ScratchRect,A0	PUSH		A0	RTSTOGGLE_CURSOR  ; ( -- )	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIO_CurRect	MOVE.L		(A6)+,-(A7)    _InverRect	RTS	TIO_CURSOR_ON  ; ( -- )		MOVE.L		CursorState,D0		BNE.S		@done		BSR			TOGGLE_CURSOR		MOVE.L		#-1,CursorState@done	RTS				TIO_CURSOR_OFF	; ( -- )		MOVE.L		CursorState,D0		BEQ.S		@done		BSR			TOGGLE_CURSOR		CLR.L		CursorState@done	RTS	TIO_BLANK   ; ( -- , blank one character position )	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIO_CurRect	MOVE.L		(A6)+,-(A7)    _EraseRect							; clear place on screen* set screen image to BL at this position	PUSH		#$20					* FV_OUT @ current_line @ ScreenImage	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			ScreenImage	BSR			CSTORE	ADD.L		#1,FV_OUT	RTS	TIO_Clear_Screen ; ( -- , clear screen )    BSR			TEXT_CLEAR	MOVE.L		#0,current_line	MOVE.L		#0,FV_OUT	RTSTIO_CLS ; ( -- )	BSR			TIO_Clear_Screen	BSR			TIO_Clear_Image	RTSTIO_INIT ; ( -- )	LEA			TIO_UPDATE,A0	MOVE.L		A0,FV_UPDATE_FUNC	; set update vector	BSR			TIO_CLS	MOVE.W		#4,-(A7)	_TextFont	MOVE.W		#9,-(A7)	_TextSize	BSR			TIO_Adjust	RTSTIO_SCROLL_SCREEN ; ( -- , scroll visible region up by one line )* HMSL-WIndow rect_offset +	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)* 0 line_height @ negate	MOVE.W		#0,-(A7)	MOVE.L		line_height,D0	NEG.L		D0	MOVE.W		D0,-(A7)* HMSL-WINDOW UpdateRgn_offset + @	MOVE.L		myWindow,A0	ADDA.L		#UpdateRgn_offset,A0	MOVE.L		(A0),-(A7)	_ScrollRect	MOVE.L		#0,-(A7)	_SetOrigin	RTSTIOScrollImage ; ( -- , scroll image in buffer )* 0 1 ScreenImage 0 0 ScreenImage ( -- source dest )	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)	ADDA.L		#tio_max_columns,A0	MOVE.L		A0,-(A6)	BSR			SWAP* tio_num_rows @ chars_per_line * F_CMOVE	MOVE.L		tio_num_rows,D0	MULU.W		#tio_max_columns,D0	MOVE.L		D0,-(A6)	BSR			F_CMOVE* 0 tio_num_rows @ ScreenImage tio_max_columns bl fill	MOVE.L		#0,-(A6)	MOVE.L		tio_num_rows,D0	MOVE.L		D0,-(A6)	BSR			ScreenImage	MOVE.L		#tio_max_columns,-(A6)	MOVE.L		#$20,-(A6)	BSR			F_FILL	RTS	TIOMOVE ; ( col row -- , move cursor to new position )	BSR			TIO_COLROW2XY	POP			D0	POP			D1	MOVE.W		D1,-(A7)	MOVE.W		D0,-(A7)	_MoveTo	RTSTIO_OUTPUT ; ( addr count -- )	MOVE.L		myWindow,-(A7)	_SetPort* dup >r	MOVE.L		(A6),-(A7)*  FV_OUT @ current_line @	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIOMove* tio_max_columns min   !!!* dup tio_buffer c!	MOVE.L		(A6),D0	LEA			tio_buffer,A0	MOVE.B		D0,(A0)* tio_buffer 1+ swap F_CMOVE	ADDA.L		#1,A0	MOVE.L		A0,-(A6)	BSR			SWAP	BSR			F_CMOVE* tio_buffer gr.text	LEA			tio_buffer,A0	MOVE.L		A0,-(A7)	_DrawString* r> FV_OUT +!	MOVE.L		(A7)+,D0	ADD.L		FV_OUT,D0	MOVE.L		D0,FV_OUT	RTSGOTOXY ; ( col row -- )* current_line ! FV_OUT !	MOVE.L		(A6)+,current_line	MOVE.L		(A6)+,FV_OUT	RTSTIOSAVE ; ( addr count -- , save in screen image )* FV_OUT @ current_line @ ScreenImage	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			ScreenImage* swap F_CMOVE	BSR			SWAP	BSR			F_CMOVE	RTSTIOSAFETYPE ; ( addr count -- , count should not exceed tio_max_columns )	PUSH		#tio_max_columns	BSR			MIN	BSR			DDUP	BSR			tiosave	BSR			TIO_OUTPUT	RTSTIO_ROOM ; ( -- left , character colums remaining on line )* tio_num_columns @ 1- FV_OUT @ -	MOVE.L		tio_num_columns,D0	SUBQ.L		#1,D0	SUB.L		FV_OUT,D0	MOVE.L		D0,-(A6)	RTSTIO_IMAGE_CR ; ( -- , advance screen image pointer to next line )* current_line @ 1+ tio_num_rows @ >=	MOVE.L		current_line,D0	ADDQ.L		#1,D0	MOVE.L		tio_num_rows,D1	CMP.L		D0,D1	BGE.S		@1	BSR			tioscrollimage@1	RTSTIO_OUTPUT_CR ; ( -- , output CR without saving , scroll if necessary )	MOVE.L		myWindow,-(A7)	_SetPort* 0 FV_OUT !	MOVE.L		#0,FV_OUT* current_line @ 1+	MOVE.L		current_line,D0	ADDQ.L		#1,D0* dup tio_num_rows @ >=	MOVE.L		tio_num_rows,D1	CMP.L		D0,D1	BGE.S		@1	BSR			tio_scroll_screen	MOVE.L		current_line,D0	BRA.S		@2@1	MOVE.L		D0,current_line		* line_height @ * tio_base_y + tio_base_x swap gr.move@2	MOVE.L		line_height,D1	MULU.W		D1,D0	ADD.L		#tio_base_y,D0	MOVE.W		#tio_base_x,-(A7)	MOVE.W		D0,-(A7)	_MoveTo	RTSTIO_CR ; ( -- )		BSR			tio_image_cr		BSR			tio_output_cr		RTSTIOCurLineRect  ; ( -- rect_addr, rectangle that covers current line )	MOVE.L		#0,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIO_COLROW2XY*	POP			D0				y pos	ADDQ.W		#3,D0	MOVE.W		D0,ScratchRect.bottom	MOVE.L		line_height,D1	SUB.W		D1,D0	MOVE.W		D0,ScratchRect.top*	MOVE.L		char_width,D0	MOVE.L		tio_num_columns,D1	MULU.W		D1,D0	POP			D1				x pos	MOVE.W		D1,ScratchRect.left	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.right	LEA			ScratchRect,A0	PUSH		A0	RTSTIO_CLEAR_LINE   ; ( -- , blank current line )	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIOCurLineRect	MOVE.L		(A6)+,-(A7)    _EraseRect	RTS	TIO_UPDATE_LINE ; ( -- , draw from screen image )		MOVE.L		FV_OUT,-(A7)			; keep OUT safe		BSR			TIO_CLEAR_LINE*		PUSH		#0		PUSH		current_line		BSR			ScreenImage		MOVE.L		tio_num_columns,-(A6)		MOVE.L		#0,FV_OUT		BSR			TIO_OUTPUT		MOVE.L		(A7)+,FV_OUT		RTSTIO_UPDATE ; ( -- , draw from screen image )* D4 = counter* D3 = limit* FV_OUT @ >r current_line @ dup >r 0		MOVEM.L		D3-D4,-(A7)		MOVE.L		myWindow,-(A7)		_SetPort		BSR			Tio_Adjust			figure out new sizes		MOVE.L		FV_OUT,-(A7)		save variables from getting cleared by CLS		MOVE.L		current_line,-(A7)		BSR			TIO_Clear_Screen*		MOVE.L		(A7),D3				current_line -> D3		BLE.S		@2		MOVE.L		D3,D4		SUB.L		tio_num_rows,D4			don't display more than can fit on screen		BGE			@1		MOVEQ.L		#0,D4				start at no less then line 0** 0 i screenimage tio_max_columns TIO_OUTPUT tio_output_cr@1		MOVE.L		#0,-(A6)		MOVE.L		D4,-(A6)		BSR			ScreenImage		MOVE.L		tio_num_columns,-(A6)		BSR			TIO_OUTPUT		BSR			TIO_Output_CR		ADDQ.L		#1,D4		CMP.L		D4,D3		BNE.S		@1* 0 r> screenimage r> TIO_OUTPUT@2		MOVE.L		#0,-(A6)		MOVE.L		(A7)+,-(A6)		BSR			ScreenImage		MOVE.L		(A7)+,-(A6)		BSR			TIO_OUTPUT		MOVEM.L		(A7)+,D3-D4		RTSTIO_TYPE ; ( addr count -- )* BEGIN	2dup tio_room min dup >r tiosafetype@1		BSR			DDUP		BSR			TIO_ROOM		; type as much as will fit on line		BSR			MIN		MOVE.L		(A6),-(A7)		BSR			TIOSafeType*    r@ - swap r> + swap  ( -- addr' count' )   ; calc how much left		MOVE.L		(A7),-(A6)		BSR			MINUS		BSR			SWAP		MOVE.L		(A7)+,-(A6)		BSR			PLUS		BSR			SWAP		MOVE.L		(A6),D0		BLE.S		@2		BSR			tio_cr		BRA.S		@1				; print any left on next line@2		BSR			DDROP		RTSTIO_BACKWARDS	; ( N -- , move cursor backwards )		MOVE.L		FV_OUT,D0		POP			D1		SUB.L		D1,D0		decrement 		BGE.S		@1		CLR.L		D0			clip to zero@1		MOVE.L		D0,FV_OUT		RTSTIO_FORWARDS	; ( N -- , move cursor forwards )		POP			D1		ADD.L		D1,FV_OUT		increment 		RTSTIO_ERASE_EOL	; ( -- , erase from current position to end of line )		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr )		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage		BSR			OVER		BSR			MINUS		( -- addr count )		PUSH		#$20		BSR			F_FILL		BSR			TIO_UPDATE_LINE		RTSTIO_DELETE		; ( N -- , delete N chars from under cursor )		PUSH		FV_OUT		BSR			PLUS		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr0 )		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr0 addr1 )		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage		BSR			OVER		BSR			MINUS		( -- addr0 addr1 count )		BSR			F_CMOVE		BSR			TIO_UPDATE_LINE		RTSTIO_INSERT		; ( N -- , make room for N characters )		PUSH		(A6)		; DUP		PUSH		FV_OUT		BSR			PLUS		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrd )			char under cursor		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrd addrs )	char to mve up to		BSR			SWAP		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage							char at beginning of next line		BSR			OVER		BSR			MINUS		( -- N addrs addrd count )		BSR			F_CMOVEB							move chars up		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrs )		BSR			SWAP		PUSH		#$20		BSR			F_FILL								fill in with blanks		BSR			TIO_UPDATE_LINE		RTS* Test Text SystemASTRING		DC.B			'Some more exciting text!'AST			LEA				ASTRING,A0			MOVE.L			A0,-(A6)			RTS				TT			BSR			AST			BSR			COUNT			BSR			TIO_TYPE			RTS			TIOBUF		LEA			Tio_Buffer,A0			PUSH		A0			RTS