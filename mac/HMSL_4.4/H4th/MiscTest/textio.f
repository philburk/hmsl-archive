\ Handle scrolled text I/O in a Mac window using Quickdraw TextdecimalANEW TASK-TEXTIO11 constant LINE_HEIGHT6 constant CHAR_WIDTH80 constant CHARS_PER_LINE10 constant TIO_BASE_X10 constant TIO_BASE_Y20 constant MAX_LINES16 constant RECT-OFFSET122 constant UpdateRgn-OffsetVARIABLE CURRENT-LINE   ( 0 -> max_lines-1 )VARIABLE CURRENT-COLVARIABLE NUM_COLUMNSVARIABLE NUM_LINESCREATE TIO-BUFFER chars_per_line 4+ allot\ Create a buffer to contain line images.: 2DARRAY  ( numx numy -- )	CREATE over , * ALLOT	DOES> ( -- x y addr )		dup >r		@ ( x y numx ) * + r> 4+ +;chars_per_line max_lines 2darray ScreenImage: TIO.FONT  ( font# -- )	gr.setport	call textfont;: ?WINDOWSIZE ( -- width height )	hmsl-window [ rect-offset 6 + ] literal + w@  ( -- right )	hmsl-window [ rect-offset 2 + ] literal + w@  ( -- right left ) -	hmsl-window [ rect-offset 4 + ] literal + w@  ( -- w bottom )	hmsl-window [ rect-offset 0 + ] literal + w@  ( -- w bottom top ) -;: TIO.ADJUST.MARGINS  ( -- , set limits based on window size )	?windowsize tio_base_y - line_height /  1 max max_lines min num_lines !	tio_base_x - char_width / 2- 1 max chars_per_line min num_columns !	current-col @  num_columns @ 1- min current-col !	current-line @ num_lines @ 1- min current-line !;	: TIO.Clear.Image  ( -- )	0 0 ScreenImage    max_lines chars_per_line *   bl fill;: TIO.CLEAR.SCREEN  ( -- , clear screen )    	gr.clear	0 current-line !	0 current-col !;: TIO.CLS ( -- )	tio.clear.screen	tio.clear.image;: TIO.INIT  ( -- )	hmsl.open	tio.cls	4 tio.font	tio.adjust.margins;: TIO.SCROLL.SCREEN  ( -- , scroll visible region up by one line )	gr.setport	HMSL-WIndow Rect-Offset +	0 line_height negate	HMSL-WINDOW UpdateRgn-Offset + @	call ScrollRect	0 0 call SetOrigin;: TIO.SCROLL.IMAGE	0 1 ScreenImage 0 0 ScreenImage ( -- source dest )	num_lines @ 1- chars_per_line * cmove	0 num_lines @ 1- ScreenImage chars_per_line bl fill;: TIO.MOVE  ( col row -- )	line_height * tio_base_y +	swap char_width * tio_base_x +	swap gr.move;: TIO.OUTPUT  ( addr count -- )	dup >r	current-col @ current-line @ tio.move	gr.setport	chars_per_line min	dup tio-buffer c!	tio-buffer 1+ swap cmove	tio-buffer gr.text	r> current-col +!;: GOTOXY  ( col row -- )	current-line ! current-col !;: TIO.SAVE  ( addr count -- , save in screen image )	current-col @ current-line @ ScreenImage	swap cmove;: TIO.SAFETYPE  ( addr count -- , count should not exceed chars_per_line )	2dup tio.save	tio.output;: TIO_ROOM  ( -- left , character colums remining on line )	num_columns @ 1- current-col @ -;: TIO.IMAGE.CR  ( -- , advance screen image pointer )	current-line @ 1+ num_lines @ >=	IF tio.scroll.image	THEN;: TIO.OUTPUT.CR  ( -- , output CR without saving )	0 current-col !	current-line @ 1+	dup num_lines @ >=	IF drop tio.scroll.screen	ELSE num_lines 1- min current-line !	THEN  current-line @	line_height * tio_base_y + tio_base_x swap gr.move;: TIO.CR  ( -- )	tio.image.cr	tio.output.cr;: TIO.IMAGE.UPDATE  ( -- , draw from screen image )	current-col @ >r current-line @ >r	current-line @ 0	tio.clear.screen	DO 0 i screenimage chars_per_line tio.output tio.output.cr	LOOP	0 r> screenimage r> tio.output;: TIO.TYPE  ( addr count -- )	BEGIN	2dup tio_room min dup >r tio.safetype		r@ - swap r> + swap  ( -- addr' count' )		dup 0>	WHILE	tio.cr	REPEAT 2drop;variable TT-COUNTER0 tt-counter !: TT	tt-counter @ 1+ dup tt-counter !	n>text tio.type	"   " count tio.type	5 choose	CASE	0 OF " Four score and seven years..." ENDOF	1 OF " Greetings Earthling!" ENDOF	2 OF " Shortie" ENDOF	3 OF " Kinder and gentler dictatorship.." ENDOF	4 OF " Medium length." ENDOF	" Didn't expect this!!!" swap	ENDCASE	count tio.type tio.cr;: MTT ( n -- )	0 DO tt LOOP;