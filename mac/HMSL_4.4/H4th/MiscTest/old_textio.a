* Handle scrolled text I/O in a Mac window using Quickdraw TextScreenImage	; ( x y -- )* 	chars_per_line * + screen_buffer +	MOVE.L		(A6)+,D0	MULU.W		#chars_per_line,D0	ADD.L		(A6)+,D0	LEA			screen_buffer,A0	ADDA.L		D0,A0	MOVE.L		A0,-(A6)	RTSSET_FONT ; ( font# -- )	MOVE.L		(A6)+,D0	MOVE.W		D0,-(A7)	_TextFont	RTSQWINDOWSIZE  ; ( -- width height )	MOVEQ.L		#0,D0	MOVE.L		myWindow,A0	MOVE.W		$16(A0),D0	SUB.W		$12(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	MOVEQ.L		#0,D0	MOVE.W		$14(A0),D0	SUB.W		$10(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	RTS	TioAdjust	; ( -- , set limits based on window size )* qwindowsize tio_base_y - line_height / 	BSR			QWINDOWSIZE	MOVE.L		(A6)+,D0	SUB.L		#tio_base_y,D0	DIVU.W		#line_height,D0	ANDI.L		#$FFFF,D0* 1 max max_lines min	LEA		num_lines,A0	MOVE.L		D0,(A0)* tio_base_x - char_width / 2-	MOVE.L		(A6)+,D0	SUB.L		#tio_base_x,D0	DIVU.W		#char_width,D0	ANDI.L		#$FFFF,D0	SUBQ.L		#2,D0* 1 max chars_per_line min	LEA		num_columns,A0	MOVE.L		D0,(A0)* current_col @  num_columns @ 1- min current_col !* current_line @ num_lines @ 1- min current_line !	RTSTIOClearImage ; ( -- )	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)* max_lines chars_per_line *   bl fill	MOVE.L		#max_lines*chars_per_line,-(A6)	MOVE.L		#$20,-(A6)	BSR			F_FILL	RTSTEXT_CLEAR ; ( -- , clear text screen )	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)	_EraseRect	RTS	TIOClearScreen ; ( -- , clear screen )    BSR			TEXT_CLEAR	MOVE.L		#0,current_line	MOVE.L		#0,current_col	RTSTIOCLS ; ( -- )	BSR			TIOClearScreen	BSR			TIOClearImage	RTSTIO_INIT ; ( -- )	BSR			TIOCLS	MOVE.L		#4,-(A6)	BSR			SET_FONT	BSR			TioAdjust	RTSTIO_SCROLL_SCREEN ; ( -- , scroll visible region up by one line )* HMSL-WIndow rect_offset +	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)* 0 line_height negate	MOVE.W		#0,-(A7)	MOVE.L		#line_height,D0	NEG.L		D0	MOVE.W		D0,-(A7)* HMSL-WINDOW UpdateRgn_offset + @	MOVE.L		myWindow,A0	ADDA.L		#UpdateRgn_offset,A0	MOVE.L		(A0),-(A7)	_ScrollRect	MOVE.L		#0,-(A7)	_SetOrigin	RTSTIOScrollImage ; ( -- )* 0 1 ScreenImage 0 0 ScreenImage ( -- source dest )	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)	ADDA.L		#chars_per_line,A0	MOVE.L		A0,-(A6)	BSR			SWAP* num_lines @ chars_per_line * F_CMOVE	MOVE.L		num_lines,D0	MULU.W		#chars_per_line,D0	MOVE.L		D0,-(A6)	BSR			F_CMOVE* 0 num_lines @ ScreenImage chars_per_line bl fill	MOVE.L		#0,-(A6)	MOVE.L		num_lines,D0	MOVE.L		D0,-(A6)	BSR			ScreenImage	MOVE.L		#chars_per_line,-(A6)	MOVE.L		#$20,-(A6)	BSR			F_FILL	RTSTIOMOVE ; ( col row -- )* line_height * tio_base_y +	MOVE.L		(A6)+,D0	MULU.W		#line_height,D0	ADD.L		#tio_base_y,D0* swap char_width * tio_base_x +	MOVE.L		(A6)+,D1	MULU.W		#char_width,D1	ADD.L		#tio_base_x,D1* swap gr.move	MOVE.W		D1,-(A7)	MOVE.W		D0,-(A7)	_MoveTo	RTSTIO_OUTPUT ; ( addr count -- )* dup >r	MOVE.L		(A6),-(A7)*  current_col @ current_line @	MOVE.L		current_col,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIOMove* chars_per_line min   !!!* dup tio_buffer c!	MOVE.L		(A6),D0	LEA			tio_buffer,A0	MOVE.B		D0,(A0)* tio_buffer 1+ swap F_CMOVE	ADDA.L		#1,A0	MOVE.L		A0,-(A6)	BSR			SWAP	BSR			F_CMOVE* tio_buffer gr.text	LEA			tio_buffer,A0	MOVE.L		A0,-(A7)	_DrawString* r> current_col +!	MOVE.L		(A7)+,D0	ADD.L		current_col,D0	MOVE.L		D0,current_col	RTSGOTOXY ; ( col row -- )* current_line ! current_col !	MOVE.L		(A6)+,current_line	MOVE.L		(A6)+,current_col	RTSTIOSAVE ; ( addr count -- , save in screen image )* current_col @ current_line @ ScreenImage	MOVE.L		current_col,-(A6)	MOVE.L		current_line,-(A6)	BSR			ScreenImage* swap F_CMOVE	BSR			SWAP	BSR			F_CMOVE	RTSTIOSAFETYPE ; ( addr count -- , count should not exceed chars_per_line )	PUSH		#chars_per_line	BSR			MIN	BSR			DDUP	BSR			tiosave	BSR			TIO_OUTPUT	RTSTIO_ROOM ; ( -- left , character colums remaining on line )* num_columns @ 1- current_col @ -	MOVE.L		num_columns,D0	SUBQ.L		#1,D0	SUB.L		current_col,D0	MOVE.L		D0,-(A6)	RTSTIO_IMAGE_CR ; ( -- , advance screen image pointer )* current_line @ 1+ num_lines @ >=	MOVE.L		current_line,D0	ADDQ.L		#1,D0	MOVE.L		num_lines,D1	CMP.L		D0,D1	BGE.S		@1	BSR			tioscrollimage@1	RTSTIO_OUTPUT_CR ; ( -- , output CR without saving )* 0 current_col !	MOVE.L		#0,current_col* current_line @ 1+	MOVE.L		current_line,D0	ADDQ.L		#1,D0* dup num_lines @ >=	MOVE.L		num_lines,D1	CMP.L		D0,D1	BGE.S		@1	BSR			tio_scroll_screen	MOVE.L		current_line,D0	BRA.S		@2@1	MOVE.L		D0,current_line		* line_height * tio_base_y + tio_base_x swap gr.move@2	MULU.W		#line_height,D0	ADD.L		#tio_base_y,D0	MOVE.W		#tio_base_x,-(A7)	MOVE.W		D0,-(A7)	_MoveTo	RTSTIO_CR ; ( -- )	BSR			tio_image_cr	BSR			tio_output_cr	RTSTIO_IMAGE_UPDATE ; ( -- , draw from screen image )* D4 = counter* D3 = limit* current_col @ >r current_line @ dup >r 0	_Debugger	MOVEM.L		D3-D4,-(A7)	MOVE.L		current_col,-(A7)	MOVE.L		current_line,-(A7)	BSR		tioclearscreen	MOVE.L		(A7),D3	BLE.S		@2	MOVEQ.L		#0,D4* 0 i screenimage chars_per_line TIO_OUTPUT tio_output_cr@1	MOVE.L		#0,-(A6)	MOVE.L		D4,-(A6)	BSR		ScreenImage	MOVE.L		#chars_per_line,-(A6)	BSR		TIO_OUTPUT	BSR		TIO_Output_CR	ADDQ.L		#1,D4	CMP.L		D4,D3	BNE.S		@1* 0 r> screenimage r> TIO_OUTPUT@2	MOVE.L		#0,-(A6)	MOVE.L		(A7)+,-(A6)	BSR		ScreenImage	MOVE.L		(A7)+,-(A6)	BSR		TIO_OUTPUT	MOVEM.L		(A7)+,D3-D4	RTSTIO_TYPE ; ( addr count -- )* BEGIN	2dup tio_room min dup >r tiosafetype@1	BSR			DDUP	BSR			TIO_ROOM	BSR			MIN	MOVE.L		(A6),-(A7)	BSR			TIOSafeType*    r@ - swap r> + swap  ( -- addr' count' )	MOVE.L		(A7),-(A6)	BSR			MINUS	BSR			SWAP	MOVE.L		(A7)+,-(A6)	BSR			PLUS	BSR			SWAP	MOVE.L		(A6),D0	BLE.S		@2	BSR			tio_cr	BRA.S		@1@2	BSR			DDROP	RTS	* Test Text SystemASTRING		DC.B			'Some more exciting text!'AST			LEA				ASTRING,A0			MOVE.L			A0,-(A6)			RTS				TT			BSR			AST			BSR			COUNT			BSR			TIO_TYPE			RTS			TIOBUF		LEA			Tio_Buffer,A0			PUSH		A0			RTS