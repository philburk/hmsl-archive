* Handle scrolled text I/O in a Mac window using Quickdraw Text** Macintosh Specific** Required words for other systems.*	TIO_TYPE	( addr count -- , output characters at addr )*	TIO_CR		( -- , output a carriage return )*	GOTOXY		( x y -- , move cursor to column x,  row y )*	TIO_CLS		( -- , clear screen )*	TIO_INIT	( -- , initialize system )*	TIO_UPDATE	( -- , update screen if neded )** An image of the output text is kept in a buffer.* Set Port to myWindow before output.** The screen image buffer is called "screen_buffer"********************************************************************** HMSL Forth System                                                 ** Author: Phil Burk                                                 ** Copyright 1989 Phil Burk , All Rights Reserved                    ************************************************************************ MOD: PLB 10/9/90 Put clip to zero in TIO_ROOM* MOD: PLB 10/7/91 Add LINE_DESCENTScreenImage	; ( x y -- addr , calc address in screen image buffer)* 	tio_max_columns * + screen_buffer +	MOVE.L		(A6)+,D0	MULU.W		#tio_max_columns,D0	ADD.L		(A6)+,D0	LEA			screen_buffer,A0	ADDA.L		D0,A0	MOVE.L		A0,-(A6)	RTSQWINDOWSIZE  ; ( -- width height , get size of Forth window)	MOVEQ.L		#0,D0	MOVE.L		myWindow,A0	MOVE.W		$16(A0),D0	SUB.W		$12(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	MOVEQ.L		#0,D0	MOVE.W		$14(A0),D0	SUB.W		$10(A0),D0	EXT.L		D0	MOVE.L		D0,-(A6)	RTSTIO_Adjust_Font	; ( -- , set char_width and height based on current font )* Use SCRATCH RECTANGLE for convenience	PEA			ScratchRect	_GetFontInfo	CLR.L		D0	LEA			ScratchRect,A0	MOVE.W		$0(A0),D0	ADD.W		$2(A0),D0	ADD.W		$6(A0),D0	MOVE.L		D0,line_height	MOVE.W		$2(A0),D0	MOVE.L		D0,line_descent** get character width from this instead of font info	MOVE.W		#0,-(A7)			; room for return parameter	MOVE.W		#$20,-(A7)			; blank char	_CharWidth	CLR.L		D0	MOVE.W		(A7)+,D0	MOVE.L		D0,char_width	RTSTio_Adjust_Window	; ( -- , set limits based on window size )* Calculate how many lines can be displayed.* qwindowsize tio_base_y - line_height / 	BSR			QWINDOWSIZE	MOVE.L		(A6)+,D0	SUB.L		#tio_base_y,D0	MOVE.L		line_height,D1	DIVU.W		D1,D0	ANDI.L		#$FFFF,D0	SUBQ.L		#1,D0* Set tio_num_rows* 1 max tio_max_rows min	MOVE.L		D0,tio_num_rows* Calculate how many columns can be displayed.* tio_base_x - char_width / 2-	MOVE.L		(A6)+,D0	SUB.L		#tio_base_x,D0	MOVE.L		char_width,D1	DIVU.W		D1,D0	ANDI.L		#$FFFF,D0	SUBQ.L		#2,D0* 1 max tio_max_columns min	CMP.L		#tio_max_columns,D0	BLT			@1	MOVE.L		#tio_max_columns,D0@1	MOVE.L		D0,tio_num_columns** FV_OUT @  tio_num_columns @ 1- min FV_OUT !	move.l		fv_out,d1	subq.l		#1,d0				; tio_num_columns-1	cmp.l		d0,d1	ble			@2	move.l		d0,d1				; set fv_out to tio_num_cols-1	move.l		d1,fv_out** current_line @ tio_num_rows @ min current_line !@2	move.l		current_line,d1	move.l		tio_num_rows,d0	sub.l		d0,d1	ble			@3	move.l		d0,current_line			; set current_line to tio_num_rows-1	push		d1	bsr			tio_scroll_buffer@3	RTS	TIO_Adjust	; ( -- , do all necessary adjustments )	BSR			TIO_Adjust_Font	BSR			TIO_Adjust_Window	RTS	TIO_Clear_Image ; ( -- )	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)* tio_max_rows tio_max_columns *   bl fill	MOVE.L		#tio_max_rows*tio_max_columns,-(A6)	MOVE.L		#$20,-(A6)	BSR			F_FILL	RTSTEXT_CLEAR ; ( -- , clear text screen )	MOVE.L		myWindow,-(A7)	_SetPort	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)	_EraseRect					; TRAP	RTS	TIO_COLROW2XY  ; ( col row -- x  y , calculate pixel position for text )* line_height * tio_base_y +	MOVE.L		(A6)+,D0	MOVE.L		line_height,D1	MULU.W		D1,D0	ADD.L		#tio_base_y,D0	MOVE.L		D0,-(A7)* swap char_width * tio_base_x +	MOVE.L		(A6)+,D1	MOVE.L		char_width,D0	MULU.W		D0,D1	ADD.L		#tio_base_x,D1	PUSH		D1	PUSH		(A7)+	RTS	TIO_CurRect  ; ( -- rect_addr, rectangle that covers current character position )	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIO_COLROW2XY*	POP			D0				y pos	MOVE.L		line_descent,D1	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.bottom	MOVE.L		line_height,D1	SUB.W		D1,D0	MOVE.W		D0,ScratchRect.top*	POP			D0				x pos	MOVE.W		D0,ScratchRect.left	MOVE.L		char_width,D1	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.right	LEA			ScratchRect,A0	PUSH		A0	RTSTOGGLE_CURSOR  ; ( -- )	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIO_CurRect	MOVE.L		(A6)+,-(A7)    _InverRect					; TRAP	RTS	TIO_CURSOR_ON  ; ( -- )		MOVE.L		CursorState,D0		BNE.S		@done		BSR			TOGGLE_CURSOR		MOVE.L		#-1,CursorState@done	RTS				TIO_CURSOR_OFF	; ( -- )		MOVE.L		CursorState,D0		BEQ.S		@done		BSR			TOGGLE_CURSOR		CLR.L		CursorState@done	RTS		TIO_UPDATE_CURSOR	; ( Turn on cursor if it should be on )		TST.L		CursorState		BEQ			@1			BSR			TOGGLE_CURSOR@1		RTSTIO_BLANK   ; ( -- , blank one character position )* Clear rectangle on display.	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIO_CurRect	MOVE.L		(A6)+,-(A7)    _EraseRect							; clear place on screen TRAP* set screen image to BL at this position	PUSH		#$20	PUSH		FV_OUT	PUSH		current_line	BSR			ScreenImage	BSR			CSTORE	ADD.L		#1,FV_OUT	RTS	TIO_Clear_Screen ; ( -- , clear screen )    BSR			TEXT_CLEAR	MOVE.L		#0,current_line	MOVE.L		#0,FV_OUT	RTSTIO_CLS ; ( -- )	BSR			TIO_Clear_Screen	BSR			TIO_Clear_Image	BSR			TIO_UPDATE_CURSOR	RTSTIO_INIT ; ( -- )	LEA			TIO_UPDATE,A0	MOVE.L		A0,FV_UPDATE_FUNC	; set update vector	BSR			TIO_CLS	MOVE.W		#4,-(A7)			; Monaco	_TextFont	MOVE.W		#9,-(A7)			; size 9	_TextSize	BSR			TIO_Adjust	RTSTIO_SCROLL_SCREEN ; ( -- , graphically scroll visible region up by one line )* HMSL-Window rect_offset +	MOVE.L		myWIndow,A0	ADDA.L		#rect_offset,A0	MOVE.L		A0,-(A7)* 0 line_height @ negate	MOVE.W		#0,-(A7)	MOVE.L		line_height,D0	NEG.L		D0	MOVE.W		D0,-(A7)* HMSL-WINDOW UpdateRgn_offset + @	MOVE.L		myWindow,A0	ADDA.L		#UpdateRgn_offset,A0	MOVE.L		(A0),-(A7)	_ScrollRect							; TRAP	MOVE.L		#0,-(A7)	_SetOrigin	RTSTIO_Scroll_Buffer ; ( N -- , scroll N lines in buffer )	MOVE.L		(A6)+,-(A7)			; keep N on return stack	LEA			screen_buffer,A0	MOVE.L		A0,-(A6)	MOVE.L		#tio_max_columns,D0	MOVE.L		(A7),D1	MULU.W		D1,D0	ADDA.L		D0,A0	MOVE.L		A0,-(A6)	BSR			SWAP			;  source dest* tio_num_rows @ N - chars_per_line * F_CMOVE	MOVE.L		tio_num_rows,D0	MULU.W		#tio_max_columns,D0	PUSH		D0	BSR			F_CMOVE* 0 tio_num_rows @ ScreenImage tio_max_columns bl fill  ; clear bottom lines	MOVE.L		#0,-(A6)	MOVE.L		tio_num_rows,D0	PUSH		D0	BSR			ScreenImage				; -- start of blanked area	MOVE.L		#tio_max_columns,D0	MOVE.L		(A7)+,D1	MULU.W		D1,D0	PUSH		D0	PUSH		#$20	BSR			F_FILL	RTS	TIOMOVE ; ( col row -- , move cursor to new position )	BSR			TIO_COLROW2XY	POP			D0	POP			D1	MOVE.W		D1,-(A7)	MOVE.W		D0,-(A7)	_MoveTo					; TRAP	RTSTIO_OUTPUT ; ( addr count -- , draw on screen)	MOVE.L		myWindow,-(A7)	_SetPort* dup >r	MOVE.L		(A6),-(A7)*  FV_OUT @ current_line @     ; move to proper position	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIOMove* tio_max_columns min   !!!     ; save in temporary buffer for Mac Call _DrawString* dup tio_buffer c!	MOVE.L		(A6),D0	LEA			tio_buffer,A0	MOVE.B		D0,(A0)* tio_buffer 1+ swap F_CMOVE	ADDA.L		#1,A0	MOVE.L		A0,-(A6)	BSR			SWAP	BSR			F_CMOVE* tio_buffer gr.text	LEA			tio_buffer,A0	MOVE.L		A0,-(A7)	_DrawString							; TRAP* r> FV_OUT +!	MOVE.L		(A7)+,D0	ADD.L		FV_OUT,D0	MOVE.L		D0,FV_OUT	RTSGOTOXY ; ( col row -- )* current_line ! FV_OUT !	POP			current_line	POP			FV_OUT	RTSTIO_SAVE ; ( addr count -- , save in screen image )* FV_OUT @ current_line @ ScreenImage	MOVE.L		FV_OUT,-(A6)	MOVE.L		current_line,-(A6)	BSR			ScreenImage			; address to save to* swap F_CMOVE	BSR			SWAP	BSR			F_CMOVE	RTSTIO_SAVETYPE ; ( addr count -- , )	BSR			DDUP	BSR			TIO_SAVE	BSR			TIO_OUTPUT	RTSTIO_ROOM ; ( -- left , character columns remaining on line )* tio_num_columns @ 1- FV_OUT @ -		MOVE.L		tio_num_columns,D0		SUBQ.L		#1,D0		SUB.L		FV_OUT,D0		BGE.S		@ok		CLR.L		D0			; clip to zero@ok		MOVE.L		D0,-(A6)		RTSTIO_BUFFER_CR ; ( -- , advance screen buffer pointer to next line )* current_line @ 1+ tio_num_rows @ >=	MOVE.L		current_line,D0	ADDQ.L		#1,D0	MOVE.L		tio_num_rows,D1	CMP.L		D0,D1	BGE.S		@1	PUSH		#1	BSR			tio_scroll_buffer@1	RTSTIO_OUTPUT_CR ; ( -- , output CR without saving , scroll if necessary )	MOVE.L		myWindow,-(A7)	_SetPort* 0 FV_OUT !	MOVE.L		#0,FV_OUT* current_line @ 1+     ;  Increment line number	MOVE.L		current_line,D0	ADDQ.L		#1,D0** dup tio_num_rows @ >=   ; Check to see if at last line.	MOVE.L		tio_num_rows,D1	CMP.L		D0,D1	BGE.S		@1	BSR			tio_scroll_screen     ;  scroll screen graphics if past	MOVE.L		current_line,D0	BRA.S		@2@1	MOVE.L		D0,current_line* position cursor at current position* line_height @ * tio_base_y + tio_base_x swap gr.move@2	MOVE.L		line_height,D1	MULU.W		D1,D0	ADD.L		#tio_base_y,D0	MOVE.W		#tio_base_x,-(A7)	MOVE.W		D0,-(A7)	_MoveTo							; TRAP	RTSTIO_CR ; ( -- )		BSR			tio_buffer_cr		BSR			tio_output_cr		RTSTIOCurLineRect  ; ( -- rect_addr, rectangle that covers current line )	MOVE.L		#0,-(A6)	MOVE.L		current_line,-(A6)	BSR			TIO_COLROW2XY*	POP			D0				y pos	MOVE.L		line_descent,D1	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.bottom	MOVE.L		line_height,D1	SUB.W		D1,D0	MOVE.W		D0,ScratchRect.top*	MOVE.L		char_width,D0	MOVE.L		tio_num_columns,D1	MULU.W		D1,D0	POP			D1				x pos	MOVE.W		D1,ScratchRect.left	ADD.W		D1,D0	MOVE.W		D0,ScratchRect.right	LEA			ScratchRect,A0	PUSH		A0	RTSTIO_CLEAR_LINE   ; ( -- , blank current line )	MOVE.L		myWindow,-(A7)	_SetPort	BSR			TIOCurLineRect	MOVE.L		(A6)+,-(A7)    _EraseRect							; TRAP	RTS	TIO_UPDATE_LINE ; ( -- , draw current line from screen buffer )		MOVE.L		FV_OUT,-(A7)			; keep OUT safe		BSR			TIO_CLEAR_LINE*		PUSH		#0		PUSH		current_line		BSR			ScreenImage		MOVE.L		tio_num_columns,-(A6)		MOVE.L		#0,FV_OUT		BSR			TIO_OUTPUT		MOVE.L		(A7)+,FV_OUT			; restore OUT		RTSTIO_UPDATE ; ( -- , draw from screen buffer )* D4 = counter* D3 = limit		MOVEM.L		D3-D4,-(A7)		MOVE.L		myWindow,-(A7)		_SetPort		BSR			Tio_Adjust			figure out new sizes		MOVE.L		FV_OUT,-(A7)		save variables from getting cleared by CLS		MOVE.L		current_line,-(A7)		BSR			TIO_Clear_Screen*		MOVE.L		(A7),D3				current_line -> D3		BLE.S		@2		MOVE.L		D3,D4		SUB.L		tio_num_rows,D4		don't display more than can fit on screen		BGE			@1		MOVEQ.L		#0,D4				start at no less then line 0*@1		MOVE.L		#0,-(A6)			loop out lines		MOVE.L		D4,-(A6)		BSR			ScreenImage		MOVE.L		tio_num_columns,-(A6)		BSR			TIO_OUTPUT		BSR			TIO_Output_CR		ADDQ.L		#1,D4		CMP.L		D4,D3		BNE.S		@1*@2		MOVE.L		#0,-(A6)			last line		MOVE.L		(A7)+,-(A6)		BSR			ScreenImage		MOVE.L		(A7)+,-(A6)		BSR			TIO_OUTPUT		BSR			TIO_UPDATE_CURSOR@3		MOVEM.L		(A7)+,D3-D4		RTSTIO_TYPE ; ( addr count -- )* BEGIN	2dup tio_room min dup >r tiosafetype@1		BSR			DDUP		BSR			TIO_ROOM		; type as much as will fit on line		BSR			MIN		MOVE.L		(A6),-(A7)		BSR			TIO_SaveType*    r@ - swap r> + swap  ( -- addr' count' )   ; calc how much left		MOVE.L		(A7),-(A6)		BSR			MINUS		BSR			SWAP		MOVE.L		(A7)+,-(A6)		BSR			PLUS		BSR			SWAP		MOVE.L		(A6),D0		BLE.S		@2		BSR			tio_cr		BRA.S		@1				; print any left on next line@2		BSR			DDROP		RTSTIO_BACKWARDS	; ( N -- , move cursor backwards )		MOVE.L		FV_OUT,D0		POP			D1		SUB.L		D1,D0		decrement 		BGE.S		@1		CLR.L		D0			clip to zero@1		MOVE.L		D0,FV_OUT		RTSTIO_FORWARDS	; ( N -- , move cursor forwards )		POP			D1		ADD.L		D1,FV_OUT		increment 		RTSTIO_ERASE_EOL	; ( -- , erase from current position to end of line )		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr )		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage		BSR			OVER		BSR			MINUS		( -- addr count )		PUSH		#$20		; BLank		BSR			F_FILL		BSR			TIO_UPDATE_LINE		RTSTIO_DELETE		; ( N -- , delete N chars from under cursor )		PUSH		FV_OUT		BSR			PLUS		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr0 )		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- addr0 addr1 )		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage		BSR			OVER		BSR			MINUS		( -- addr0 addr1 count )		BSR			F_CMOVE		BSR			TIO_UPDATE_LINE		RTSTIO_INSERT		; ( N -- , make room for N characters )		PUSH		(A6)		; DUP		PUSH		FV_OUT		BSR			PLUS		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrd )			char under cursor		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrd addrs )	char to move up to		BSR			SWAP		PUSH		#0		MOVE.L		CURRENT_LINE,D0		ADDQ.L		#1,D0		PUSH		D0		BSR			ScreenImage					char at beginning of next line		BSR			OVER		BSR			MINUS		( -- N addrs addrd count )		BSR			F_CMOVEB					move chars up		PUSH		FV_OUT		PUSH		CURRENT_LINE		BSR			ScreenImage  ( -- N addrs )		BSR			SWAP		PUSH		#$20		BSR			F_FILL						fill in with blanks		BSR			TIO_UPDATE_LINE		RTS* Test Text SystemASTRING		DC.B			'Some more exciting text!'AST			LEA				ASTRING,A0			MOVE.L			A0,-(A6)			RTS				TT			BSR			AST			BSR			COUNT			BSR			TIO_TYPE			RTS			TIOBUF		LEA			Tio_Buffer,A0			PUSH		A0			RTS