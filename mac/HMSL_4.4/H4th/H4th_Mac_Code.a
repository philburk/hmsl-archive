* Macintosh Specific Code for HMSL Forth*********************************************************************** HMSL Forth System                                                 ** Author: Phil Burk                                                 ** Copyright 1989 Phil Burk , All Rights Reserved                    *****************************************************************************************************************************************************   Main Segment, System Interface, Loader, FileIO.				SEG 			'Main'				TITLE			'HMSL4th - Main Program'************************************************ Sample Main Program - Execution starts here ************************************************* This is another code module.	It is declared as the main code module which* means execution will start here.; ------------------------- Top Level of H4th -----------------------MACCODE			MAIN				WITH			QuickDraw,GlobalData,H4thData  Cover our data areas				IMPORT			RUN_4TH				IMPORT			SEG_STR_FOPEN, SEG_CLOSEFILE, SEG_FREAD				IMPORT			EventsInit; This is the primary entry point from the Mac OSHMSLForth		JSR				InitHostSys			Initialize Host.				LEA				TopTempStack,A6		setup temp data stack				JSR				LOAD_H4th			trys to load from data fork*													Set D0 to zero if loaded OK.				TST.L			D0					Check for data fork load.				BNE				@rsrc_load				MOVE.L			FV_CODE_PTR,A0		get start of dictionary from loader				JSR				(A0)				call dictionary, do FORTH				JSR				UNLOAD_H4TH			Deallocate Code when done				RTS				@rsrc_load		JSR				RUN_4TH				Enter Forth by calling RSRC segment.				RTS; -------------------------------------------------------------------				MACRO				DRAWMSG			&xpos, &ypos, &str				MOVE.L			myWindow,-(A7)				_SetPort		;				Set current grafPort to this window				MOVE.W			&xpos,-(A7)				MOVE.W			&ypos,-(A7)				_MoveTo				PEA				&str				_DrawString				ENDM				InitHostSys		PEA 			thePort 		Initialize QuickDraw				_InitGraf				_InitFonts		;				Initialize Font Manager				MOVE.L			#$0000FFFF,D0	Discard any previous events				_FlushEvents	;				FlushEvents(EventEvent, 0);				_InitWindows	;				Initialize Window Manager				_InitMenus		;				Initialize Menu Manager				_TEInit 		;				Initialize TextEdit				CLR.L			-(A7)			Initialize Dialog Manager				_InitDialogs	;				InitDialogs(NIL);				_InitCursor 	;				Make cursor an arrow				JSR 			SetUpMenus		Set up menus and menu bar				PEA 			SetUpMenus		Unload the SetUpMenus segment				_UnLoadSeg		;				Since we will never call it again				WITH			screenBits.bounds				PEA 			dragRect		Call QuickDraw to set dragging				MOVE			#4,-(A7)		boundaries; ensure at least				MOVE			#24,-(A7)		4 by 4 pixels will remain visible				MOVE			right,D0				SUBQ			#4,D0				MOVE			D0,-(A7)				MOVE			bottom,D0				SUBQ			#4,D0				MOVE			D0,-(A7)				_SetRect		;				SetRect(dragRect, 4, 24,				ENDWITH 		;					right-4, bottom-4);				CLR.B			doneFlag		Flag to detect Quit command				SUBQ			#4,A7			Put up application window				MOVE			#windowID,-(A7)				PEA 			wRecord;				MOVE.L			#-1,-(A7)				MOVE.L			#-1,NegativeOne				PEA 			NegativeOne				_GetNewWindow	;				myWindow := GetNewWindow(windowID,				MOVE.L			(A7)+,myWindow		 @wRecord, Ptr(-1));								* Initialize Event Handling				JSR				EventsInit				EJECT				RTS******************************************* SetUpMenus - Set up menus and menu bar *******************************************SetUpMenus		SUBQ			#4,A7			Read Apple menu from resource				MOVE			#appleID,-(A7)		file				_GetRMenu		;				appleMenuH := GetMenu(appleID);				MOVE.L			(A7),appleMenuH Leave extra copy of handle on				MOVE.L			(A7),-(A7)			stack for _AddResMenu				CLR 			-(A7)			Install Apple menu in menu bar				_InsertMenu 	;				InsertMenu(appleMenuH, 0);				MOVE.L			#'DRVR',-(A7)	Add DA names to Apple menu				_AddResMenu 	;				AddResMenu(appleMenuH, 'DRVR');				SUBQ			#4,A7			Read File menu from resource				MOVE			#fileID,-(A7)		file				_GetRMenu		;				fileMenuH := GetMenu(fileID);				MOVE.L			(A7),fileMenuH				CLR 			-(A7)			Install File menu in menu bar				_InsertMenu 	;				InsertMenu(fileMenuH, 0);				SUBQ			#4,A7			Read Edit menu from resource				MOVE			#editID,-(A7)		file				_GetRMenu		;				editMenuH := GetMenu(editID);				MOVE.L			(A7),editMenuH				CLR 			-(A7)			Install Edit menu in menu bar				_InsertMenu 	;				InsertMenu(editMenuH, 0);								SUBQ			#4,A7			Read Include menu from resource				MOVE			#includeID,-(A7)		file				_GetRMenu		;				editMenuH := GetMenu(ID);				MOVE.L			(A7),inclMenuH				CLR 			-(A7)			Install menu in menu bar				_InsertMenu 	;				InsertMenu(editMenuH, 0);				*				SUBQ			#4,A7			Read Window menu from resource*				MOVE			#windMenuID,-(A7)		file*				_GetRMenu		;				editMenuH := GetMenu(ID);*				MOVE.L			(A7),windMenuH*				CLR 			-(A7)			Install menu in menu bar*				_InsertMenu 	;				InsertMenu(editMenuH, 0);								_DrawMenuBar	;				Draw the menu bar				CLR.L			InclMenuHit				RTS 							Exit	* Load from Data Fork -----------------------------------------LD_OPEN		; ( -- refnum | NULL , open data fork )				PUSH			#CurApName				JSR				SEG_STR_FOPEN				RTSLD_CLOSE	;	( -- , read number from file)				PUSH			FV_SPARE				JSR				SEG_CLOSEFILE				RTS				LD_READ_NUM	;	( -- n , read number from file)				PUSH			FV_SPARE				LEA				FV_ECHO,A0				PUSH			A0				PUSH			#4				JSR				SEG_FREAD				POP				D0				PUSH			FV_ECHO				RTSUNLOAD_H4TH		; ( -- , unload allocated H4th )				MOVE.L			FV_CODE_PTR,D0				BEQ				@1				MOVE.L			D0,A0				_DisposPtr				CLR.L			FV_CODE_PTR*@1				MOVE.L			FV_HEADERS_PTR,D0				BEQ				@2				MOVE.L			D0,A0				_DisposPtr				CLR.L			FV_HEADERS_PTR*@2				RTSLD_STAT		; ( -- error , load HDRS chunk )				BSR				LD_READ_NUM				Get Chunk Type				POP				D0				CMP.L			#'STAT',D0				Is it a 'HDRS' type?				BNE				@bad_image				BSR				LD_READ_NUM				Get size of chunk.				POP				FV_CHUNK_SIZE*				BSR				LD_READ_NUM				Get size to allocate for memory.				POP				FV_CODE_SIZE*				BSR				LD_READ_NUM				Get Here, Relocatable				POP				FV_DP					must relocate later*				BSR				LD_READ_NUM				Get size to allocate for memory.				POP				FV_HEADERS_SIZE*				BSR				LD_READ_NUM				Get current, Relocatable				POP				FV_CURRENT				PUSH			#0				RTS@bad_image		PUSH			#1				RTS				LD_DICT		; ( -- error , load DICT chunk )				BSR				LD_READ_NUM				Get Chunk Type				POP				D0				CMP.L			#'DICT',D0				Is it a 'DICT' type?				BNE				@bad_image				BSR				LD_READ_NUM				Get size of chunk.				POP				FV_CHUNK_SIZE** Load code into allocated memory				MOVE.L			FV_CODE_SIZE,D0				_NewPtr									; Allocate mem for Code				MOVE.L			A0,FV_CODE_PTR			save pointer				MOVE.L			A0,D0				BEQ				@bad_alloc				test allocation				PUSH			FV_SPARE				fileid				PUSH			A0						addr				PUSH			FV_CHUNK_SIZE			count				JSR				SEG_FREAD				read				POP				D0				CMP.L			FV_CHUNK_SIZE,D0		check bytes read				BNE				@bad_read				PUSH			#0				RTS@bad_image		PUSH			#1				RTS@bad_alloc		PUSH			#2				RTS@bad_read		PUSH			#3				RTSLD_HDRS		; ( -- error , load HDRS chunk )				BSR				LD_READ_NUM				Get Chunk Type				POP				D0				CMP.L			#'HDRS',D0				Is it a 'HDRS' type?				BNE				@bad_image				BSR				LD_READ_NUM				Get size of chunk.				POP				FV_CHUNK_SIZE** Load headers into allocated memory				MOVE.L			FV_HEADERS_SIZE,D0				_NewPtr									; Allocate mem for Code				MOVE.L			A0,FV_HEADERS_PTR		save pointer				MOVE.L			A0,D0				BEQ				@bad_alloc				test allocation				PUSH			FV_SPARE				fileid				PUSH			A0						addr				PUSH			FV_CHUNK_SIZE			count				JSR				SEG_FREAD				read				POP				D0				CMP.L			FV_CHUNK_SIZE,D0		check bytes read				BNE				@bad_read				PUSH			#0				RTS@bad_image		PUSH			#1				RTS@bad_alloc		PUSH			#2				RTS@bad_read		PUSH			#3				RTSWAIT_MESSAGE	DC.B			'Loading HForth Dictionary. Please wait...'LOAD_H4TH		; ( --- )				DRAWMSG			#40,#40,WAIT_MESSAGE				MOVE.L			#0,loadStatus				CLR.L			FV_CODE_PTR			; clear memory pointers				CLR.L			FV_HEADERS_PTR*				BSR				LD_OPEN					open self data fork				POP				D0				BEQ				@no_open				MOVE.L			#1,loadStatus				MOVE.L			D0,FV_SPARE				BSR				LD_READ_NUM				read FORM tag				POP				D0				CMP.L			#'FORM',D0				Is it an IFF FORM?				BNE				@not_image								MOVE.L			#2,loadStatus				BSR				LD_READ_NUM				get size				POP				D0				BSR				LD_READ_NUM				POP				D0				CMP.L			#'FRTH',D0				Is it a 'FRTH' type?				BNE				@not_image** Load three chunks				MOVE.L			#3,loadStatus				BSR				LD_STAT					load statistics on dictionary				POP				D0				BNE				@bad_load								MOVE.L			#4,loadStatus				BSR				LD_DICT					load actual dictionary				POP				D0				BNE				@bad_load								MOVE.L			#5,loadStatus				MOVE.L			FV_HEADERS_SIZE,D0		don't load headers if turnkeyed				BEQ				@fixvars				BSR				LD_HDRS				POP				D0				BNE				@bad_load* Fix system variables.@fixvars		MOVE.L			#6,loadStatus				MOVE.L			FV_CODE_SIZE,D0			set limits				ADD.L			FV_CODE_PTR,D0				SUB.L			#32,D0					allow for underflow				MOVE.L			D0,FV_CODE_LIMIT				MOVE.L			D0,FV_S_ZERO** Set up headers if any.				MOVE.L			FV_HEADERS_SIZE,D0				BEQ				@noheaders				ADD.L			FV_HEADERS_PTR,D0				MOVE.L			D0,FV_HEADERS_LIMIT*				MOVE.L			FV_HEADERS_PTR,D0				MOVE.L			D0,FV_HDRSBASE				ADD.L			FV_CURRENT,D0			relocate CURRENT				MOVE.L			D0,FV_CONTEXT				MOVE.L			D0,FV_CURRENT				MOVE.L			D0,A0				CLR.L			D0				MOVE.B			(A0),D0					get count byte of top word				ADDQ.L			#2,D0					evenup count, include count byte				ANDI.L			#-2,D0				ADD.L			D0,A0				MOVE.L			A0,FV_NEXTLINK*@noheaders		MOVE.L			FV_CODE_PTR,D0				ADD.L			D0,FV_DP				relocate DP*				MOVE.L			FV_CODE_PTR,BASE_REG	load relocation register				MOVE.L			A4,HIBASE_REG				ADD.L			#$10000,HIBASE_REG		load high relocation base+64K								BSR				LD_CLOSE				MOVEQ.L			#0,D0					return noErr				MOVE.L			#7,loadStatus				RTS*@bad_load		BSR				UNLOAD_H4TH@not_image		BSR				LD_CLOSE@no_open		MOVEQ.L			#1,D0				RTS				ENDP								include			'fileio.a'								TITLE			'ShowAboutMeDialog - Display the "About"...'*********************************************** ShowAboutMeDialog - Display the "About"... ************************************************ This procedure is called from DoCommand when item #1 is selected from the* apple menu list.	It sets up a dialog box indicating the author and language* of this sample program.  The box remains until the user clicks the mouse on* the continue button.				ShowAboutMeDialog PROCStackFrame		RECORD			{A6Link},DECR	Stack frame for some localsRetAddr 		DS.L			1				Return addressA6Link			DS.L			1				Caller's A6savePort		DS.L			1				Port at the time of callitemType		DS.W			1				Returned by _GetDItem (not used)itemHdl 		DS.L			1				Handle to the itemitemRect		DS.W			Rect			Returned by _GetDItem (not used)itemHit 		DS.W			1				Part codeLocalSize		EQU 			*				Size of the local stack frame				ENDRtheDialog		EQU 			A3				Dialog pointer				WITH			StackFrame		Cover our local stack frame** Start here: create new stack frame, save regs, current grafPort, and allocate* space for the dialog box*				LINK			A6,#LocalSize	Allocate our local stack frame				MOVE.L			A3,-(A7)		We need another register here				PEA 			savePort(A6)	Remember the current grafPort				_GetPort		;				across this routine				SUBQ.W			#4,A7			Create a new dialog				MOVE.W			#aboutMeDLOG,-(A7) Dialog is defined as a resource				CLR.L			-(A7)			Dialog mgr will allocate space				PEA 			-1				Dialog box will be top window				_GetNewDialog				MOVE.L			(A7),theDialog	theDialog holds ptr to dialog info				_SetPort		;				Set the current grafPort** Wait for user to click the continue button*WaitForOk		CLR.L			-(A7)			Wait for the click...				PEA 			itemHit(A6)				_ModalDialog				CMPI.W			#okButton,itemHit(A6)				BNE.S			WaitForOk		Loop until continue clicked** User is now satisfied -- let's get out of here!*				MOVE.L			A3,-(A7)		Close the dialog box				_CloseDialog				MOVE.L			savePort(A6),-(A7)				_SetPort		;				Put original grafPort back				MOVE.L			(A7)+,theDialog Restore the saved register				UNLK			A6				Unlink our local stack frame				RTS 							Exit				ENDP* A small macro definition to illustrate some of the macro processor's power.* In the code we need to do "case" statements to process the Edit menu items,* the main event loop event cases, and the mouse down event cases. The following* macro is used to generate a branch based on an index value in a D-register.* The branch is through a table of relative addresses also generated by this* macro.  The macro is called in one of two forms as follows:*  {Form #1}	Case#			(Dreg,Default),case0,case1,...caseN*  {Form #2}	Case#.<size>	(Dreg,IF),(cst0,case0),...,(cstN,caseN)* The "Dreg" is a D-register with a value from 0 to N.	In Form #1, the* "Default" specifies a label for any omitted case labels not specified* explicitly. The "case0", "case1",..."caseN" are case labels identifying the* various cases to be processed.  A case label may be omitted, in which case* the "Default" is used. The "Default" may also be omitted, but in that case all* case labels must be specified. If there are fewer case labels than there are* cases, but there are N possible values for the case index, the proper number* of trailing commas must be supplied to generate the defaults.* In Form #2, the default is specified as the word "IF".  In this form the macro* generates a set of compares (CMPI's) and branches (BEQ) for each specified* case (there is no implicit default).	Each case is a constant/label pair.* The constant is compared (CMPI.W) and an branch is done (BEQ) to the case if* the Dreg equals the constant.  A size may be specified for all the branches* as a <size> attribute to the Case# call itself.  This must either be an "S"* or "W" to generate BEQ.S's or BEQ.W's.  The default is for "S".				MACRO				Case#.&Size 	&IdxDef				PRINT			Push,NoMDir 	Only list generated code				LCLA			&i				Index to macro parameters				LCLA			&n				Total number of macro parameters				LCLC			&Dreg,&Def		The Dreg and Default parameters				LCLC			&sz 			The <size> value.*&Dreg			SETC			&IdxDef[1]		Pick off 1st opnd of sublist&Def			SETC			&IdxDef[2]		Pick off 2nd opnd of sublist&n				SETA			&Nbr(&Syslist)	Done for efficiency&i				SETA			2				Cases start at 2nd parameter.*	  IF &UpCase(&Def) <> 'IF' THEN.*				ADD 			&Dreg,&Dreg				MOVE			Case&SysNdx(&Dreg),&Dreg				JMP 			Case&SysNdx(&Dreg)Case&SysNdx.*		WHILE &i <= &n DO		Process each case label		  IF &SysList[&i] <> '' THEN.*				DC.W			&SysList[&i]-Case&SysNdx.*		  ELSE.*				DC.W			&Def-Case&SysNdx.*		  ENDIF		  &i: SETA &i+1 		Count off parameter		ENDWHILE	  ELSE						Process (Cst,lbl) pairs		&Sz: SETC &Default(&Size, 'S') Setup size attribute		WHILE &i <= &n DO		Process each (Cst,lbl) pair.*				CMPI			#&SysList[&i,1],&Dreg				BEQ.&Sz 		&SysList[&i,2].*		&i: SETA &i+1			Count off parameter		ENDWHILE	  ENDIF.*				PRINT			Pop 			Restore original print status				ENDM***************************************************************************************				TITLE			'Event Handler'				SEG				'EventHandler'				EventCode		PROC				WITH			QuickDraw,GlobalData,H4thData				IMPORT			ShowAboutMeDialog, GET_INCLUDE, RE_INCLUDE				ENTRY			CheckEvents, EventsInit				CheckEvents		MOVE.L			A2,-(A7)		Save A2 for local vars				;				_SystemTask		; 				keep DAs alive				SUBQ			#2,A7			Call ToolBox Event Manager to get				MOVE			#everyEvent,-(A7)	the next event that the				PEA 			myEvent 			application should handle				_GetNextEvent	;				GetNextEvent(everyEvent, myEvent);				MOVE.W			(A7)+,D0				BNE.S			@RealEvent		process any real events; distinguish between NULL events and System handled events; pass NULL events to window for cursor flashing				MOVE			myEvent.what,D0 	Fetch the event number				BEQ.S			ToCurrentW				BRA				MainEventExit; broker some special events@RealEvent		MOVE			myEvent.what,D0 Fetch the event number				Case#			(D0,MainEventExit), \									ToCurrentW,	\	  0: Null									BrokerDown,	\	  1: Mouse down									ToCurrentW,	\	  2: Mouse up									BrokerKey,	\	  3: Key down									ToCurrentW,	\	  4: Key up									BrokerKey,	\	  5: Auto key									BrokerUpdate, 	\	  6: Update									,			\	  7: Disk inserted (not used)									BrokerActivate,	\	  8: Activate									ToCurrentW,		\									ToCurrentW,		\									ToCurrentW,		\									ToCurrentW,		\									ToCurrentW,		\									ToCurrentW,		;  9-15: (not used)				MainEventExit	MOVE.L			(A7)+,A2				RTSToCurrentW	; ( send event to current window event handler )				MOVE.L			CurWindowTr,D0				BEQ				MainEventExit				MOVEA.L			D0,A0				MOVEA.L			(A0),A1	; get EVHandler				JSR				(A1)	; call windows event handler				BRA				MainEventExitBrokerUpdate				MOVEA.L			myEvent.message,A1				MOVE.L			wRefCon(A1),D0	; get Window Tracker Structure				BEQ				MainEventExit				MOVEA.L			D0,A0				MOVEA.L			(A0),A1				JSR				(A1)			; call windows event handler				BRA				MainEventExitBrokerActivate		; if new window activated, set window tracker				CLR.L			CurWindowTr		; clear old current				MOVE			myEvent.modifiers,D0 	App window status changed				BTST			#activeFlag,D0			Is window becoming active ?				BEQ.S			BrokerUpdate			No, some other window is				MOVEA.L			myEvent.message,A1	; get window				MOVE.L			wRefCon(A1),D0	; get Window Tracker Structure				BEQ				MainEventExit				MOVE.L			D0,CurWindowTr	; make this current window				MOVEA.L			D0,A0				MOVEA.L			(A0),A1				JSR				(A1)			; call windows event handler				BRA				MainEventExit				BrokerDown		SUBQ			#2,A7			Mouse button down:				MOVE.L			myEvent.where,-(A7) Call Window Manager to learn				PEA 			whichWindow 		where				_FindWindow 	;				FindWindow(myEvent.where, whichWindow);				CLR.L			D0				MOVE.W			(A7)+,D0		; get mousedown code				CMP.W			#inContent,D0	; is it window specific				BGE				@inwind				CMP.W			#inSysWindow,D0	;				BEQ				SysWIndow				CMP.W			#inMenuBar,D0	;				BEQ				HandleMenu				BRA				MainEventExit	; no response to inDesk@inwind			MOVE.L			D0,whichPart	; call window's MouseDown Handler				MOVE.L			whichWindow,A1	; get Mac window Pointer				MOVE.L			wRefCon(A1),A0	; get Window Tracker				MOVEA.L			4(A0),A1				JSR				(A1)			; call windows event handler				BRA				MainEventExit** Send MenuKey events to Menu Handler*BrokerKey 		;				Key pressed				BTST			#CmdKey,myEvent.modifiers				BEQ				ToCurrentW		If command key down, call Menu				SUBQ			#4,A7			Manager to learn which command				MOVE			myEvent.message+2,-(A7)				_MenuKey				MOVE.L			(A7)+,D0				MOVE.L			D0,WhichPart	for high level routines				JSR 			DoCommand		DoCommand(MenuKey(Chr(myEvent.message+2)));				TST.B			doneFlag		Did we process the Quit command ?				BEQ 			@1				MOVE.L			#1,ifquit@1				BRA				MainEventExitSysWindow				PEA 			myEvent 		Desk accessory window:				MOVE.L			whichWindow,-(A7)	Call Desk Manager to handle it				_SystemClick	;				SystemClick(myEvent, whichWindow);				BRA				MainEventExit				HandleMenu				SUBQ			#4,A7			Menu bar:				MOVE.L			myEvent.where,-(A7) Call Menu Manager to learn				_MenuSelect 	;					which command				MOVE.L			(A7)+,D0				MOVE.L			D0,WhichPart	for high level routines				JSR 			DoCommand		DoCommand(MenuSelect(myEvent.where, ));				TST.B			doneFlag		Did we process the Quit command ?				BEQ 			@1				MOVE.L			#1,ifquit@1				BRA				MainEventExit				************************************************************************************; Handler for HForth window, uses EventHandler Jump TableH4thEVHandler	MOVE			myEvent.what,D0		Fetch the event number				CMP.W			#NumEventHandlers,D0				BGE.S			@done				LEA				EventHandlers,A0	Base of Jump Table				LSL.W			#2,D0				offset as 4 byte cells				MOVE.L			$0(A0,D0.W),A1		fetch address of handler				JSR				(A1)				call handler@done			RTS* Mouse down event processing*nullEvent		RTSH4thMDHandler	MOVE.L			whichPart,D0		Returned from FindWindow				CMP.L			#NumWindowHandlers,D0				BGE				@1				LEA				WindowHandlers,A0	Base of Jump Table				LSL.W			#2,D0				offset as 4 byte cells				MOVE.L			$0(A0,D0.W),A1		fetch address of handler				JSR				(A1)				call handler@1				RTSDrag				MOVE.L			whichWindow,-(A7) Title bar:				MOVE.L			myEvent.where,-(A7) Call Window Manager to drag				PEA 			dragRect				_DragWindow 	;				DragWindow(whichWindow,myEvent.where,dragRect);				RTSGrow				SUBQ			#4,A7				space for width and height				MOVE.L			whichWindow,-(A7) 	window ptr				MOVE.L			myEvent.where,-(A7) startpt				MOVE.W			#100,growRect.top				MOVE.W			#100,growRect.left				MOVE.W			#400,growRect.bottom				MOVE.W			#700,growRect.right				PEA 			growRect				_GrowWindow 	;				GrowWindow(whichWindow,myEvent.where,growRect);				MOVE.L			(A7)+,D0				BEQ				@1				MOVE.L			whichWindow,-(A7) 	window ptr				MOVE.L			D0,-(A7)			push w,h				MOVE.W			#$FFFF,-(A7)			fUpdate				_SizeWindow				BSR				update_screen@1				RTSContent				SUBQ			#4,A7			Body of application window:				_FrontWindow	;				Call Window Manager to check whether				MOVE.L			(A7)+,D0		it's the active window and make it				CMP.L			whichWindow,D0	active if not				BEQ.S			@1				If app window is active, hop				MOVE.L			whichWindow,-(A7)				_SelectWindow	;				If new window, select it@1				RTS** Key down and Auto key event processing*keyDownautoKey 						;				Key pressed; All MenuKey events should already be filtered out by BrokerKey				MOVE			myEvent.message+2,D0				MOVE.L			D0,KEYHOLDER				MOVE.L			#-1,IFKEY		Tell ?Terminal that char is in KEYHOLDER				RTS** Activate/deactivate event processing *activate		RTS** Update event processing*update_screen	; ( -- , update screen by doing whatever is necessary )				LEA				FV_UPDATE_FUNC,A0				MOVE.L			(A0),D0				BEQ				@dont				MOVE.L			D0,A0				JSR				(A0)			; usually redraw Forth Text@dont			RTSupdate* Update after so that entire window is updated and cursor does not get left on.				MOVE.L			myEvent.message,-(A7) Window appearance needs updating				_BeginUpDate	;				Call Window Manager to begin update				BSR				update_screen				MOVE.L			myEvent.message,-(A7)				_EndUpDate		;				Call Window Manager to end update				RTS************************************************************************ DoCommand - Execute command specified by the result of a MenuSelect ************************************************************************* This routine takes as a parameter the MenuSelect return in D0.theItem 		EQU 			D3 * The following defines some local data known only to this proc.				DATA			;				Switch into local data sectionname			DS.B			256 			Desk accessory name string				CODE							Switch back to code sectionDOCOMMAND	; ( call appropriate menu handler from table )			; the table holds CFAs for 8 menus 128-135				MOVE.L			D0,theItem		Case on menu ID in				SWAP			D0					high-order word of mResult				ANDI.L			#$0000FFFF,D0	; mask off Menu ID				BEQ				@exit				SUBI.L			#$80,D0			; start at 128				CMP.L			#NumMenuHandlers,D0				BGE				@exit				ASL.L			#2,D0			; cell*				LEA				MenuHandlers,A0	; address of table				MOVEA.L			$0(A0,D0.W),A1	; get CFA from table				JSR				(A1)			; call command for menu ID								;				To indicate completion of@exit			CLR.W			-(A7)			command, call Menu Manager				_HiliteMenu 	;				to unhighlight menu title				RTS				HiliteMenu(0); {highlighted by MenuSelect}** Apple menu processing*appleMenu		MOVE.L			appleMenuH,-(A7) Call Menu Manager to get DA				MOVE			theItem,-(A7)		name				PEA 			name				_GetItem		;				GetItem(appleMenuH, theItem, name);				CMPI.W			#1,theItem				BNE.S			assumeDeskAcc				JSR 			ShowAboutMeDialog				BRA.S			itworksassumeDeskAcc				SUBQ			#2,A7			Call Desk Manager to open DA				PEA 			name				_OpenDeskAcc	;				OpenDeskAcc(name);				ADDQ			#2,A7			(OpenDeskAcc result not used)itworks				MOVE.L			myWindow,-(A7)	Call QuickDraw to restore application				_SetPort		;					window as grafPort				RTS** Include menu processing*fileMenu		CMP.W			quitCommand,theItem				BNE				@2				ST				doneFlag		Set flag to Quit (caller tests)@2				RTS** Edit menu processing*editMenu		SUBQ			#2,A7			Call Desk Manager to handle editing command				MOVE			theItem,D1		if DA window is the active window				SUBQ			#1,D1			SystemEdit requires item adjustment				MOVE			D1,-(A7)		since theItem is 1 high for it				_SysEdit		;				SystemEdit(theItem-1);				MOVE.B			(A7)+,D0						RTS				DoNothing		RTS* Include menu processing*includeMenu		ANDI.L			#$0000FFFF,theItem	; mask off Menu ID				MOVE.L			theItem,InclMenuHit				RTSEventsInit		; Initialize Jump tables with Handler addresses.				LEA				EventHandlers,A0				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 0: NULL				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 1: Mouse down				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 2: Mouse up (not used)				LEA			keyDown,A1				MOVE.L			A1,(A0)+			; 3: Key down				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 4: Key up (not used)				LEA			autokey,A1				MOVE.L			A1,(A0)+			; 5: Auto key				LEA			update,A1				MOVE.L			A1,(A0)+			; 6: Update				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 7: Disk inserted (not used)				LEA			activate,A1				MOVE.L			A1,(A0)+			; 8: Activate				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 9: (not used)				MOVE.L			A1,(A0)+			; 10: (not used)				MOVE.L			A1,(A0)+			; 11: (not used)				MOVE.L			A1,(A0)+			; 12: (not used)				MOVE.L			A1,(A0)+			; 13: (not used)				MOVE.L			A1,(A0)+			; 14: (not used)				MOVE.L			A1,(A0)				; 15: (not used)								LEA				WindowHandlers,A0				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 0: inDesk				LEA			nullevent,A1				MOVE.L			A1,(A0)+			; 1: MenuBar				LEA			nullevent,A1				MOVE.L			A1,(A0)+			; 2: SysWindow				LEA			Content,A1				MOVE.L			A1,(A0)+			; 3: Content				LEA			Drag,A1				MOVE.L			A1,(A0)+			; 4: Drag				LEA			Grow,A1				MOVE.L			A1,(A0)+			; 5: Grow				LEA			nullEvent,A1				MOVE.L			A1,(A0)+			; 6: GoAway				MOVE.L			A1,(A0)+			; 7: ZoomIn  ?				MOVE.L			A1,(A0)+			; 8: ZoomOut ?				LEA				MenuHandlers,A0				LEA			appleMenu,A1				MOVE.L			A1,(A0)+				LEA			fileMenu,A1				MOVE.L			A1,(A0)+				LEA			editMenu,A1				MOVE.L			A1,(A0)+				LEA			includeMenu,A1				MOVE.L			A1,(A0)+				LEA			DoNothing,A1				MOVE.L			A1,(A0)+				MOVE.L			A1,(A0)+				MOVE.L			A1,(A0)+				MOVE.L			A1,(A0)+				; Initialize Window Tracker for H4th				LEA				myWindowTR,A0				MOVE.L			A0,CurWindowTR				MOVE.L			myWindow,A1				MOVE.L			A0,wRefCon(A1)		; set refCon in window to point to tracker				MOVE.L			A1,8(A0)	; set field in tracker to point to window				LEA				H4thEVHandler,A1				MOVE.L			A1,(A0)+			; update tracker				LEA				H4thMDHandler,A1				MOVE.L			A1,(A0)+			; update tracker				RTS								ENDP				