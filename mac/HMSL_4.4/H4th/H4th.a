* File H4th.a********************************************************************** HMSL Forth System                                                 ** Author: Phil Burk                                                 ** Copyright 1989 Phil Burk , All Rights Reserved                    ************************************************************************ Note: When assembling this program on the Mac, you must discard the old* image if you have done a SAVE-FORTH.  This is because the assembler will* not replace the data fork and the loader will get confused.** Forth Compiler** Register Assignments:** D0 = scratch, used for head tail optimization* D1-D2 = scratch, may be changed by any routines, including Mac toolbox* D3 = reserved* D4 = reserved* D5-D6 = used for DO loops* D7 = (reserved) might be used by Floating Point** A0-A1 = scratch* A2 = Local Variable stack frame pointer* A3 = HIBASE_REG = base + 64K - allows direct addressing to 96K + BSR relative* A4 = BASE_REG = base of code* A5 = application space pointer for Macintosh OS* A6 = DSP = Parameter Stack* A7 = 68000 and Forth return stack* MOD: PLB 11/26/90 Fixed REINCLUDE byte count problem!*			(ABORT) tells which word was being compiled.* MOD: PLB 7/11/91 Expanded room for CREATE words for long JSR.* MOD: PLB 9/25/91 Added D@ D! and (D0)* MOD: PLB 1/13/92 Added REDEFS?, ($CREATE), made F_EXIT not IMMEDIATE* 00001 PLB 2/21/92 Change FINDNFA to return +1 for immediate				TITLE			'HMSL4th - Forth for HMSL'				BLANKS			OFF 	; allow comments without semicolons				PRINT			OFF				INCLUDE 		'Traps.a'				INCLUDE 		'ToolEqu.a'				INCLUDE 		'QuickEqu.a'				INCLUDE 		'SysEqu.a'				INCLUDE			'PackMacs.a'				PRINT			ON**************************************************************************** Macros for Forth* PUSH and POP from data stack				MACRO				PUSH			&parmA				MOVE.L			&parmA,-(A6)				ENDM								MACRO				POP				&parmA				MOVE.L			(A6)+,&parmA				ENDM				MACRO				GRAB			&parmA				MOVE.L			(A6),&parmA				ENDM				* System Global Data made into Variables				MACRO				SVARIABLE		&name				EXPORT			(SYSV_&name) : CODESYSV_&name		LEA				&name,A0				PUSH			A0				RTS				ENDM* Regular Forth Variables				MACRO				FVARIABLE		&name				EXPORT			(&name) : CODE&name			LEA				FV_&name,A0				PUSH			A0				RTS				ENDM								MACRO				FCONSTANT		&name,&value				EXPORT			(&name) : CODE&name			PUSH			#&value				RTS				ENDM				MACRO				FWORDEND		&name		; end Forth word entry point				EXPORT			(END_&name) : CODEEND_&name		RTS				ENDM				TITLE			'Global Declarations for Sample'				include 'H4th_Mac_Data.a'				************************************************************************** H4th Specific Constants and DataTIBSize			EQU				128				FREE_CODE_SPACE	EQU				10000		initial dictionary bytes freeFREE_HDRS_SPACE	EQU				5000		initial name space* Flags for compiler, set in flag field with name.FLAG_IMMEDIATE	EQU				1FLAG_SMUDGED	EQU				2FLAG_HEAD		EQU				4FLAG_TAIL		EQU				8FLAG_INLINE		EQU				16* Equates for REGISTERSILOOP			EQU				D5JLOOP			EQU				D6HIBASE_REG		EQU				A3BASE_REG		EQU				A4DSP				EQU				A6RP				EQU				A7* Equates for Text I/O system.tio_max_columns	EQU				128			maximums for screen image buffertio_max_rows	EQU				36tio_base_x		EQU				10			left margintio_base_y		EQU				10			top marginrect_offset		EQU				16UpdateRgn_offset EQU			122* H4th Global VariablesH4thData		RECORDTIB				DS.B			TIBSizeInclMenuHit		DS.L			1IFQuit			DS.L			1IFKEY			DS.L			1KEYHOLDER		DS.L			1TempStack		DS.L			32				temporary data stackTopTempStack	DS.L			4				protect against underflowlast_vRefNum	DS.L			1				last volume used (long!)last_fileName	DS.L			128				last file includedCursorState		DS.L			1				keep track of flashing cursorCursorTime		DS.L			1				time cursor was turned onTRIED_TO_BYE	DS.L			1				set when trying to BYE* Official Forth variablesFV_TO_IN		DS.L			1				index of current char in TIBFV_NUMTIB		DS.L			1				number of chars in TIBFV_OUT			DS.L			1				count of outputted chars on lineFV_SPAN			DS.L			1				number of characters from expectFV_STATE		DS.L			1				true if compilingFV_BASE			DS.L			1				numeric baseFV_ECHO			DS.L			1				flag to display text while includingFV_SPARE		DS.L			1				for miscellaneous useFV_HDRSBASE		DS.L			1				set to point to base of headersFV_IF_DEBUG		DS.L			1				If true, MAYDEBUG will debug.FV_OSSTACKPTR	DS.L			1				ODE object stack pointerFV_IFMULTI		DS.L			1				true if multifinder activeFV_KEYSLEEP		DS.L			1				number of ticks KEY sleepsFV_R_ZERO		DS.L			1				initial return stack pointerFV_S_ZERO		DS.L			1				initial data stack pointer* Variables used by File I/OFV_FERROR		DS.L			1				errors from file I/OFV_FSPAN		DS.L			1				span from FEXPECTFV_FSOURCE		DS.L			1				source for FEXPECT to read fromFV_AT_EOF		DS.L			1				flag for when end of file reachedFV_FILETYPE		DS.L			1				Mac File Type, eg. TEXT, MidiFV_FILECREATOR	DS.L			1				Mac File Creator, eg. HMSL, MIDI* Variables used by Loader and Save-ForthFV_CONTEXT		DS.L			1				nfa of word to search fromFV_CURRENT		DS.L			1				nfa of last word definedFV_NEXTLINK		DS.L			1				address of next link fieldFV_DP			DS.L			1				dictionary pointerFV_DPL			DS.L			1				decimal place used by number?FV_CODE_PTR		DS.L			1				pointer to base of codeFV_CODE_SIZE	DS.L			1				allocated size of code desiredFV_CODE_LIMIT	DS.L			1				address at end of codeFV_HEADERS_PTR	DS.L			1				pointer to base of headersFV_HEADERS_SIZE	DS.L			1				allocated size of headers desiredFV_HEADERS_LIMIT	DS.L		1				address at end of headersFV_CHUNK_SIZE	DS.L			1				size of chunk in load fileFV_UPDATE_FUNC	DS.L			1				pointer to update routine used byFV_REDEFSQ		DS.L			1				if true, check for redefinitions*												CheckEvents, Set on load.* Variables for Text I/O system.line_height			DS.L			1			distance between succesive line bottomsline_descent		DS.L			1			descending pixelschar_width			DS.L			1current_line		DS.L			1			current line cursor is ontio_num_columns		DS.L			1			number of columns visible in windowtio_num_rows		DS.L			1			number of lines visible in windowtio_buffer 			DS.B			tio_max_columnsscreen_buffer 		DS.B			tio_max_columns*tio_max_rows					ENDR* Global Macro Variables				GBLA		&previous_nfw				include			'H4th_Mac_Code.a'				* Standard Forth Words ---------------------------------------------------------				SEG				'H4thDict'HMSL4TH			PROC			EXPORT				WITH			QuickDraw,GlobalData,H4thData  Cover our data areas								ENTRY			RUN_4TH, TIO_UPDATE				ENTRY			CodeBase				IMPORT			( HeadersBase , Next_Header ) : CODE				IMPORT			( StartDict ) : CODE				IMPORT			CheckEvents* Import from FileIO segment				IMPORT		SEG_STR_FOPEN, SEG_CLOSEFILE, SEG_FCLOSE, SEG_FFLUSH, SEG_FLUSHVOL				IMPORT		SEG_FWRITE, SEG_FREAD, SEG_FSEEK, SEG_FREWIND, SEG_FEXPECT				IMPORT		SEG_STR_FCREATE_VR, SEG_STR_FOPEN_VR				IMPORT		SEG_STR_FCREATE, SEG_STR_FSETVOL_VR, SEG_STR_FDELETE_VR				IMPORT		SEG_SFGETFILEP, SEG_FTRUNCATE* File I/O				ENTRY		STR_FOPEN, STR_INCLUDE, F_INCLUDE, FTRUNCATE				ENTRY		P_STR_INCLUDE_VR, STR_INCLUDE_VR, RE_INCLUDE, GET_INCLUDE				ENTRY		FREAD,FWRITE,FCLOSE,FSEEK,FFLUSH,FLUSHVOL,FEXPECT,FQUERY,FOPEN				ENTRY		GOTOXY,OFFSET_BEGINNING				ENTRY		OFFSET_END,OFFSET_CURRENT				ENTRY		STR_FCREATE_VR, STR_FOPEN_VR, P_STR_FOPEN_VR				ENTRY		STR_FCREATE, STR_FSETVOL_VR, STR_FDELETE_VR				ENTRY		F_SFGETFILEP				* Build Header for each Forth word* Stack Manipulation				ENTRY		DUP, Q_DUP, DROP, OVER, ROT, MINUS_ROT				ENTRY		SWAP,TUCK,NIP,DDROP,DDUP,ZERO_SP,SP_FETCH,SP_STORE				ENTRY		DEPTH,PICK, DSTORE, DFETCH, DSWAP,DOVER, S_ZERO, XDROP* Call Support				ENTRY		A0_STORE, A0_FETCH, A1_STORE, A1_FETCH, D0_STORE, D0_FETCH* Return Stack				ENTRY		TO_R, ZERO_TO_R, R_FROM, R_FETCH, R_DROP, RP_FETCH, RP_STORE				ENTRY		WTO_R, ZERO_WTO_R, WR_FROM, WR_FETCH, R_ZERO, X_TO_R, X_R_FROM* Memory				ENTRY		F_CMOVE,F_CMOVEB,F_FILL,FETCH,STORE,WFETCH,WSTORE,CFETCH				ENTRY		CSTORE,F_ON,F_OFF* Output				ENTRY		DOTS,DUMP,DOT,DOTHEX,CR, TO_NEWLINE* Control				ENTRY		BYE,P_ABORT,ABORT,P_QUIT,QUIT,CHECK_STACK, Q_ERROR, F_ERROR				ENTRY		UserApplication,UserInit,UserTerm, F_NOOP, F_EXIT* I/O				ENTRY		KEY,P_KEY,EMIT,P_EMIT,TYPE,P_TYPE,COUNT, PAUSE_TASK				ENTRY		STRMOVE,DOT_PAREN,BACKSPACE,TIO_CLS,TIO_ADJUST,BL				ENTRY		P_QTERMINAL, QTERMINAL, P_EXPECT, EXPECT				ENTRY		NUM_COLUMNS, LAST_EVENT, P_CR, KEYLOOP				ENTRY		EVENT_HANDLERS, WINDOW_HANDLERS, MENU_HANDLERS				ENTRY		TIO_CURSOR_ON, TIO_CURSOR_OFF, FLASH_CURSOR				ENTRY		WATCH_CURSOR, IBEAM_CURSOR, ARROW_CURSOR				* Editing I/O Support				ENTRY		TIO_BACKWARDS				ENTRY		TIO_FORWARDS				ENTRY		TIO_ERASE_EOL				ENTRY		TIO_INSERT				ENTRY		TIO_DELETE				* Variables				ENTRY		TO_IN,NUMTIB,OUT,CONTEXT,CURRENT,NEXTLINK,SPAN				ENTRY		DP,BASE,FERROR,FSPAN,FSOURCE,AT_EOF,ECHO,ADDR_TIB				ENTRY		SPARE, IFMULTI, KEYSLEEP, DPL				ENTRY		CODE_PTR, CODE_SIZE, HEADERS_PTR, HEADERS_SIZE				ENTRY		HDRSBASE, CODE_LIMIT, HEADERS_LIMIT				ENTRY		FILETYPE, FILECREATOR				ENTRY		WHICH_PART, WHICH_WINDOW, MAIN_WINDOW				* Compiler						ENTRY		WORD				ENTRY		SCAN				ENTRY		SKIP				ENTRY		WCOMMA				ENTRY		COMMA				ENTRY		CALLCOMMA				ENTRY		NFACALL				ENTRY		P_NFACALL				ENTRY		COMPILE_INLINE				ENTRY		P_COMPILE_INLINE				ENTRY		COMPILE_NFA_INLINE				ENTRY		P_COMPILE_NFA_INLINE				ENTRY		TICK				ENTRY		TICKN				ENTRY		P_FIND				ENTRY		FIND				ENTRY		P_FINDNFA				ENTRY		FINDNFA				ENTRY		MATCHNFAS				ENTRY		GET_CODEBASE				ENTRY		EXECUTE				ENTRY		HERE				ENTRY		P_HERE				ENTRY		PAD				ENTRY		ALLOT				ENTRY		NFA2CFA				ENTRY		NFA2LFA				ENTRY		NFA2SFA				ENTRY		NFA2FFA				ENTRY		NFA2CFA				ENTRY		NFA2LFA				ENTRY		COLON_CREATE				ENTRY		P_CREATE				ENTRY		P_STRING_CREATE				ENTRY		CREATE				ENTRY		DOES				ENTRY		DEFER				ENTRY		TO_IS				ENTRY		SEMICOLON				ENTRY		COLON				ENTRY		STATE				ENTRY		Q_IMMEDIATE				ENTRY		QUERY				ENTRY		P_QUERY				ENTRY		LITERAL				ENTRY		ALITERAL				ENTRY		DLITERAL				ENTRY		LEFT_BRACKET				ENTRY		RIGHT_BRACKET				ENTRY		LATEST				ENTRY		BRANCH				ENTRY		ZERO_BRANCH				ENTRY		Q_COMP				ENTRY		Q_PAIRS				ENTRY		USE_TO_REL				ENTRY		REL_TO_USE				ENTRY		PQ_DO				ENTRY		P_DO				ENTRY		PLOOP				ENTRY		PPLUSLOOP				ENTRY		I_DO				ENTRY		J_DO				ENTRY		F_BOUNDS				ENTRY		PLEAVE				ENTRY		HNUMBERQ				ENTRY		NUMBERQ				ENTRY		P_SMUDGE				ENTRY		P_UNSMUDGE				ENTRY		SMUDGE				ENTRY		UNSMUDGE				ENTRY		INTERPRET				ENTRY		RECOGNIZE* Test words				ENTRY		DEBUG				ENTRY		MAYDEBUG				ENTRY		IF_DEBUG				* ODE Stack Manipulation				ENTRY		OS_PUSH, OS_DROP, OS_COPY, OS_PLUS, OS_PLUS_PUSH				* ADD NEW ONES HERE !!!!* Comparison Operators				ENTRY			EQUALS				ENTRY			NOT_EQUALS				ENTRY			GREATER_THAN				ENTRY			LESS_THAN				ENTRY			GREATER_EQUAL				ENTRY			LESS_EQUAL				ENTRY			UGREATER_THAN				ENTRY			ULESS_THAN				ENTRY			EQUALS0				ENTRY			NOT_EQUALS0				ENTRY			GREATER_THAN0				ENTRY			LESS_THAN0				ENTRY			GREATER_EQUAL0				ENTRY			LESS_EQUAL0								ENTRY		BETWEEN				ENTRY		WITHIN* Logical Operators				ENTRY		L_AND				ENTRY		L_OR				ENTRY		L_XOR				ENTRY		F_NOT* Arithmetic				ENTRY		PLUS				ENTRY		MINUS				ENTRY		NEGATE				ENTRY		MULTIPLY				ENTRY		ABS_VALUE				ENTRY		DIVIDE				ENTRY		PLUS_STORE				ENTRY		MIN				ENTRY		MAX				ENTRY		SHIFT, ASHIFT, PLUS_SHIFT, MINUS_SHIFT				ENTRY		TWOPLUS				ENTRY		TWOTIMES				ENTRY		TWOSLASH				ENTRY		UTWOSLASH*				ENTRY		UTWOTIMES*				ENTRY		DTWOSLASH				ENTRY		DNEGATE				ENTRY		F_DABS				ENTRY		DPLUS				ENTRY		DMINUS				ENTRY		TWOMINUS				ENTRY		FOURPLUS				ENTRY		FOURTIMES				ENTRY		FOURSLASH				ENTRY		FOURMINUS				ENTRY		ONEMINUS				ENTRY		ONEPLUS				ENTRY		BYTE_EXTEND				ENTRY		WORD_EXTEND				ENTRY		S_TO_D				* MIDI Manager support				ENTRY		F_SndDispVersion				ENTRY		DebugMIDIReadHook				ENTRY		MIDIReadHook				ENTRY		MIDIEchoHook				 				 				* Entry Point For Forth ------------------------------------------------CodeBase		DS.L			0					RUN_4TH			BSR				InitForth				BSR				UserApplication		Set in a turnkeyed program.				BSR				OK				BSR				CR				BSR				QUIT				Calls BYE in a turnkeyed program.; Execution will never get past QUIT				RTSWelcome			DC.B			'----=< Welcome to HMSL >=----'				InitForth		BSR				SaveRetStack	; assume A6 stack already setup				TST.L			D0				BEQ.S			@1				BSR				InitCodeRsrc	; init if nonzero, loaded from resource@1				BSR				ResetForth				BSR				InitVars* Initialize Subsystems				BSR				TIO_INIT* Post Welcome				LEA				Welcome,A0				MOVE.L			A0,-(A6)				BSR				COUNT				BSR				TYPE				BSR				CR				BSR				UserInit		; deferred user initialization				RTS				SaveRetStack	MOVE.L			A7,FV_R_ZERO		save return stack level				RTS				RestoreRetStack	MOVE.L			(A7)+,A0		save return pointer				MOVE.L			FV_R_ZERO,A7				ADD.L			#4,A7				MOVE.L			A0,-(A7)				RTSInitVars		CLR.L			FV_FSOURCE				CLR.L			IfQuit				CLR.L			IfKey				CLR.L			FV_OUT				CLR.L			FV_ECHO				MOVE.L			#10,FV_BASE      set to decimal				CLR.L			FV_NUMTIB				CLR.L			FV_OUT				CLR.L			FV_FSOURCE				CLR.L			FV_IF_DEBUG				CLR.L			FV_IFMULTI				CLR.L			FV_KEYSLEEP				CLR.L			TRIED_TO_BYE				CLR.L			CursorState				CLR.L			CursorTime				MOVE.L			#$54455854,FV_FILETYPE	'TEXT'				MOVE.L			#$484D534C,FV_FILECREATOR	'HMSL'				RTS				ResetForth		BSR				ZERO_SP				CLR.L			FV_STATE* reset QUERY to get from keyboard;				LEA				P_QUERY,A1;				LEA				QUERY,A0; I don't know why this doesn't assemble!!!! %Q;				ADDA.L			#DEFER_DATA-DEFER_CODE,A0;				MOVE.L			A1,(A0)				RTS* Set  FV_DP,  FV_NEXTLINK,  FV_HDRSBASE, FV_CURRENT, FV_CONTEXT, BASE_REG, HIBASE_REG* 		FV_S_ZEROInitCodeRsrc	; ( -- , assume stack completely empty )				LEA				StartDict,A0				MOVE.L			A0,FV_DP				ADDA.L			#FREE_CODE_SPACE-32,A0				MOVE.L			A0,FV_S_ZERO				BSR				ZERO_SP				; use stack in dictionary*				BSR				GET_NEXTLINK				POP				FV_NEXTLINK				BSR				GET_HeadersBase				POP				FV_HDRSBASE*				MOVE.L			FV_NEXTLINK,A0				SUBA.L			#4,A0					length of name of 1+				MOVE.L			A0,FV_CONTEXT				MOVE.L			A0,FV_CURRENT				LEA				CodeBase,BASE_REG		load relocation register				MOVE.L			A4,HIBASE_REG				ADD.L			#$10000,HIBASE_REG		load high relocation base+64K*				MOVE.L			FV_DP,D0				set limits for code				ADD.L			#FREE_CODE_SPACE,D0				MOVE.L			D0,FV_CODE_LIMIT				MOVE.L			FV_NEXTLINK,D0			set limits for headers				ADD.L			#FREE_HDRS_SPACE,D0				MOVE.L			D0,FV_HEADERS_LIMIT				CLR.L			FV_CODE_PTR				CLR.L			FV_HEADERS_PTR				RTS								* Include various modules				include			'textio.a'	; TYPE CR etc.				include 		'midi_mgr.a'				* Define words to push variable addresses.				FVARIABLE		STATE				FVARIABLE		TO_IN				FVARIABLE		NUMTIB				FVARIABLE		OUT				FVARIABLE		CONTEXT				FVARIABLE		CURRENT				FVARIABLE		NEXTLINK				FVARIABLE		SPAN				FVARIABLE		DP				FVARIABLE		BASE				FVARIABLE		SPARE				FVARIABLE		IF_DEBUG				FVARIABLE		IFMULTI				FVARIABLE		KEYSLEEP				FVARIABLE		R_ZERO				FVARIABLE		S_ZERO				FVARIABLE		UPDATE_FUNC				FVARIABLE		DPL				FVARIABLE		REDEFSQ				* Variables to Control File I/O				FVARIABLE		FSPAN				FVARIABLE		FSOURCE				FVARIABLE		FERROR				FVARIABLE		AT_EOF				FVARIABLE		ECHO				FVARIABLE		FILETYPE				FVARIABLE		FILECREATOR* Variables used by Loader				FVARIABLE		CODE_PTR				FVARIABLE		CODE_SIZE				FVARIABLE		CODE_LIMIT				FVARIABLE		HEADERS_PTR				FVARIABLE		HEADERS_SIZE				FVARIABLE		HEADERS_LIMIT				FVARIABLE		HDRSBASE				* Variables used by ODE				FVARIABLE		OSSTACKPTR* System Variables				SVARIABLE		IFQUIT				SVARIABLE		IFKEY				SVARIABLE		KEYHOLDER				SVARIABLE		AppleMenuH				SVARIABLE		FileMenuH				SVARIABLE		EditMenuH				SVARIABLE		loadStatus*				SVARIABLE		LINE_HEIGHT*				SVARIABLE		LINE_DESCENT*				SVARIABLE		CHAR_WIDTHADDR_TIB				LEA				TIB,A0				PUSH			A0				RTS		IMPORT	MATH_CODE : CODE		IMPORT	(P_SLASHMOD_00 , P_USLASH_00) : CODE		IMPORT	(P_TIMES_00, P_UTIMES_00 , P_MTIMES_00 ) : CODE		IMPORT	(P_SLASHMOD_20 , P_USLASH_20, P_MSLASH_20) : CODE		IMPORT	(P_TIMES_20, P_UTIMES_20 , P_MTIMES_20) : CODE		IMPORT	(DTWOTIMES , DUTWOTIMES , DUTWOSLASH, PLUSMINUS) : CODE		**************************************************************************		Stack Manipulation												**************************************************************************ZERO_SP   ;   ( whatever -- , clear stack )				MOVE.L			FV_S_ZERO,A6				RTS				SP_FETCH	; ( -- addr , set stack pointer )				MOVE.L			DSP,-(DSP)	FWORDEND	SP_FETCH	SP_STORE	; ( addr -- , set stack pointer )				MOVE.L			(DSP)+,DSP	FWORDEND	SP_STORE								MACRO				M_DUP				MOVE.L			(A6),-(A6)				ENDM				DUP	; ( n -- n n )				M_DUP	FWORDEND	DUPQ_DUP	; ( n | 0 -- n n | 0 )				MOVE.L			(A6),D0				BEQ.S			END_Q_DUP				PUSH			D0			; WARNING - This cannot be head/tail optimized											;	because of the branch.	FWORDEND	Q_DUP				SWAP				MOVE.L			(A6)+,D1				MOVE.L			(A6)+,D0				MOVE.L			D1,-(A6)				MOVE.L			D0,-(A6)	FWORDEND	SWAP	TUCK				MOVE.L			(A6)+,D1				MOVE.L			(A6)+,D0				MOVE.L			D1,-(A6)				MOVE.L			D0,-(A6)				MOVE.L			D1,-(A6)				RTS					MACRO				M_DROP				ADDQ.L			#4,A6				ENDM				DROP	; ( n -- )				M_DROP	FWORDEND	DROP				MACRO				M_OVER				MOVE.L			$4(A6),-(A6)				ENDM				OVER	; ( a b -- a b a )				M_OVER	FWORDEND	OVERROT				MOVE.L			$8(A6),D0				MOVE.L			$4(A6),$8(A6)				MOVE.L			(A6),$4(A6)				MOVE.L			D0,(A6)				RTS				MINUS_ROT				MOVE.L			(A6),D0				MOVE.L			$4(A6),(A6)				MOVE.L			$8(A6),$4(A6)				MOVE.L			D0,$8(A6)				RTSNIP				MOVE.L			(A6)+,(A6)	FWORDEND	NIP* Multiple stack operatorsXDROP	; ( ... N -- , drop N items )				POP				d0				asl.l			#2,d0				adda.l			d0,a6				rts				* Double number stack manipulators.DFETCH ;  ( addr -- d )			move.l		(a6)+,a0			move.l		4(a0),-(a6)			move.l		(a0),-(a6)			RTSDSTORE ;   ( d addr -- )			move.l		(a6)+,a0			move.l		(a6)+,(a0)+			move.l		(a6)+,(a0)+			RTS			DDUP	; ( a b -- a b a b )				MOVE.L			$4(A6),-(A6)				MOVE.L			$4(A6),-(A6)				RTS				DSWAP	; ( a b c d-- c d a b )				MOVE.L			(A6),D0				MOVE.L			$8(A6),(A6)				MOVE.L			D0,$8(A6)				MOVE.L			$4(A6),D0				MOVE.L			$C(A6),$4(A6)				MOVE.L			D0,$C(A6)				RTS				DOVER 	; ( a b c d -- a b c d a b )				MOVE.L			$C(A6),-(A6)				MOVE.L			$C(A6),-(A6)				RTSDDROP				ADDQ.L			#8,A6				RTSPICK	 ; ( v v v n -- v v v vn , pick nth from stack )				POP				D0				LSL				#2,D0				MOVE.L			$0(DSP,D0.L),-(DSP)	FWORDEND	PICK* Support for system calls.A0_STORE	; ( n -- , store in A0 )				POP				A0	FWORDEND	A0_STOREA0_FETCH	; ( -- n , fetch from A0 )				PUSH			A0	FWORDEND	A0_FETCHA1_STORE	; ( n -- , store in A1 )				POP				A1	FWORDEND	A1_STOREA1_FETCH	; ( -- n , fetch from A1 )				PUSH			A1	FWORDEND	A1_FETCHD0_STORE	; ( n -- , store in D0 )				POP				D0	FWORDEND	D0_STORED0_FETCH	; ( -- n , fetch from D0 )				PUSH			D0	FWORDEND	D0_FETCH	* Return Stack ManipulationTO_R	; ( n -- , push onto return stack , inline macro )				MOVE.L			(A6)+,-(A7)	FWORDEND	TO_RZERO_TO_R	; ( -- , push 16 bit zero to stack for Mac calls )				MOVE.L			#0,-(A7)	FWORDEND	ZERO_TO_RR_FROM	; ( -- n , pop from return stack , inline macro )				MOVE.L			(A7)+,-(A6)	FWORDEND	R_FROMR_FETCH	; ( -- n , copy from return stack , inline macro )				MOVE.L			(A7),-(A6)	FWORDEND	R_FETCH	WTO_R	; ( w -- , push word onto return stack , inline macro )				POP				D0				MOVE.W			D0,-(A7)	FWORDEND	WTO_RZERO_WTO_R	; ( -- , push 16 bit zero to stack for Mac calls )				MOVE.W			#0,-(A7)	FWORDEND	ZERO_WTO_R	WR_FROM	; ( -- w , pop word from return stack , inline macro )				MOVE.W			(A7)+,-(A6)				MOVE.W			#0,-(A6)	FWORDEND	WR_FROMWR_FETCH	; ( -- w , copy word from return stack , inline macro )				MOVE.W			(A7),-(A6)				MOVE.W			#0,-(A6)	FWORDEND	WR_FETCH	R_DROP	; ( -- , drop item from return stack , inline macro )				ADD.L			#4,A7	FWORDEND	R_DROPRP_FETCH	; ( -- addr , fetch stack pointer )				PUSH			RP				ADDQ.L			#4,(A6)	FWORDEND	RP_FETCHRP_STORE	; ( addr -- , set stack pointer )				POP				RP	FWORDEND	RP_STORE	X_TO_R	; ( ... n -- , push onto return stack , inline macro )				MOVE.L			(A7)+,D1		; save return address				POP				D0				BLE				@2				; don't if <= 0@1				MOVE.L			(A6)+,-(A7)				SUBQ.L			#1,D0				BGT				@1@2				MOVE.L			D1,-(A7)				RTS	X_R_FROM	; ( n -- ... , pop from return stack , inline macro )				MOVE.L			(A7)+,D1		; save return address				POP				D0				BLE				@2				; don't if <= 0@1				MOVE.L			(A7)+,-(A6)				SUBQ.L			#1,D0				BGT				@1@2				MOVE.L			D1,-(A7)				RTS				**************************************************************************		   ODE Stack Tools												*************************************************************************** Old version - see attempt at optimization in 'new_obj_stack.a'OS_PUSH		;	( n -- , push onto object stack )				MOVE.L		FV_OSSTACKPTR,A0  				MOVE.L		(A6)+,-(A0)  				MOVE.L		A0,FV_OSSTACKPTR  				RTSOS_DROP 	;	( -- , drop top of object stack )				ADDQ.L		#$4,FV_OSSTACKPTR	FWORDEND	OS_DROPOS_COPY		;	( -- N , make copy of top of object stack )				MOVE.L		FV_OSSTACKPTR,A0				MOVE.L		(A0),-(A6)	FWORDEND	OS_COPYOS_PLUS		;	( M -- N+M , add top of object stack )				POP			D0				MOVE.L		FV_OSSTACKPTR,A0				ADD.L		(A0),D0				PUSH		D0	FWORDEND	OS_PLUSOS_PLUS_PUSH  ; ( N -- , Add to OS TOP and push onto object stack )				POP			D0				MOVE.L		FV_OSSTACKPTR,A0				ADD.L		(A0),D0				MOVE.L		D0,-(A0)				MOVE.L		A0,FV_OSSTACKPTR				RTS		**************************************************************************		   Memory Access												**************************************************************************FETCH	; ( addr -- n )				POP				A0				MOVE.L			(A0),-(A6)	FWORDEND	FETCH				STORE	; ( n addr -- )				POP				A0				MOVE.L			(A6)+,(A0)	FWORDEND	STORE				WFETCH	; ( addr -- word )				POP				A0				MOVEQ.L			#0,D0				MOVE.W			(A0),D0				PUSH			D0	FWORDEND	WFETCH				WSTORE	; ( word addr -- )				POP				A0				MOVE.L			(A6)+,D0				MOVE.W			D0,(A0)	FWORDEND	WSTORE				CFETCH	; ( addr -- byte )				POP				A0				MOVEQ.L			#0,D0				MOVE.B			(A0),D0				PUSH			D0	FWORDEND	CFETCH				CSTORE	; ( byte addr -- )				POP				A0				MOVE.L			(A6)+,D0				MOVE.B			D0,(A0)				RTSGET_CODEBASE  ;	( -- codebase , get base address of code segment )				PUSH			BASE_REG				RTSUSE_TO_REL  ; ( absolute -- relocatable )				POP				A0				SUBA.L			BASE_REG,A0				PUSH			A0	FWORDEND	USE_TO_REL				REL_TO_USE  ; ( relocatable -- absolute  )				POP				A0				ADDA.L			BASE_REG,A0				PUSH			A0	FWORDEND	REL_TO_USEF_ON		; ( addr -- , set true )				POP				A0				MOVE.L			#$FFFFFFFF,(A0)	FWORDEND	F_ON				F_OFF		; ( addr -- , set false )				POP				A0				MOVE.L			#$0,(A0)	FWORDEND	F_OFF				**************************************************************************		   Arithmetic													**************************************************************************PLUS	; (  a b -- a+b )				POP			D0				ADD.L		D0,(A6)	FWORDEND	PLUS				MINUS	; (  a b -- a-b )				POP			D0				SUB.L		D0,(A6)	FWORDEND	MINUS				ONEPLUS	; ( n -- n+1 )				ADDQ.L			#1,(A6)	FWORDEND	ONEPLUS				ONEMINUS	; ( n -- n-1 )				SUBQ.L			#1,(A6)	FWORDEND	ONEMINUS				TWOPLUS	; ( n -- n+2 )				ADDQ.L			#2,(A6)	FWORDEND	TWOPLUS				TWOMINUS	; ( n -- n-2 )				SUBQ.L			#2,(A6)	FWORDEND	TWOMINUSTWOTIMES	; ( n -- n*2 )				POP				D0				ASL.L			#1,D0				PUSH			D0	FWORDEND	TWOTIMES				TWOSLASH	; ( n -- n/2 )				POP				D0				ASR.L			#1,D0				PUSH			D0	FWORDEND	TWOSLASHUTWOSLASH	; ( n -- n/2 )				POP				D0				LSR.L			#1,D0				PUSH			D0	FWORDEND	UTWOSLASHFOURPLUS	; ( n -- n+4 )				ADDQ.L			#4,(A6)	FWORDEND	FOURPLUS				FOURMINUS	; ( n -- n-4 )				SUBQ.L			#4,(A6)	FWORDEND	FOURMINUSFOURTIMES	; ( n -- n*4 )				POP				D0				ASL.L			#2,D0				PUSH			D0	FWORDEND	FOURTIMES				FOURSLASH	; ( n -- n/4 )				POP				D0				ASR.L			#2,D0				PUSH			D0	FWORDEND	FOURSLASH				PLUS_STORE	; ( n addr -- , add n to addr )				POP			A0				POP			D0				ADD.L		D0,(A0)	FWORDEND	PLUS_STORE	MIN		; ( a b -- a | b , leave lowest )				POP			D0				POP			D1				CMP.L		D1,D0				BLT.S		@1				PUSH		D1				BRA.S		@2@1				PUSH		D0@2				RTSMAX		; ( a b -- a | b , leave highest )				POP			D0				POP			D1				CMP.L		D1,D0				BGE.S		@1				PUSH		D1				BRA.S		@2@1				PUSH		D0@2				RTSPLUS_SHIFT	; ( val n -- , logical shift val by LEFT by n bits )				POP			D0				POP			D1				LSL.L		D0,D1				PUSH		D1	FWORDEND	PLUS_SHIFT				MINUS_SHIFT	; ( val n -- , logical shift val by RIGHT by n bits )				POP			D0				POP			D1				LSR.L		D0,D1				PUSH		D1	FWORDEND	MINUS_SHIFTSHIFT	; ( val n -- , logical shift val by n bits )				POP			D0				BGE.S			@left				POP			D1				NEG.L		D0				LSR.L		D0,D1				BRA.S			@done@left			POP			D1				LSL.L		D0,D1@done			PUSH		D1				RTSASHIFT	; ( val n -- , arithmetic shift val by n bits )				POP			D0				BGE.S		@left				POP			D1				NEG.L		D0				ASR.L		D0,D1				BRA.S		@done@left			POP			D1				ASL.L		D0,D1@done			PUSH		D1				RTS				ABS_VALUE	; ( a -- |a| )				POP			D0				BGT.S		@dont				NEG.L		D0@dont			PUSH		D0	FWORDEND	ABS_VALUEMULTIPLY	; ( a b -- a*b , fast * , kludge %Q )				POP			D0				POP			D1				MULS		D1,D0				PUSH		D0	FWORDEND	MULTIPLY				SLASHMOD_F	; ( a b -- rem q , fast version, %Q )				POP			D0				BEQ.S		@divby0				POP			D1				DIVS		D0,D1				MOVE.L		D1,D0				SWAP		D1			extract remainder				ANDI.L		#$FFFF,D1				EXT.L		D1				PUSH		D1				ANDI.L		#$FFFF,D0				EXT.L		D0				PUSH		D0@divby0			RTSDIVIDE		; ( a b -- a/b , fast version %Q )				POP			D0				BEQ.S		@divby0				POP			D1				DIVS		D0,D1				ANDI.L		#$FFFF,D1				EXT.L		D1				PUSH		D1@divby0			RTSNEGATE		;  ( d -- -d )				NEG.L		(DSP)	FWORDEND	NEGATEBYTE_EXTEND   ; ( signed_byte -- signed_long )				POP			D0				EXT.W		D0				EXT.L		D0				PUSH		D0	FWORDEND	BYTE_EXTENDWORD_EXTEND   ; ( signed_word -- signed_long )				POP			D0				EXT.L		D0				PUSH		D0	FWORDEND	WORD_EXTEND			S_TO_D	; ( single -- double )				tst.l		(a6)				bge.s		@1				move.l		#-1,-(a6)				bra			@2@1				move.l		#0,-(a6)@2				rts* Double Precision OperatorsDNEGATE		;  ( d -- -d )				NEG.L		$4(DSP)				NEGX.L		(DSP)	FWORDEND	DNEGATEF_DABS		; ( d -- |d| )				TST.L		(DSP)				BMI			DNEGATE				RTSDPLUS		;  ( d1 d2 -- d1+d2 )				MOVEM.L		D2-D3,-(A7)				MOVEM.L		(DSP)+,D0-D3				ADD.L		D1,D3				ADDX.L		D0,D2				PUSH		D3				PUSH		D2				MOVEM.L		(A7)+,D2-D3				RTSDMINUS		;  ( d1 d2 -- d1-d2 )				MOVEM.L		D2-D3,-(A7)				MOVEM.L		(DSP)+,D0-D3				SUB.L		D1,D3				SUBX.L		D0,D2				PUSH		D3				PUSH		D2				MOVEM.L		(A7)+,D2-D3				RTS**************************************************************************		   Logical Operators											**************************************************************************L_AND	; ( a b -- a&b )				POP			D0				AND.L		D0,(A6)	FWORDEND	L_ANDL_OR	; ( a b -- a|b )				POP			D0				OR.L		D0,(A6)	FWORDEND	L_ORL_XOR	; ( a b -- a XOR b )				POP			D0				EOR.L		D0,(A6)	FWORDEND	L_XOR				F_NOT	; ( a -- !a )				POP			D0				BNE.S			@1				PUSH		#$FFFFFFFF				RTS@1				PUSH		#0				RTS**************************************************************************		   Comparison Operators											**************************************************************************				MACRO				COMPARISON	&name,&opcode		; ( a b -- flag )				EXPORT		(&name) : CODE&name			CMPM.L		(A6)+,(A6)+				&opcode		@not				PUSH		#0				RTS@not			PUSH		#-1				RTS				ENDM						BRANCH		BYTE		COMPARISON	EQUALS,BEQ		COMPARISON	NOT_EQUALS,BNE		COMPARISON	GREATER_THAN,BGT		COMPARISON	LESS_THAN,BLT		COMPARISON	UGREATER_THAN,BHI		COMPARISON	ULESS_THAN,BCS		COMPARISON	GREATER_EQUAL,BGE		COMPARISON	LESS_EQUAL,BLE		BRANCH		WORD							MACRO				COMPARISON0	&name,&opcode		; ( a -- flag )				EXPORT		(&name) : CODE&name			TST.L		(A6)+				&opcode		@not				PUSH		#0				RTS@not			PUSH		#-1				RTS				ENDM				BRANCH		BYTE		COMPARISON0	EQUALS0,BEQ		COMPARISON0	NOT_EQUALS0,BNE		COMPARISON0	GREATER_THAN0,BGT		COMPARISON0	LESS_THAN0,BLT		COMPARISON0	GREATER_EQUAL0,BGE		COMPARISON0	LESS_EQUAL0,BLE		BRANCH		WORD			BETWEEN		; ( n min max -- flag )				POP			D0			max				POP			D1			min				MOVE.L		(DSP),D2	n				CMP.L		D2,D1				BGT.S		@out				CMP.L		D2,D0				BLT.S			@out				MOVE.L		#$FFFFFFFF,(DSP)				BRA.S		@end@out			CLR.L		(DSP)@end			RTSWITHIN    ; ( n min max -- flag )				SUB.L		#1,(DSP)				BSR			BETWEEN				RTS				**************************************************************************		  	Iterative Memory Operations									**************************************************************************F_CMOVE ; ( addr dest count -- )				POP			D0		count				POP			A1		dest				POP			A0		source				TST.L		D0				BLE.S		@2@1				MOVE.B		(A0)+,(A1)+				SUBQ.L		#1,D0				BGT.S		@1		( don't use DBRA cuz only 16 bit count )@2				RTSF_CMOVEB ; ( addr dest count -- , move data backwards )				POP			D0		count				POP			A1		dest				ADD.L		D0,A1				POP			A0		source				ADD.L		D0,A0				TST.L		D0				BLE.S		@2@1				MOVE.B		-(A0),-(A1)				SUBQ.L		#1,D0				BGT.S		@1		( don't use DBRA cuz only 16 bit count )@2				RTSF_FILL ; ( addr count byte -- )				POP			D0				POP			D1				POP			A0				TST.L		D1				BLE.S		@2@1				MOVE.B		D0,(A0)+				SUBQ.L		#1,D1				BGT.S		@1@2				RTS**************************************************************************		  	Terminal I/O												**************************************************************************LAST_EVENT	; ( -- EventRecord , for examining last event )				LEA			myEvent,A0				PUSH		A0				RTS				WHICH_WINDOW	; ( -- which-window , window found by FindWindow )				LEA			whichWindow,A0				PUSH		A0				RTS				WHICH_PART		; ( -- which-part , part found by FindWindow )				LEA			whichPart,A0				PUSH		A0				RTS				MAIN_WINDOW		; ( -- H4thWindow )				MOVE.L		myWindow,-(A6)				RTSEVENT_HANDLERS	; ( -- EventHandlers , for examining last event )				LEA			EventHandlers,A0				PUSH		A0				RTSWINDOW_HANDLERS		; ( -- WIndowHandlers , for examining last event )				LEA			WindowHandlers,A0				PUSH		A0				RTSMENU_HANDLERS		; ( -- MenuHandlers , list of menu processors )				LEA			MenuHandlers,A0				PUSH		A0				RTSCHECK_INCLUDES	; ( -- , do INCLUDE if chosen from menu )				MOVE.L			InclMenuHit,D0			process file menu hit				BEQ.S			@3				CLR.L			InclMenuHit				CMPI.B			#1,D0					BNE.S			@1					BSR				TIO_CURSOR_OFF					BSR				GET_INCLUDE					BRA.S			@3@1				CMPI.B			#2,D0					BNE.S			@2					BSR				TIO_CURSOR_OFF					BSR				RE_INCLUDE@2				CMPI.B			#3,D0					BNE.S			@3					BSR				TIO_CURSOR_OFF					BSR				EDIT_INCLUDE@3				RTS				P_QTERMINAL				JSR				CheckEvents				BSR				CHECK_INCLUDES				TST.L			IfQuit				BEQ.S			@1				BSR				BYE@1				MOVE.L			IfKey,-(A6)				RTS				FLASH_CURSOR	; ( -- , flash cursor every CaretTime ticks )				MOVE.L		#0,-(A7)				_TickCount					; TRAP				MOVE.L		(A7)+,D1		get current time				MOVE.L		CursorTime,D0				ADD.L		CaretTime,D0	if (last+caret < current) toggle				CMP.L		D0,D1				BLT			@done				MOVE.L		D1,CursorTime	update time				MOVE.L		CursorState,D0				BEQ.S		@nowoff				BSR			TIO_CURSOR_OFF				RTS@nowoff			BSR			TIO_CURSOR_ON@done			RTSP_KEY		; ( -- char , wait for character )				BSR			QTERMINAL		; is there already a character?				POP			D0				BNE			@gotchar				_ObscureCursor				; turn off mouse cursor until mouse moves				MOVE.L		#8,FV_KEYSLEEP	; sleep				BSR			TIO_CURSOR_ON@loop			BSR			FLASH_CURSOR				BSR			KEYLOOP				BSR			PAUSE_TASK		; give other tasks a chance				BSR			QTERMINAL				POP			D0				BEQ.S		@loop				BSR			TIO_CURSOR_OFF				CLR.L		FV_KEYSLEEP* return key value@gotchar		MOVE.L		KEYHOLDER,D0				ANDI.L		#$FF,D0				PUSH		D0				CLR.L		IFKEY				RTS				EMITBUF			DS.L			1P_EMIT	; ( char -- , emit by typing to TIO )				LEA				EMITBUF,A0				POP				D0				MOVE.B			D0,(A0)				PUSH			A0				PUSH			#1				BSR				TYPE				RTS				OLDCR			MOVE.L			#$0D,-(A6)		Push 'CR'				BSR				EMIT				CLR.L			FV_OUT				RTSP_CR			BSR				TIO_CR				RTSNUM_COLUMNS	; ( -- #cols )				PUSH			tio_num_columns				RTS				SPACE			MOVE.L			#32,-(A6)		Push ' '				BSR				EMIT				RTS				COUNT	; ( addr -- addr+1, count )				MOVE.L			(A6)+,A0				MOVEQ.L			#0,D0				MOVE.B			(A0)+,D0				MOVE.L			A0,-(A6)				MOVE.L			D0,-(A6)				RTS				OLDTYPE	; ( addr count -- )				MOVE.L			D6,-(A7)				MOVE.L			(A6)+,D6			Counter				BLE.S			@2				SUBQ.L			#1,D6@1				M_DUP				BSR				CFETCH				BSR				EMIT				BSR				ONEPLUS				DBRA			D6,@1@2				M_DROP				MOVE.L			(A7)+,D6				RTS				P_TYPE	; ( addr count -- )				BSR				TIO_CURSOR_OFF				BSR				TIO_TYPE				BSR				PAUSE_TASK		; give other tasks a chance				RTSDOT_PAREN  ; ( <text> -- , print it )				PUSH			#')'				BSR				WORD				BSR				COUNT				BSR				TYPE				RTSTO_NEWLINE	; ( -- , CR if OUT > 0 )				MOVE.L		FV_OUT,D0				BLE.S		@1				BSR			CR@1				RTSCURSOR_LEFT ; ( -- , move one position to the left )				MOVE.L		FV_OUT,D0				BLE.S		@1				SUBQ.L		#1,D0				MOVE.L		D0,FV_OUT@1				RTSBACKSPACE	; ( -- )				BSR			CURSOR_LEFT				BSR			TIO_BLANK				BSR			CURSOR_LEFT				RTSP_EXPECT	; ( addr max -- , input string of characters)				MOVE.L			D6,-(A7)		save old				MOVE.L			(A6)+,D6		countdown in D6				MOVE.L			D6,FV_SPAN	@1		; ( -- addr )				TST.L			D6				done if max hit				BLE.S			@2				BSR				KEY				( addr char -- )				MOVE.L			(A6)+,D0				CMP.B			#$08,D0			is it a backspace?				BNE.S			@notbs			skip if not				MOVE.L			FV_SPAN,D0		check limit				CMP.L			D6,D0			at beginning?				BEQ.S			@1				then just ignore it				ADDQ.L			#1,D6			bump index				POP				A0				adjust address				SUBQ.L			#1,A0				PUSH			A0				BSR				BACKSPACE				BRA.S			@1@notbs			POP				A0				( -- , not a backspace )				MOVE.B			D0,(A0)+				PUSH			A0				SUBQ.L			#1,D6;				BLE.S			@2				CMP.B			#EOL_CHAR,D0				BEQ.S			@2				PUSH			D0				BSR				EMIT				BRA.S			@1@2				SUB.L			D6,FV_SPAN				MOVE.L			(A6)+,A0				MOVE.L			(A7)+,D6				RTS				**************************************************************************		  	Numeric Output												**************************************************************************DIG2ASC	; ( n -- char , convert to 0-9/A-> representation )				POP				D0				ADD.L			#'0',D0				CMP.L			#'9',D0				BLE.S			@1				ADD.L			#'A'-'9'-1,D0@1				PUSH			D0				RTSN2TEXT ; ( N -- addr count, output hex representation )* D1 = numeric holder* A0 = pointer to number builder* D3 = count of chars				MOVE.L			D3,-(A7)				BSR				PAD				POP				A0				POP				D1				CLR.L			D3				TST.L			D1				BNE.S			@1				MOVE.B			#'0',-(A0)				MOVE.B			#1,D3				BRA.S			@2*@1				MOVE.L			D1,D0				ANDI.L			#$F,D0				PUSH			D0				BSR				DIG2ASC				POP				D0				MOVE.B			D0,-(A0)				ADDQ.L			#1,D3				LSR.L			#4,D1				TST.L			D1				BNE.S			@1*@2				PUSH			A0				PUSH			D3				MOVE.L			(A7)+,D3				RTS				DOTHEX ; ( N -- , print in hex )				BSR				N2TEXT				BSR				TYPE				BSR				SPACE				RTS				DEPTH	; ( -- depth )				MOVE.L			FV_S_ZERO,A0				SUBA.L			A6,A0			num bytes				MOVE.L			A0,D0				ASR.L			#2,D0			num cells				PUSH			D0				RTSDOTS_STR		DC.B			'Stack> 'DOTS	; ( a b c ... -- , print stack contents )				MOVE.L			D3,-(A7)		; save D3				BSR				CR				LEA				DOTS_STR,A0		; print 'STACK>'				MOVE.L			A0,-(A6)				BSR				COUNT				BSR				TYPE				BSR 			DEPTH			; get stack depth				POP				D3				ASL.L			#2,D3			; number of bytes on stack@1				TST.L			D3				BLE.S			@2				MOVE.L			-4(A6,D3.L),D0				PUSH			D0				BSR				DOT				SUBQ.L			#4,D3				BRA.S			@1@2				BSR				CR				MOVE.L			(A7)+,D3				RTS				DUMPROW	; ( addr -- , dump one row )				M_DUP				BSR DOTHEX				MOVE.L			D3,-(A7)				MOVE.L			#$0F,D3@1				M_DUP				BSR				CFETCH				BSR				DOTHEX				BSR				ONEPLUS				DBRA			D3,@1				M_DROP				BSR				CR				MOVE.L			(A7)+,D3				RTS				DUMP	; ( addr count -- , dump data )* A2 = address* D3 = count				MOVEM.L			D3/A2,-(A7)				BSR				CR				POP				D3				POP				A2				ASR.L			#4,D3		divide by 16@1				PUSH			A2				BSR				DUMPROW				ADDA.L			#$10,A2				DBRA			D3,@1				MOVEM.L			(A7)+,D3/A2				RTS				TOUPPER	; ( char -- char' , convert to upper case )				POP				D0				CMP.B			#'a',D0				BLT.S			@1				SUB.B			#'a'-'A',D0@1				PUSH			D0				RTS**************************************************************************		Error Handling and Checking										**************************************************************************DEBUG			_Debugger				RTS				MAYDEBUG		MOVE.L			FV_IF_DEBUG,D0				BEQ.S			@1				_Debugger@1				RTSQ_COMP_STR		DC.B			'Compile Mode Only!!'Q_COMP		; ( -- , check state )				MOVE.L			FV_STATE,D0				BNE.S			@no_error				LEA				Q_COMP_STR,A0				BSR				MSG_ABORT@no_error		RTSQ_PAIRS_STR		DC.B			'Mismatched Conditionals'Q_PAIRS		; ( marker1 marker2 -- , check match )				CMPM.L			(A6)+,(A6)+				BEQ.S			@no_error				LEA				Q_PAIRS_STR,A0				BSR				MSG_ABORT@no_error		RTS				MSG_OUT		; ( addr:A0 , write string from A0 )				MOVE.L			A0,-(DSP)				BSR				COUNT				BSR				TYPE				RTSWHERE_STR		DC.B			'While compiling: 'WHEREBAD	; ( -- , give message if aborted in a colon def )				MOVE.L			FV_STATE,D0				BEQ.S			@no_msg				LEA				WHERE_STR,A0				BSR				MSG_OUT				MOVE.L			FV_CURRENT,A0		LATEST				MOVE.B			(A0)+,D0				ANDI.L			#$1F,D0				limit to 31 chars				PUSH			A0				PUSH			D0				BSR				TYPE				ID.				BSR				CR@no_msg			RTS				ABORT_STR		DC.B			'Forth Aborted!!'P_ABORT				BSR				TO_NEWLINE				LEA				ABORT_STR,A0				BSR				MSG_OUT				BSR				CR				BSR				WHEREBAD				BSR				QUIT				RTSHEX_SIGN		DC.B			' (hex)'				ALIGN			2SHOW_BASE	; ( -- , show base via "hex" or base value )				MOVE.L			FV_BASE,D0				CMP.L			#$0A,D0			; decimal?				BEQ.S			@done				CMP.L			#$10,D0				BEQ.S			@showhex		; hex?  otherwise				PUSH			D0				; save base and make copy to print				PUSH			D0				PUSH			#'('				BSR				EMIT				MOVE.L			#$0A,FV_BASE	; print in decimal				BSR				N2TEXT				BSR				TYPE				PUSH			#')'				BSR				EMIT				POP				FV_BASE			; restore base				BRA.S			@done@showhex		LEA				HEX_SIGN,A0				BSR				MSG_OUT@done			RTS				Prompt			DC.B			' ok'OK			; ( -- )				BSR				CHECK_STACK				LEA				Prompt,A0				MOVE.L			A0,-(A6)				BSR				COUNT				BSR				TYPE				BSR				DEPTH				BSR				DOT				BSR				SHOW_BASE				RTSUNDERFLOWSTR	DC.B			'Stack Underflow!'STACKTOOBIGSTR	DC.B			'Stack/Dictionary Collision!'				ALIGN			2CHECK_STACK		; ( -- )				BSR				DEPTH				POP				D0				BGE.S			@not_under		is depth < 0 ??				BSR				ZERO_SP				LEA				UNDERFLOWSTR,A0				BSR				MSG_ABORT@not_under		BSR				HERE			is SP < DP+1024 ??				POP				D0				MOVE.L			A6,D1				SUB.L			D0,D1				ADD.L			#1024,D1		D1 = SP-DP+1024				BGT.S			@stack_ok				BSR				ZERO_SP				LEA				STACKTOOBIGSTR,A0				BSR				MSG_ABORT@stack_ok		RTSREPORTNAME	; ( $name --- , report as bad )				BSR				COUNT				BSR				TYPE				BSR				SPACE				PUSH			#'?'				BSR				EMIT				BSR				CR				BSR				ABORT				RTS* Message #1ERROR_MSG_1		DC.B			'Could not find 'ERROR_MSG_2		DC.B			'Not a deferred word!'ERROR_MSG_3		DC.B			'Unbalanced Conditionals!'ERROR_MSG_0		DC.B			'Undefined Error!'				ALIGN			2				MSG_ABORT	;  ( msg:A0 -- , type message then abort )				BSR				TO_NEWLINE				BSR				MSG_OUT				BSR				CR				BSR				ABORT				RTSF_ERROR   ; ( error_number -- , report error and abort )				POP				D0		; number				CMP.L			#1,D0				BNE.S			@2				LEA				ERROR_MSG_1,A0				BSR				MSG_OUT				BSR				HERE				BSR				REPORTNAME*@2				CMP.L			#2,D0				BNE.S			@3				LEA				ERROR_MSG_2,A0				BSR				MSG_ABORT*@3				CMP.L			#3,D0				BNE.S			@4				LEA				ERROR_MSG_3,A0				BSR				MSG_ABORT*@4				LEA				ERROR_MSG_0,A0				BSR				MSG_ABORT				RTS				Q_ERROR   ; ( flag error_number -- , report error and abort if true )				BSR				SWAP				POP				D1				BEQ.S			@ok				BSR				F_ERROR				RTS@ok				M_DROP				RTS				**************************************************************************		Parsing and Compiler support									**************************************************************************SCAN	;	( addr len char --- addr len' , scan for a character)* If  char is a blank, also look for EOL $0D and TAB $09* A0 = addr = address to search -- address found at or end+1* D0 = len  = number of characters to search* D1 = char = character to search for* D2 = char = character from string to compare with				MOVE.L			D2,-(A7)				POP				D1				POP				D0				BEQ.S			@done			0 length input string ?				POP				A0* Scan should include EOL and TAB@begin			MOVE.B			(A0)+,D2		get next char				CMP.B			D1,D2			compare with input				BEQ.S			@foundit				CMP.B			#EOL_CHAR,D2	EOL ?				BEQ.S			@foundit				CMP.B			#$20,D1			if BL check for TAB too				BNE.S			@notblank				CMP.B			#TAB_CHAR,D2				BEQ.S			@foundit@notblank		SUBQ.L			#1,D0			decr and loop				BGT.S			@begin* didn't find it, return end+1 and 0				PUSH			A0				BRA.S			@done* found char@foundit		SUB.L			#1,A0			already past char from post inc				PUSH			A0@done			PUSH			D0				MOVE.L			(A7)+,D2				RTS				SKIP	;	( addr len char --- addr' len' , skip leading characters)* Terminate if EOL* A0 = addr = address to search -- address found at or end+1* D0 = len  = number of characters to search* D1 = char = character to skip				MOVE.L			D2,-(A7)				POP				D1				POP				D0				BEQ.S			@done				0 length input				POP				A0@begin			MOVE.B			(A0)+,D2			get char				CMP.B			D1,D2				BNE.S			@mismatch				CMP.B			#EOL_CHAR,D2				BEQ.S			@foundone				BRA.S			@notblank@mismatch		CMP.B			#$20,D1				BNE.S			@foundone			not blank so don't need to test for TAB				CMP.B			#TAB_CHAR,D2				BNE.S			@foundone			really not a white space@notblank		SUBQ.L			#1,D0				BGT.S			@begin* didn't find it, return end+1 and 0				PUSH			A0				BRA.S			@done				@foundone		SUB.L			#1,A0		already past char from post inc				PUSH			A0@done			PUSH			D0				MOVE.L			(A7)+,D2				RTS				* -------------------------------------------------------BL		; ( --- space-char )				PUSH			#32				RTS				WORD	;	( char --- addr )* Leave a blank after word at HERE* A2 = starting address* D3 = char* D4 = starting count				MOVEM.L			D3-D4/A2,-(A7)				POP				D3				get delimiting character				LEA				TIB,A0			get TIB				MOVE.L			FV_TO_IN,D0				ADD.L			D0,A0			point to current char				MOVE.L			FV_NUMTIB,D4					SUB.L			D0,D4			calc # chars left in TIB				BGT.S			@charsleft		zero out here if none left				MOVE.L			#0,D4			in case negative chars left				BRA.S			@buildhere@charsleft		PUSH			A0				addr				PUSH			D4				len				PUSH			D3				char				BSR				SKIP			( -- addr' len' )				MOVE.L			(A6),D4				MOVE.L			$4(A6),A2		save starting address				PUSH			D3				scan for next occurence of char or EOL				BSR				SCAN			( --- addr' len' )* Update >IN* D4 = chars left in string including the word				POP				D0				MOVE.L			FV_NUMTIB,D1				SUB.L			D0,D1				ADDQ.L			#1,D1			advance >in past delimiter				MOVE.L			D1,FV_TO_IN				SUB.L			D0,D4			count of chars in word				M_DROP* Copy word to HERE* D4 = Count* A2 = Address of 1st Char of string to move@buildhere		BSR				P_HERE						POP				A0				MOVE.B			D4,(A0)+		set count				BLE.S			@end				SUBQ.L			#1,D4			setup loop counter				CLR.L			D0				@nextc			MOVE.B			(A2)+,D0		get next char				CMP.B			#'a',D0			is it lower case?				BLT.S			@move				CMP.B			#'z',D0				BGT.S			@move				SUB.B			#'a'-'A',D0		convert to UPPER CASE@move			MOVE.B			D0,(A0)+		place char				DBRA			D4,@nextc				MOVE.B			#$20,(A0)+		pad with blank				* build stack@end			BSR				P_HERE				MOVEM.L			(A7)+,D3-D4/A2				RTS								HNUMBERQ	; ( $addr --- d true | false )* Convert hexadecimal string at addr to number* D0 = accumulator* D4 = counter* D3 = char holder* A0 = string pointer				MOVEM.L			D3-D4,-(A7)				MOVE.L			#-1,FV_DPL			for single precision				CLR.L			D0				CLR.L			D4				CLR.L			D3*				MOVE.L			FV_BASE,D1				POP				A0				MOVE.B			(A0)+,D4				BEQ.S			@false				SUBQ.L			#1,D4@next			MOVE.B			(A0)+,D3		get next char				SUB.B			#'0',D3				BLT.S			@false			some kind of punctuation				CMP.B			#9,D3			hex type digit				BLE.S			@1				SUB.B			#'A'-'0'-10,D3				CMP.B			#$10,D3				BGE.S			@false				CMP.B			#$9,D3				BLE.S			@false@1				ASL.L			#4,D0				ADD.L			D3,D0				DBRA			D4,@next				PUSH			D0				PUSH			#0				PUSH			#-1				MOVEM.L			(A7)+,D3-D4				RTS@false			PUSH #0				MOVEM.L			(A7)+,D3-D4				RTS				STRMOVE		; ( $addr addr --- )				POP				A1				POP				A0				CLR.L			D0				MOVE.B			(A0),D0				BEQ.S			@done@1				MOVE.B			(A0)+,(A1)+				DBRA			D0,@1@done				RTSP_QUERY		; ( -- , READ INTO TIB )				LEA				TIB,A0				PUSH			A0				PUSH			#TIBSize				BSR				EXPECT				MOVE.L			FV_SPAN,FV_NUMTIB				MOVE.L			#0,FV_TO_IN				MOVE.L			#0,FV_AT_EOF				RTS				FQUERY		; ( -- , Read from File into TIB )				LEA				TIB,A0				PUSH			A0				PUSH			#TIBSize				BSR				FEXPECT				MOVE.L			FV_FSPAN,FV_NUMTIB				MOVE.L			#0,FV_TO_IN				MOVE.L			FV_ECHO,D0				BEQ.S			@done				LEA				TIB,A0				PUSH			A0				PUSH			FV_NUMTIB				BSR				TYPE				BSR				CR@done			RTS            EXECUTE		; ( cfa - )				POP				A0				JSR				(A0)	FWORDEND	EXECUTEMATCHNFAS	; ( nfa1 nfa2 -- true-if-equal )				POP				A0				POP				A1				MOVE.B			(A0)+,D0				ANDI.L			#$1F,D0				MOVE.B			(A1)+,D1				ANDI.L			#$1F,D1				CMP.L			D0,D1				BNE.S			@nomatch				TST.L			D0				BEQ.S			@nomatch				SUBQ.L			#1,D0@1				CMPM.B			(A0)+,(A1)+				DBNE			D0,@1				BNE.S			@nomatch				PUSH			#-1				RTS@nomatch		PUSH			#0				RTS				NEXTNAME	; ( nfa -- previous_nfa , traverse dictionary )				POP				A0				SUBA.L			#$A,A0			to link field				MOVE.L			(A0),D0			relative nfa				BEQ.S			@zero				ADD.L			FV_HDRSBASE,D0			absolute nfa				PUSH			D0				RTS@zero			PUSH			D0				RTS				NFA2LFA	; ( nfa -- lfa , convert )				POP				A0				SUBA.L			#$A,A0			to link field				PUSH			A0	FWORDEND	NFA2LFA	NFA2SFA	; ( nfa -- sfa , convert to size field byte )				POP				A0				SUBA.L			#$2,A0			to link field				PUSH			A0	FWORDEND	NFA2SFA	NFA2FFA	; ( nfa -- ffa , convert to flag field byte )				POP				A0				SUBA.L			#$1,A0			to link field				PUSH			A0	FWORDEND	NFA2FFA				NFA2CFA		; ( nfa -- cfa , find executable code address from name )				POP				A0				SUBA.L			#6,A0				MOVE.L			(A0),A0			relative cfa				ADDA.L			BASE_REG,A0			absolute cfa				PUSH			A0	FWORDEND	NFA2CFA				P_FINDNFA		; ( addr -- nfa_imm 1 | nfa -1 | addr false )				MOVE.L			FV_CONTEXT,A0				PUSH			A0			( -- addr  nfa )@1				BSR				DDUP				BSR				MATCHNFAS	( -- addr nfa flag )				POP				D0				BEQ.S			@2			keep looking				M_DUP				BSR				Q_SMUDGED	( -- addr nfa flag )				POP				D0				BEQ.S			@match		not smudged@2				BSR				NEXTNAME	( addr next_nfa )				M_DUP				POP				D0				BNE.S			@1@giveup			RTS@match			BSR				NIP			( - nfa )				M_DUP				BSR				Q_IMMEDIATE				POP				D0			-1 if immediate, 0 if not				BEQ				@notimm				MOVE.L			#1,-(a6)	; return 1 if immediate , 00001				RTS@notimm			MOVE.L			#-1,-(A6)	; return -1 if NOT immediate				RTSP_SMUDGE		; ( -- , hide latest word defined )				MOVE.L			FV_CURRENT,A0		latest				SUBA.L			#2,A0				nfa->ffa				ORI.W			#FLAG_SMUDGED,(A0)				RTS				P_UNSMUDGE		; ( -- , reveal latest word defined )				MOVE.L			FV_CURRENT,A0		latest				SUBA.L			#2,A0				nfa->ffa				ANDI.W			#~FLAG_SMUDGED,(A0)				RTS				P_FIND		; ( $name -- cfa -1 | cfa_imm 1 | $name false )				BSR				FINDNFA				POP				D0				BEQ.S			@not				BSR				NFA2CFA		 does not change D0@not			PUSH			D0				RTSWCOMMA		;	( w --- , place word in dictionary )				MOVE.L			FV_DP,A0				POP				D0				MOVE.W			D0,(A0)+				MOVE.L			A0,FV_DP				RTS				COMMA		;	( w --- , place word in dictionary )				MOVE.L			FV_DP,A0				MOVE.L			(A6)+,(A0)+				MOVE.L			A0,FV_DP				BSR				CHECK_STACK				RTS				ALLOT		; ( n -- , allot n bytes in dict )				MOVE.L			FV_DP,A0				POP				D0				ADD.L			D0,A0				MOVE.L			A0,FV_DP				BSR				CHECK_STACK				RTS				* Compiler SupportTICK		;	( <word> --- cfa )				PUSH			#32				BSR				WORD				BSR				P_FIND				POP				D0				BNE.S			@good				BSR				REPORTNAME@good			RTSTICKN		;	( <word> --- nfa )				PUSH			#32				BSR				WORD				BSR				FINDNFA				POP				D0				BNE.S			@good				BSR				REPORTNAME@good			RTSADDORGPUSH	; ( -- address , used internally by ALITERAL )				ADDA.L			A4,A0				PUSH			A0	FWORDEND	ADDORGPUSH				ALITERAL	;	( address -- , compile reference to that address )* Determine which register to reference off of, A3 or A4 or PC relative.				MOVE.L			FV_STATE,D0				BEQ				@done			; don't touch if interpreting				POP				D0				MOVE.L			D0,D1				SUB.L			BASE_REG,D1				BLE				@out				CMP.L			#$8000,D1				BGE.S			@usea3				PUSH			#$41EC			LEA		$x(A4)				BRA.S			@finish@usea3			CMP.L			#$18000,D1				BGE.S			@usebsr				SUB.L			#$10000,D1				PUSH			#$41EB			LEA		$x(A3)				BRA.S			@finish@usebsr			MOVE.L			D1,A0			save it for long				MOVE.L			FV_DP,D0				SUB.L			BASE_REG,D0		HERE USE->REL				SUB.L			D0,D1			Relative branch value				SUBQ.L			#2,D1				CMP.L			#$FFFF8000,D1				BLE.S			@longref				PUSH			#$41FA			LEA		$x(PC)@finish			BSR				WCOMMA				PUSH			D1				BSR				WCOMMA				PUSH			#2				; size of A0_PUSH				LEA				A0_FETCH,A0					PUSH			A0				BSR				COMPILE_INLINE	; allow tail optimization				RTS@longref		MOVE.L			A0,D1			Slow ref for worst case.				PUSH			#$207C			MOVE.L	#rel,A0				BSR				WCOMMA				PUSH			D1				BSR				COMMA				PUSH			#4				; size of ADDORGPUSH				LEA				ADDORGPUSH,A0					PUSH			A0				BSR				COMPILE_INLINE	; allow tail optimization@done			RTS@out			LEA				MSG_TOO_FAR,A0				BSR				MSG_ABORT				RTSCALLCOMMA	;	( cfa -- , compile call to that word )* Determine which register to jump off of, A3 or A4.				POP				D0				MOVE.L			D0,D1				SUB.L			BASE_REG,D1				BLE.S			@out				CMP.L			#$8000,D1				BGE.S			@usea3				PUSH			#$4EAC			JSR		$x(A4)				BRA.S			@finish@usea3			CMP.L			#$18000,D1				BGE.S			@usebsr				SUB.L			#$10000,D1				PUSH			#$4EAB			JSR		$x(A3)				BRA.S			@finish@usebsr			MOVE.L			D1,A0			save it for long				MOVE.L			FV_DP,D0				SUB.L			BASE_REG,D0		HERE USE->REL				SUB.L			D0,D1			Relative branch value				SUBQ.L			#2,D1				CMP.L			#$FFFF8000,D1				BLE.S			@longjump				PUSH			#$6100			BSR@finish			BSR				WCOMMA				PUSH			D1				BSR				WCOMMA				RTS@longjump		MOVE.L			A0,D1			Slow JSR for worst case. See DOES_PLACE kludge.				PUSH			#$203C			MOVE.L	#rel,D0				BSR				WCOMMA				PUSH			D1				BSR				COMMA				PUSH			#$4EB40800		JSR		$0(A4,D0.L)				BSR				COMMA				RTS@out			LEA				MSG_TOO_FAR,A0				BSR				MSG_ABORT				RTSMSG_TOO_FAR		DC.B			'Attempt to CALL outside dictionary.'P_COMPILE_INLINE	; ( size cfa -- , compile an inline call )				BSR				P_HERE				BSR				ROT			; ( cfa here size )				M_DUP						; ( cfa here size size )				BSR				ALLOT		; ( cfa oldhere size )				BSR				F_CMOVE		; copy code inline				RTS				P_COMPILE_NFA_INLINE	; ( size nfa -- , compile an inline call using NFA )				BSR				NFA2CFA				BSR				P_COMPILE_INLINE				RTSP_NFACALL		; ( nfa -- , compile call either inline or JSR )				M_DUP				BSR				Q_INLINE				POP				D0				BEQ.S			@callit				M_DUP						( -- nfa nfa )  Compile INLINE				BSR				NFA2SFA				BSR				CFETCH		( -- nfa size )				BSR				SWAP		( -- size nfa )				BSR				COMPILE_NFA_INLINE				RTS@callit			BSR				NFA2CFA			; compile with JSR				BSR				CALLCOMMA				RTS* These two words must be followed by a word offset inline.BRANCH		;	( -- , branch for conditionals )				DC.W			$6000		force long branch	FWORDEND	BRANCHZERO_BRANCH	;	( flag -- , branch if 0 )				POP				D0				DC.W			$6700		ASM didn't like to do long branch	FWORDEND	ZERO_BRANCH* Support for DO LOOPPQ_DO		; (?DO)  ( limit start -- , skip DO LOOP  if at limit)				MOVE.L			(RP)+,A0			Save return address				MOVEM.L			ILOOP-JLOOP,-(RP)				MOVE.L			(A6)+,ILOOP				MOVE.L			(A6)+,JLOOP				CMP.L			ILOOP,JLOOP				BLE.S			@skipit				ADD.L			#$80000000,JLOOP				SUB.L			JLOOP,ILOOP				JMP				(A0)@skipit			MOVEM.L			(RP)+,ILOOP-JLOOP				ADDA.L			D0,A0				JMP				(A0)				RTS				* Support for -DO +LOOPP_DO		; (DO)  ( limit start -- , always execute )				MOVE.L			(RP)+,A0			Save return address				MOVEM.L			ILOOP-JLOOP,-(RP)				MOVE.L			(A6)+,ILOOP				MOVE.L			(A6)+,JLOOP				ADD.L			#$80000000,JLOOP				SUB.L			JLOOP,ILOOP				JMP				(A0)				RTS		; redundant								PLOOP		; (LOOP)    ( -- , increment counter, check for past limit )				ADDQ.L			#1,ILOOP				BVC				@dummy         Leave blank for resolve@dummy			MOVEM.L			(RP)+,ILOOP-JLOOP	FWORDEND	PLOOP	PPLUSLOOP		; (+LOOP)    ( N -- , restore indices from return stack )				ADD.L			(A6)+,ILOOP				BVC				@dummy         Leave blank for resolve@dummy			MOVEM.L			(RP)+,ILOOP-JLOOP	FWORDEND	PPLUSLOOPI_DO		;  I  ( -- index , do loop index )				MOVE.L			ILOOP,D0				ADD.L			JLOOP,D0				PUSH			D0	FWORDEND	I_DOJ_DO		;  J  ( -- index , outer do loop index )				MOVE.L			$4(RP),D0				ADD.L			(RP),D0				PUSH			D0	FWORDEND	J_DOPLEAVE		;  LEAVE ( -- )				MOVEM.L			(RP)+,ILOOP-JLOOP				DC.L			$60000000         ;  BRA	*+0	FWORDEND	PLEAVEF_BOUNDS		;  BOUNDS  ( addr count -- lim first , set up for DO LOOP )				POP				D0				MOVE.L			(DSP),D1				ADD.L			D0,(DSP)				PUSH			D1				RTSCHECK_REDEFS  ; ( name -- , print message if redefined )				MOVE.L			FV_REDEFSQ,D0				BEQ				@dontlook	; dont look if REDEFS? false				M_DUP				BSR				FIND				POP				D0				BEQ.S			@newone				M_DROP						; don't need CFA				BSR				COUNT		; print name				BSR				TYPE				LEA				MSG_REDEF,A0				BSR				MSG_OUT				BSR				CR				RTS@newone			M_DROP@dontlook		M_DROP				RTS				MSG_REDEF		DC.B			' redefined!'P_HERE		;	( -- addr )				PUSH			FV_DP				RTSPAD			;	( -- addr )				MOVE.L			FV_DP,A0				ADD.L			#$80,A0				PUSH			A0	FWORDEND	PAD				P_CREATE		; (CREATE) ( <word> --- , build header )* Align dictionary Pointer				MOVE.L			FV_DP,D0				ANDI.B			#1,D0				BEQ				@1				ADD.L			#1,FV_DP@1				PUSH			#32				BSR				WORD			get name and leave at HERE				BSR				P_STRING_CREATE				RTS				P_STRING_CREATE   ; ( $NAME -- , create entry in dictionary, no code )				M_DUP				BSR				CHECK_REDEFS	is it already defined				MOVE.L			FV_HDRSBASE,A1				MOVE.L			FV_CURRENT,A0				SUB.L			A1,A0			calculate relative link value				MOVE.L			FV_NEXTLINK,A1				MOVE.L			A0,(A1)+		lay down link field				MOVE.L			FV_DP,A0		get HERE as address of next CFA				SUB.L			BASE_REG,A0				MOVE.L			A0,(A1)+		initial cfa value				MOVE.W			#0,(A1)+		initial flag				MOVE.L			A1,FV_CURRENT				MOVE.L			A1,FV_CONTEXT				PUSH			A1				BSR				STRMOVE			copy name from word				MOVE.L			FV_CURRENT,A0				CLR.L			D0				MOVE.B			(A0),D0			get string length				ADDQ.B			#2,D0				ANDI.B			#$3E,D0			force to even number				ADD.L			D0,A0			calculate new next link				MOVE.L			A0,FV_NEXTLINK				RTS* Template used to make code field of a CREATE wordCREATE_CODE ; ( -- addr , code to push address )				LEA				CREATE_DATA,A0				PUSH			A0DOES_PLACE		RTS						overwrite with optional call to DOES code				RTS				RTS				RTS				RTS						; call could be as much as 5 words!!!!				RTSCREATE_DATA		DC.L			0		where data would go if usedCREATE  ; ( <name> -- )				BSR				COLON_CREATE			create header				LEA				CREATE_CODE,A0				PUSH			A0				BSR				HERE				PUSH			#CREATE_DATA-CREATE_CODE				BSR				F_CMOVE			copy "create code"				PUSH			#CREATE_DATA-CREATE_CODE				BSR				ALLOT			allot space				RTS* Compile Time:   IMMEDIATE*		Compile call to (DOES)*		Compile RTS to terminate CREATE CodeDOES	; ( -- )				LEA				PDOES,A0				PUSH			A0				BSR				CALLCOMMA		call (DOES)				PUSH			#$4E75				BSR				WCOMMA			compile RTS				RTS				* *****************************************************************LATEST    ; ( -- nfa , of previous or current definition )				MOVE.L			FV_CURRENT,-(A6)				RTS				* Patch last CREATE construction to call DOES code* Return stack has address of RTS before DOES codePDOES			BSR				HERE			save HERE				BSR 			LATEST				BSR				NFA2CFA			cfa of new word				POP				A0				ADDA.L			#DOES_PLACE-CREATE_CODE,A0	offset to DOES call place				MOVE.L			A0,FV_DP		set DP to DOES place				MOVE.L			(A7),A0			address of RTS before DOES code				ADDA.L			#2,A0			add 2 bytes for RTS				PUSH			A0				BSR				CALLCOMMA		compile call				BSR				DP				BSR				STORE			restore DP				RTS				LITERAL   ;  ( N -- , compile call to this number if state is on, use MOVEQ if possible )				TST.L			FV_STATE				BEQ.S			@done				MOVE.L			(A6),D0				CMP.L			#127,D0				BGT.S			@slowform				CMP.L			#(-128),D0				BLT.S			@slowform				M_DROP				ANDI.L			#$FF,D0			; mask off low byte				ORI.W			#$7000,D0		; or with MOVEQ	#x,D0				PUSH			D0				BSR				WCOMMA			; compile MOVEQ				PUSH			#2				LEA				D0_FETCH,A0				PUSH			A0				BSR				COMPILE_INLINE	; for optimizer				BRA.S			@done@slowform		PUSH			#$2D3C 		; push opcode				BSR				WCOMMA		; compile it				BSR				COMMA@done			RTSDLITERAL  ; ( D -- , compile double number )				TST.L			FV_STATE				BEQ.S			@done				BSR				SWAP				BSR				LITERAL				BSR				LITERAL@done			RTS				RIGHT_BRACKET   ;  ( -- , ] start compile )				MOVE.L			#-1,FV_STATE				RTSLEFT_BRACKET   ; ( -- , [ stop compiling )				MOVE.L			#0,FV_STATE				RTSCOLON				BSR				COLON_CREATE				BSR				SMUDGE			hide until compilation done				BSR				RIGHT_BRACKET				RTS				SEMICOLON				BSR				Q_COMP			; ?COMP				PUSH			#$4E75			; compile EXIT				BSR				WCOMMA				BSR				LEFT_BRACKET				BSR				UNSMUDGE				BSR				CHECK_STACK				RTS				MACRO				CHECK_FLAG		&name	; ( nfa -- true | false )Q_&name			BSR				NFA2FFA				BSR				CFETCH				POP				D0				ANDI.L			#FLAG_&name,D0				BEQ.S			@not				PUSH			#-1				RTS@not			PUSH			#0				RTS				ENDM				CHECK_FLAG		IMMEDIATE				CHECK_FLAG		INLINE				CHECK_FLAG		HEAD				CHECK_FLAG		TAIL				CHECK_FLAG		SMUDGEDINTERPRET	; ( -- , interpret input string )@1				MOVE.L			FV_TO_IN,D0		check to see if any left				MOVE.L			FV_NUMTIB,D1				CMP.L			D0,D1				BEQ.S			@3				PUSH			#32				BSR				WORD			get next word				M_DUP				BSR				CFETCH			length = 0?				POP				D0				BEQ.S			@4				BSR				FINDNFA			look up in dict				POP				D0				BEQ.S			@notfound		not found?* This was changed when -1/1 changed in FINDNFA , 00001				BGT.S			@exec			If +1 then it is immediate so execute it,* found word, not immediate, compile or execute				MOVE.L			FV_STATE,D0		compiling?				BEQ.S			@exec* compile reference				BSR				NFACALL			otherwise compile a reference.				BRA.S			@1@exec			BSR				NFA2CFA				BSR				EXECUTE			do it				BRA.S			@1* Try to interpret it some other way using a deferred word.@notfound		M_DUP				BSR				RECOGNIZE		try to recognize this as something else				POP				D0				BEQ.S			@notrec				M_DROP							was OK, carry on				BRA.S			@1* Try to convert to a number@notrec			M_DUP				BSR				NUMBERQ				POP				D0				BEQ.S			@bad				BSR				ROT				M_DROP							get rid of name				TST.L			FV_DPL			is it double precision				BGE.S			@double				M_DROP							single precision				BSR				LITERAL				BRA.S			@1@double			BSR				DLITERAL				BRA.S			@1* Report as an error@bad			BSR				REPORTNAME@3				RTS@4				M_DROP				RTSP_QUIT			BSR				RestoreRetStack				BSR				ResetForth				BSR				CLEANUP_FILE				BSR				TIO_UPDATE@loop							BSR				ARROW_CURSOR				BSR				QUERY				BSR				SPACE				BSR				INTERPRET				MOVE.L			FV_STATE,D0				BNE.S			@1				BSR				OK@1				BSR				CR				MOVE.L			ifquit,D0				BEQ.S			@loop				BSR				BYE				RTS								this won't execute				BYE		; ( -- , stop execution, return to Finder ); Set flag so that the next time we try to BYE we won't call UserTerm; This is so that if UserTerm crashes and Quits, we can still get out; the second time.				TST.L			TRIED_TO_BYE				BNE.S			@1				MOVE.L			#-1,TRIED_TO_BYE				BSR				UserTerm@1				BSR				RestoreRetStack				BSR				CLEANUP_FILE				RTS				**************************************************************************		Defer															**************************************************************************				MACRO				FDEFER			&name,&value				EXPORT			(&name) : CODE&name			MOVE.L			@vector,A0				ADD.L			BASE_REG,A0			convert to absolute				JMP				(A0)				save a return@vector			DC.L			&value-CodeBase		place for execution address				ENDM				FDEFER			EMIT,P_EMIT				FDEFER			KEY,P_KEY				FDEFER			TYPE,P_TYPE				FDEFER			PAUSE_TASK,F_NOOP				FDEFER			CR,P_CR				FDEFER			DOT,DOTHEX				FDEFER			QUIT,P_QUIT				FDEFER			NUMBERQ,HNUMBERQ				FDEFER			QTERMINAL,P_QTERMINAL				FDEFER			FIND,P_FIND				FDEFER			FINDNFA,P_FINDNFA				FDEFER			SMUDGE,P_SMUDGE				FDEFER			UNSMUDGE,P_UNSMUDGE				FDEFER			EXPECT,P_EXPECT				FDEFER			QUERY,P_QUERY				FDEFER			COLON_CREATE,P_CREATE				FDEFER			UserInit,F_NOOP				FDEFER			UserApplication,F_NOOP				FDEFER			UserTerm,F_NOOP				FDEFER			STR_FOPEN_VR,P_STR_FOPEN_VR				FDEFER			ABORT,P_ABORT				FDEFER			STR_INCLUDE_VR,P_STR_INCLUDE_VR				FDEFER			EDIT_INCLUDE,F_NOOP				FDEFER			NFACALL,P_NFACALL				FDEFER			COMPILE_INLINE,P_COMPILE_INLINE				FDEFER			COMPILE_NFA_INLINE,P_COMPILE_NFA_INLINE				FDEFER			HERE,P_HERE				FDEFER			RECOGNIZE,EQUALS0			( nfa -- flag )				FDEFER			KEYLOOP,F_NOOP; defer math functions so can switch for 020				FDEFER			SLASHMOD,P_SLASHMOD_00				FDEFER			USLASH,P_USLASH_00				FDEFER			UTIMES,P_UTIMES_00				FDEFER			MTIMES,P_MTIMES_00				FDEFER			S_TIMES,P_TIMES_00								DEFER_CODE ; ( -- addr , code to push address )				MOVE.L			DEFER_DATA,A0				ADD.L			BASE_REG,A0			convert to absolute				JMP				(A0)				save a returnDEFER_DATA		DC.L			0		            place for execution address				DEFER  ; ( <name> -- , define a deferred word )				BSR				COLON_CREATE			create header				LEA				DEFER_CODE,A0				PUSH			A0				BSR				HERE				PUSH			#DEFER_DATA-DEFER_CODE				BSR				F_CMOVE			copy "create code"				PUSH			#DEFER_DATA-DEFER_CODE				BSR				ALLOT			allot space				LEA				QUIT,A0				SUB.L			BASE_REG,A0				PUSH			A0				BSR				COMMA				RTSTO_IS	; ( cfa -- addr_vector , convert deferred cfa )				POP				D0				ADD.L			#DEFER_DATA-DEFER_CODE,D0				PUSH			D0				RTS				F_NOOP		; ( -- , do nothing )				RTS				F_EXIT		; ( -- RTS )				RTS	FWORDEND	F_EXIT**************************************************************************		Cursor Changing													**************************************************************************WATCH_CURSOR				MOVE.L			#0,-(a7)				MOVE.W			#4,-(a7)				_GetCursor						; TRAP				MOVE.L			(a7),A0			dereference handle				MOVE.L			(a0),(a7)				_SetCursor						; TRAP				RTSIBEAM_CURSOR				MOVE.L			#0,-(a7)				MOVE.W			#1,-(a7)				_GetCursor						; TRAP				MOVE.L			(a7),A0				MOVE.L			(a0),(a7)				_SetCursor						; TRAP				RTSARROW_CURSOR				_InitCursor						; TRAP				RTS**************************************************************************		File I/O & INCLUDE												*************************************************************************** Hooks to FileIO segment to allow normal dictionary referencing.				FCONSTANT		OFFSET_BEGINNING,fsFromStart				FCONSTANT		OFFSET_END,fsFromLEOF				FCONSTANT		OFFSET_CURRENT,fsFromMarkSTR_FOPEN		PUSH			#0				BSR				STR_FOPEN_VR				RTSFOPEN			PUSH			#$20				BSR				WORD				BSR				STR_FOPEN				RTSCLOSEFILE		JSR				SEG_CLOSEFILE				RTSFCLOSE			JSR				SEG_FCLOSE				RTSFFLUSH			JSR				SEG_FFLUSH				RTSFLUSHVOL		JSR				SEG_FLUSHVOL				RTSFWRITE			JSR				SEG_FWRITE				RTSFREAD			JSR				SEG_FREAD				RTSFSEEK			JSR				SEG_FSEEK				RTSFTRUNCATE		JSR				SEG_FTRUNCATE				RTSFREWIND			JSR				SEG_FREWIND				RTSFEXPECT			JSR				SEG_FEXPECT				RTSSTR_FCREATE_VR	JSR				SEG_STR_FCREATE_VR				RTSP_STR_FOPEN_VR	JSR				SEG_STR_FOPEN_VR				RTSSTR_FCREATE		JSR				SEG_STR_FCREATE				RTSSTR_FSETVOL_VR	JSR				SEG_STR_FSETVOL_VR				RTSSTR_FDELETE_VR	JSR				SEG_STR_FDELETE_VR				RTSF_SFGETFILEP	JSR				SEG_SFGETFILEP				RTS* ------------------------------------------------------------------CLEANUP_FILE	; ( -- , close source file if left open )				TST.L			FV_FSOURCE				BEQ.S			@1				skip if zero fileid				PUSH			FV_FSOURCE				BSR				FCLOSE				CLR.L			FV_FSOURCE@1				RTS				MSG_INCLUDE		DC.B			' File could not be opened! 'SAVE_NAME_VR		; ( $filename vrefnum -- )* Save FileName and vRefNum for ReInclude				MOVE.L			(A6)+,last_vRefNum* Copy filename to last_FileName buffer				MOVE.L			(A6),A0					addr of name of string				MOVE.B			(A0),D1					length of string				ANDI.L			#$7F,D1					clip to 127				ADDQ.L			#1,D1					include count byte				LEA				last_FileName,A1				PUSH			A1				PUSH			D1						( -- $name &lfn count )				BSR				F_CMOVE				RTSMSG_BAD_STATE	DC.B			'Left in compile mode - missing ';'???'CHECK_COMP		; ( -- , check state )				MOVE.L			FV_STATE,D0				BEQ.S			@no_error				LEA				MSG_BAD_STATE,A0				BSR				MSG_ABORT@no_error		RTSLOAD_NAME_VR		; ( $filename vrefnum -- , load from file )				BSR				STR_FOPEN_VR			open file				POP				D0				MOVE.L			D0,FV_FSOURCE			set include source				BEQ.S			@nogood* Enable Menu Item				MOVE.L			inclMenuH,-(A7)				MOVE.W			#ReIncludeCommand,-(A7)				_EnableItem						; TRAP				BSR				WATCH_CURSOR* Load em up...@start			BSR				FQUERY				MOVE.L			FV_AT_EOF,D0				BNE.S			@finish				BSR				INTERPRET				BRA.S			@start@finish			BSR				CLEANUP_FILE				BSR				CHECK_STACK				BSR				CHECK_COMP				RTS*@nogood			BSR				CR				LEA				MSG_INCLUDE,A0				BSR				MSG_ABORT				RTSP_STR_INCLUDE_VR	; ( $filename vrefnum -- )				BSR				DDUP				BSR				SAVE_NAME_VR				BSR				LOAD_NAME_VR				RTSMSG_DONE_INC	DC.B			'Compilation Finished.'MSG_GET_INC		DC.B			'Include: 'RE_INCLUDE		; ( -- , include same file as before )				BSR				CR* Echo file about to be loaded.				LEA				last_FileName,A0				BSR				MSG_OUT				BSR				SPACE				PUSH			last_vRefNum				BSR				DOT				BSR				CR*				LEA				last_FileName,A0				PUSH			A0				PUSH			last_vRefNum				BSR				LOAD_NAME_VR				LEA				MSG_DONE_INC,A0				BSR				MSG_OUT				BSR				CR				BSR				ARROW_CURSOR				RTS				GET_INCLUDE		; ( -- , include using Standard Open File Dialog )				LEA				MSG_GET_INC,A0				PUSH			A0				BSR				F_SFGETFILEP				POP				D0				BEQ.S			@cancel				BSR				STR_INCLUDE_VR				LEA				MSG_DONE_INC,A0				BSR				MSG_OUT				BSR				CR				BSR				ARROW_CURSOR@cancel			BSR				TIO_UPDATE				RTSSTR_INCLUDE		; ( $filename -- )				PUSH			#0				BSR				STR_INCLUDE_VR				RTS				F_INCLUDE   ;  ( <filename> -- , compile file )				PUSH			#$20				BSR				WORD				BSR				STR_INCLUDE				RTS					* ---------------------------------------------------------------------* Used only during initialization if not loaded from data fork.GET_HeadersBase  ;	( -- HeadersBase , get base address of name fields)				LEA				HeadersBase,A0				PUSH			A0				RTSGET_NEXTLINK  ;	( -- nextlink , get base address of name fields)				LEA				HeadersBase,A0				LEA			Next_Header-HeadersBase,A1   Kludge to get far addr.				ADDA.L			A1,A0				PUSH			A0				RTS				ENDP* ---------------------------------------------------------------------								include 		'math.a'	; arithmetic support				H4THDICT		PROC			EXPORT				EXPORT			StartDict : CODEStartDict		DS.L			FREE_CODE_SPACE/4				ENDP* Forth Names Module* Put Names in Separate segmentH4THNAMES		PROC			EXPORT				EXPORT			( HeadersBase , Next_Header ) : CODE* ------------------------------------------------------------------				* Headers for Forth Dictionary* Header Structure*	Bytes		Contents*	4			LFA, Backwards Link Field to Previous NFA, Relative to HeadersBase*	4			Pointer to Code, Relative to CodeBase*	1			Size*	1			Flags*	even		NFA, Counted Name*	Flags Needed*		I - 1 = Immediate*		S - 1 = Smudged*		H - 1 = Head Optimizable*		T - 1 = Tail Optimizable*		M - 1 = Macro expand function&previous_nfw	SETA		&ORD(*)HeadersBase		DS.L		1		base of name segment* macro for building Forth Headers				MACRO				NFW			&name,&code,&flags				IMPORT		(&code) : CODE				GBLA		&previous_nfw				GBLA		&latest				LCLA		&flagval				DC.L		&previous_nfw-HeadersBase				DC.L		&code-CodeBase&flagval		SETA		0				IF	&POS('I',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_IMMEDIATE				ENDIF				IF	&POS('S',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_SMUDGED				ENDIF				IF	&POS('H',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_HEAD				ENDIF				IF	&POS('T',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_TAIL				ENDIF				IF	&POS('M',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_INLINE				ENDIF				DC.W		&flagval&previous_nfw	SETA		&ORD(*)					DC.B		&name				ENDM				* for INLINE words				MACRO				INFW		&name,&code,&flags				IMPORT		(&code , END_&code) : CODE				GBLA		&previous_nfw				GBLA		&latest				LCLA		&flagval				DC.L		&previous_nfw-HeadersBase				DC.L		&code-CodeBase&flagval		SETA		0				IF	&POS('I',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_IMMEDIATE				ENDIF				IF	&POS('S',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_SMUDGED				ENDIF				IF	&POS('H',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_HEAD				ENDIF				IF	&POS('T',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_TAIL				ENDIF&flagval		SETA		&flagval|16		; automatically set flags				DC.B		END_&code-&code				DC.B		&flagval&previous_nfw	SETA		&ORD(*)					DC.B		&name				ENDM								MACRO				NFWS		&name,&flags ; same name as label				IMPORT		(&name) : CODE				GBLA		&previous_nfw				GBLA		&latest				LCLA		&flagval				DC.L		&previous_nfw-HeadersBase				DC.L		&name-CodeBase&flagval		SETA		0				IF	&POS('I',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_IMMEDIATE				ENDIF				IF	&POS('S',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_SMUDGED				ENDIF				IF	&POS('H',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_HEAD				ENDIF				IF	&POS('T',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_TAIL				ENDIF				IF	&POS('M',&flags)>0 THEN&flagval		SETA		&flagval|FLAG_INLINE				ENDIF				DC.W		&flagval&previous_nfw	SETA		&ORD(*)					DC.B		'&name'				ENDM				* Macro for getting last nfa				MACRO				GETLATEST				GBLA		&previous_nfw				DC.L		&previous_nfw				ENDM				* Build Header for each Forth word* Stack Manipulation				INFW		'DUP',DUP				INFW		'?DUP',Q_DUP				INFW		'-DUP',Q_DUP				INFW		'DROP',DROP				INFW		'OVER',OVER				NFWS		ROT				NFW			'-ROT',MINUS_ROT				INFW		'SWAP',SWAP,'T'				NFWS		TUCK				INFW		'NIP',NIP				NFW			'D@',DFETCH				NFW			'D!',DSTORE				NFW			'2@',DFETCH ; alias				NFW			'2!',DSTORE				NFWS		DDROP				NFWS		DDUP				NFWS		DSWAP				NFWS		DOVER				NFW			'2DROP',DDROP				NFW			'2DUP',DDUP				NFW			'2SWAP',DSWAP				NFW			'2OVER',DOVER				NFW			'0SP',ZERO_SP				INFW		'SP@',SP_FETCH				INFW		'SP!',SP_STORE				NFWS		DEPTH				INFW		'PICK',PICK,'H'				NFW			'S0',S_ZERO				NFWS		XDROP* ODE Support				NFWS		OSSTACKPTR				NFW			'OS.PUSH',OS_PUSH				INFW		'OS.DROP',OS_DROP				INFW		'OS.COPY',OS_COPY,'T'				INFW		'OS+',OS_PLUS,'HT'				NFW			'OS+PUSH',OS_PLUS_PUSH,'H'				* Call Support				INFW		'D0!',D0_STORE,'H'				INFW		'D0@',D0_FETCH,'T'				INFW		'A0!',A0_STORE,'H'				INFW		'A0@',A0_FETCH,'T'				INFW		'A1!',A1_STORE				INFW		'A1@',A1_FETCH				* Return Stack				INFW		'>R',TO_R				INFW		'R>',R_FROM				INFW		'0>R',ZERO_TO_R				INFW		'R@',R_FETCH				INFW		'W>R',WTO_R				INFW		'WR>',WR_FROM				INFW		'0W>R',ZERO_WTO_R				INFW		'WR@',WR_FETCH				INFW		'RDROP',R_DROP				INFW		'RP@',RP_FETCH				INFW		'RP!',RP_STORE				NFW			'R0',R_ZERO				NFW			'X>R',X_TO_R				NFW			'XR>',X_R_FROM* Memory				NFW			'CMOVE',F_CMOVE				NFW			'CMOVE>',F_CMOVEB				NFW			'FILL',F_FILL				INFW		'@',FETCH,'H'				INFW		'!',STORE,'H'				INFW		'W@',WFETCH,'HT'				INFW		'W!',WSTORE,'H'				INFW		'C@',CFETCH,'HT'				NFW			'C!',CSTORE				INFW		'ON',F_ON,'H'				INFW		'OFF',F_OFF,'H'* Output				NFW			'.S',DOTS				NFW			'DUMP',DUMP				NFW			'.',DOT				NFW			'.HEX',DOTHEX				NFWS		CR,CR				NFW			'(CR)',P_CR* Control				NFW			'BYE',BYE				NFWS		ABORT				NFW			'(QUIT)',P_QUIT				NFWS		QUIT				NFW			'?STACK',CHECK_STACK				NFWS		USERINIT				NFWS		USERAPPLICATION				NFWS		USERTERM				NFW			'NOOP',F_NOOP,'I'				INFW		'EXIT',F_EXIT				NFW			'?ERROR',Q_ERROR				NFW			'ERROR',F_ERROR				* I/O				NFW			'KEY',KEY				NFW			'(KEY)',P_KEY				NFWS		KEYLOOP				NFW			'EMIT',EMIT				NFW			'(EMIT)',P_EMIT				NFW			'TYPE',TYPE				NFW			'(TYPE)',P_TYPE				NFW			'>NEWLINE',TO_NEWLINE				NFW			'COUNT',COUNT				NFW			'PAUSE',PAUSE_TASK				NFW			'$MOVE',STRMOVE				NFW			'.(',DOT_PAREN				NFWS		BACKSPACE				NFW			'CLS',TIO_CLS				NFW			'ADJUST.SCREEN',TIO_ADJUST				NFW			'UPDATE.SCREEN',TIO_UPDATE				NFW			'BL',BL				NFW			'(?TERMINAL)',P_QTERMINAL				NFW			'?TERMINAL',QTERMINAL				NFW			'(EXPECT)',P_EXPECT				NFW			'EXPECT',EXPECT				NFW			'#COLS',NUM_COLUMNS				NFW			'LAST-EVENT',LAST_EVENT				NFW			'WHICH-WINDOW',WHICH_WINDOW				NFWS		MAIN_WINDOW				NFW			'WHICH-PART',WHICH_PART				NFW			'EVENT-HANDLERS',EVENT_HANDLERS				NFW			'WINDOW-HANDLERS',WINDOW_HANDLERS				NFW			'MENU-HANDLERS',MENU_HANDLERS				NFW			'CURSOR.OFF',TIO_CURSOR_OFF				NFW			'CURSOR.ON',TIO_CURSOR_ON				NFW			'FLASH.CURSOR',FLASH_CURSOR				NFW			'IBEAM.CURSOR',IBEAM_CURSOR				NFW			'WATCH.CURSOR',WATCH_CURSOR				NFW			'ARROW.CURSOR',ARROW_CURSOR				* Editing I/O Support				NFW			'TIO.BACKWARDS',TIO_BACKWARDS				NFW			'TIO.FORWARDS',TIO_FORWARDS				NFW			'TIO.ERASE.EOL',TIO_ERASE_EOL				NFW			'TIO.INSERT',TIO_INSERT				NFW			'TIO.DELETE',TIO_DELETE* File I/O				NFW			'$FOPEN',STR_FOPEN				NFWS		FOPEN				NFW			'$FOPEN_VR',STR_FOPEN_VR				NFW			'($FOPEN_VR)',P_STR_FOPEN_VR				NFW			'$INCLUDE',STR_INCLUDE				NFW			'INCLUDE',F_INCLUDE				NFW			'($INCLUDE_VR)',P_STR_INCLUDE_VR				NFW			'$INCLUDE_VR',STR_INCLUDE_VR				NFW			'INCLUDE.EDIT',EDIT_INCLUDE				NFWS		FREAD				NFWS		FWRITE				NFWS		FCLOSE				NFWS		FSEEK				NFWS		FTRUNCATE				NFWS		FFLUSH				NFWS		FLUSHVOL				NFWS		FEXPECT				NFWS		FQUERY				NFWS		GOTOXY				NFWS		OFFSET_BEGINNING				NFWS		OFFSET_END				NFWS		OFFSET_CURRENT				NFW			'$FCREATE_VR',STR_FCREATE_VR				NFW			'$FCREATE',STR_FCREATE				NFW			'$FSETVOL_VR',STR_FSETVOL_VR				NFW			'$FDELETE_VR',STR_FDELETE_VR				NFW			'SFGETFILEP',F_SFGETFILEP* Variables				NFW			'>IN',TO_IN				NFW			'#TIB',NUMTIB				NFWS		OUT				NFWS		CONTEXT				NFWS		CURRENT				NFWS		NEXTLINK				NFWS		SPAN				NFWS		DP				NFWS		BASE				NFWS		FERROR				NFWS		FSPAN				NFWS		FSOURCE				NFW			'AT-EOF',AT_EOF				NFWS		ECHO				NFW			'TIB',ADDR_TIB				NFWS		SPARE				NFWS		IFMULTI				NFWS		KEYSLEEP				NFW			'FILE-TYPE',FILETYPE				NFW			'FILE-CREATOR',FILECREATOR				NFWS		UPDATE_FUNC				NFW			'REDEFS?',REDEFSQ				NFWS		DPL				* Variables used by Loader				NFW			'CODE-PTR',CODE_PTR				NFW			'CODE-SIZE',CODE_SIZE				NFW			'CODE-LIMIT',CODE_LIMIT				NFW			'HEADERS-PTR',HEADERS_PTR				NFW			'HEADERS-SIZE',HEADERS_SIZE				NFW			'HEADERS-LIMIT',HEADERS_LIMIT				NFW		'IF-QUIT',SYSV_IFQUIT				NFW		'IF-KEY',SYSV_IFKEY				NFW		'KEY-HOLDER',SYSV_KEYHOLDER				NFW		'APPLEMENUH',SYSV_AppleMenuH				NFW		'FILEMENUH',SYSV_FileMenuH				NFW		'EDITMENUH',SYSV_EditMenuH				NFW		'LOAD-STATUS',SYSV_loadStatus*				NFW		'LINE-HEIGHT',SYSV_LINE_HEIGHT*				NFW		'LINE-DESCENT',SYSV_LINE_DESCENT*				NFW		'CHAR-WIDTH',SYSV_CHAR_WIDTH* Compiler						NFW			'WORD',WORD				NFWS		SKIP				NFWS		SCAN				NFW			'W,',WCOMMA				NFW			',',COMMA				NFW			'CALL,',CALLCOMMA				NFW			'(COMPILE_INLINE)',P_COMPILE_INLINE				NFW			'(COMPILE_NFA_INLINE)',P_COMPILE_NFA_INLINE				NFWS		COMPILE_INLINE				NFWS		COMPILE_NFA_INLINE				NFW			'NFACALL,',NFACALL				NFW			'(NFACALL,)',P_NFACALL				NFW			'''',TICK				NFW			'''N',TICKN				NFW			'(FIND)',P_FIND				NFWS		FIND				NFW			'(FINDNFA)',P_FINDNFA				NFWS		FINDNFA				NFW			'MATCH.NFAS',MATCHNFAS				NFW			'CODEBASE',GET_CODEBASE				NFW			'HEADERS-BASE',HDRSBASE				INFW			'EXECUTE',EXECUTE,'H'				NFWS		HERE				NFW			'(HERE)',P_HERE				INFW		'PAD',PAD,'T'				NFW			'ALLOT',ALLOT				INFW		'NFA->CFA',NFA2CFA,'HT'				INFW		'NFA->LFA',NFA2LFA,'HT'				INFW		'NFA->SFA',NFA2SFA,'HT'				INFW		'NFA->FFA',NFA2FFA,'HT'				NFW			'NAME>',NFA2CFA				NFW			'N>LINK',NFA2LFA				NFW			':CREATE',COLON_CREATE				NFW			'(CREATE)',P_CREATE				NFW			'($CREATE)',P_STRING_CREATE				NFW			'CREATE',CREATE				NFW			'DOES>',DOES,'I'				NFWS		DEFER				NFW			'>IS',TO_IS				NFW			';',SEMICOLON,'I'				NFW			':',COLON				NFW			'STATE',STATE				NFW			'IMMEDIATE?',Q_IMMEDIATE				NFWS		QUERY				NFW			'(QUERY)',P_QUERY				NFWS		LITERAL,'I'				NFWS		DLITERAL,'I'				NFWS		ALITERAL,'I'				NFW			'[',LEFT_BRACKET,'I'				NFW			']',RIGHT_BRACKET				NFWS		LATEST				INFW		'BRANCH',BRANCH				INFW		'0BRANCH',ZERO_BRANCH				NFW			'?COMP',Q_COMP				NFW			'?PAIRS',Q_PAIRS				INFW		'USE->REL',USE_TO_REL,'HT'				INFW		'REL->USE',REL_TO_USE,'HT'				NFW			'(?DO)',PQ_DO				NFW			'(DO)',P_DO				INFW		'(LOOP)',PLOOP				INFW		'(+LOOP)',PPLUSLOOP				INFW		'I',I_DO,'T'				INFW		'J',J_DO,'T'				NFW			'BOUNDS',F_BOUNDS				INFW		'(LEAVE)',PLEAVE				NFW			'HNUMBER?',HNUMBERQ				NFW			'NUMBER?',NUMBERQ				NFW			'(SMUDGE)',P_SMUDGE				NFW			'(UNSMUDGE)',P_UNSMUDGE				NFWS		SMUDGE				NFWS		UNSMUDGE				NFWS		INTERPRET				NFWS		RECOGNIZE				* Test words				NFW			'DEBUGGER()',DEBUG				NFWS		MAYDEBUG				NFW			'IF-DEBUG',IF_DEBUG				* MIDI Manager Support words				NFW			'SNDDISPVERSION()',F_SNDDISPVERSION				NFWS		DEBUGMIDIREADHOOK				NFWS		MIDIREADHOOK				NFWS		MIDIECHOHOOK* ADD NEW ONES HERE !!!!* Comparison Operators				NFW			'=',EQUALS				NFW			'<>',NOT_EQUALS				NFW			'>',GREATER_THAN				NFW			'<',LESS_THAN				NFW			'>=',GREATER_EQUAL				NFW			'<=',LESS_EQUAL				NFW			'U>',UGREATER_THAN				NFW			'U<',ULESS_THAN				NFW			'0=',EQUALS0				NFW			'0<>',NOT_EQUALS0				NFW			'0>',GREATER_THAN0				NFW			'0<',LESS_THAN0				NFW			'0>=',GREATER_EQUAL0				NFW			'0<=',LESS_EQUAL0								NFWS		BETWEEN				NFWS		WITHIN* Logical Operators				INFW		'AND',L_AND,'H'				INFW		'OR',L_OR,'H'				INFW		'XOR',L_XOR,'H'				NFW			'NOT',F_NOT* Arithmetic				INFW		'+',PLUS,'H'				INFW		'-',MINUS,'H'				INFW		'NEGATE',NEGATE				NFW			'+-',PLUSMINUS				INFW		'W*',MULTIPLY,'HT'				NFW			'UM/MOD',USLASH; these are deferred				NFW			'/MOD',SLASHMOD				NFW			'U/',USLASH				NFW			'U*',UTIMES				NFW			'M*',MTIMES				NFW			'*',S_TIMES								NFW			'(/MOD_00)',P_SLASHMOD_00				NFW			'(U/_00)',P_USLASH_00				NFW			'(U*_00)',P_UTIMES_00				NFW			'(M*_00)',P_MTIMES_00				NFW			'(*_00)',P_TIMES_00								NFW			'(/MOD_20)',P_SLASHMOD_20				NFW			'(M/_20)',P_MSLASH_20				NFW			'(U/_20)',P_USLASH_20				NFW			'(U*_20)',P_UTIMES_20				NFW			'(M*_20)',P_MTIMES_20				NFW			'(*_20)',P_TIMES_20								INFW		'ABS',ABS_VALUE,'HT'				NFW			'W/',DIVIDE				INFW		'+!',PLUS_STORE,'H'				NFWS		MIN				NFWS		MAX				INFW		'+SHIFT',PLUS_SHIFT,'H'				INFW		'-SHIFT',MINUS_SHIFT,'H'				NFWS		SHIFT				NFWS		ASHIFT				INFW		'B->S',BYTE_EXTEND,'HT'				INFW		'W->S',WORD_EXTEND,'HT'				NFW			'S_>D',S_TO_D,				INFW		'2+',TWOPLUS				INFW		'2*',TWOTIMES,'HT'				INFW		'2/',TWOSLASH				INFW		'U2/',UTWOSLASH,'HT'*				NFW			'U2*',UTWOTIMES				NFW			'D2*',DTWOTIMES*				NFW			'D2/',DTWOSLASH				NFW			'DU2*',DUTWOTIMES				NFW			'DU2/',DUTWOSLASH				INFW		'DNEGATE',DNEGATE				NFW			'DABS',F_DABS				NFW			'D+',DPLUS				NFW			'D-',DMINUS				INFW		'2-',TWOMINUS				INFW		'4+',FOURPLUS				INFW		'4*',FOURTIMES,'HT'				INFW		'4/',FOURSLASH,'HT'				INFW		'4-',FOURMINUS				INFW		'CELL+',FOURPLUS				INFW		'CELL*',FOURTIMES				INFW		'CELLS',FOURTIMES,'HT'				INFW		'CELL/',FOURSLASH,'HT'				INFW		'CELL-',FOURMINUS				INFW		'1-',ONEMINUS				 INFW		'1+',ONEPLUS   ; must use 1+ for last word, KLUDGE for next_nfa* DON'T ADD ANYTHING HERE OR H4TH WON'T WORK !!!!!!!!!!!!!!!!Next_Header		DS.L		FREE_HDRS_SPACE/4		room for a few names				ENDP								END 			;				of Sample