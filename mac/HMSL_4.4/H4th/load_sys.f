cr .( Compile H4th system words in High Level Forth) cr: ::::H4TH:LOAD_SYS.F ;	CREATE TASK-LOAD_SYS.F 0 ,: IMMEDIATE    latest nfa->ffa dup c@ 1 OR	swap c!;: (   29 word drop ; immediate( That was the definition for the comment word. ): \ ( <line> -- , comment out rest of line )    0D word drop; immediate\ *********************************************************************\ * HMSL Forth System                                                 *\ * Author: Phil Burk                                                 *\ * Copyright 1989 Phil Burk , All Rights Reserved                    *\ *********************************************************************\ 00001 9/25/91 Added -DO and DVARIABLE\ 00002 9/14/92 Fix lword, now skips leading blanks\ These should be in kernal: 3DUP  ( a b c -- a b c a b c )	2 pick 2 pick 2 pick;10 base !  ( hexadecimal )\ Define Math Operators: / ( n d -- n/d )	/mod nip;: MU/MOD  ( d n -- n-rem d-quotient , returns double quotient )    >r 0 r@ u/	r> swap >r	u/ r>;: UM* M*  ( miserable kludge %Q );: MOD ( n d -- r , calc modulus )	/mod drop;: SYSDUMP ( -- , dump system parameters )	CR    SPAN @ . CR	STATE @ . CR	TIB #TIB @ TYPE CR	FSOURCE @ . CR;\ : 0CR   cr  0 out ! ; \ do we need this?: RPICK   ( n -- r[n] )	1+ cells  rp@ + @ ;: BIT-CLR?  ( n1 bit# -- flag )  1 swap +shift and 0=     ;: BIT-SET?  ( n1 bit# -- flag )  bit-clr? 0=  ;: ? ( addr -- , print contents )	@ .;: NameBase  ( -- base-of-names )	Headers-Base @;( Compiler support , based on FIG )( 'n is currently not state-smart but it soon will be ): [COMPILE]  ( <name> -- , compile now even if immediate )    'n nfacall,;  IMMEDIATE: (COMPILE)  ( rel_nfa -- , compile call )	namebase + nfacall,;: COMPILE  ( <name> -- , save NFA and compile later )    'n namebase - ( make nfa relocatable )	[compile] literal	( store relative nfa of word to be compiled )	[ 'n (compile) namebase - ] literal   \ compile call to (compile)	(compile); IMMEDIATE( Conditionals in '83 form): CONDITIONAL_KEY ( -- , lazy constant ) 7351 ;: ?CONDITION   ( f -- )  conditional_key - 3 ?error ;: >MARK      ( -- addr )   here 0 w,   ;  ( 16 bit !! ): >RESOLVE   ( addr -- )   here over - swap w!  ;  ( %S ): <MARK      ( -- addr )   here  ;: <RESOLVE   ( addr -- )   here - w,  ;  ( %S ): ?>MARK      ( -- f addr )   conditional_key >mark  ;: ?>RESOLVE   ( f addr -- )   swap ?condition  >resolve  ;: ?<MARK      ( -- f addr )   conditional_key <mark  ;: ?<RESOLVE   ( f addr -- )   swap ?condition  <resolve  ;: BEGIN    ?<mark   ; immediate: AGAIN    compile branch  ?<resolve   ; immediate: UNTIL    compile 0branch ?<resolve   ; immediate: IF       compile 0branch ?>mark      ; immediate: THEN     ?>resolve  ; immediate: ELSE     compile branch  ?>mark  2swap  ?>resolve  ; immediate: WHILE    [compile]  if  ; immediate: REPEAT   2swap  [compile] again  [compile] then  ; immediate\ A few words for JForth compatibility -----------------------: >FIG-FLAG ( FLAG --- FIG-FLAG-1-OR-0 )  IF 1 ELSE 0 THEN ;: >REL  ( adr -- adr )  ; immediate: >ABS  ( adr -- adr )  ; immediate: FIG-VAR  ( n -- , define a preset variable like FIG )	create ,;\ Store and Fetch relocatable code addresses. ---------------: IF.USE->REL  ( use -- rel , preserve zero )	dup IF use->rel THEN;: IF.REL->USE  ( rel -- use , preserve zero )	dup IF rel->use THEN;: A!  ( dictionary_address addr -- )    >r if.use->rel r> !;: A@  ( addr -- dictionary_address )    @ if.rel->use;: A, ( dictionary_address -- )    if.use->rel ,;\ Elementary data structures.: CONSTANT  ( n <name -- )    CREATE , IMMEDIATE	DOES> @ state @		IF [compile] literal		THEN;: VARIABLE  ( <name> -- )    CREATE 0 , IMMEDIATE	DOES> [compile] aliteral;: DVARIABLE	CREATE 0 , 0 , IMMEDIATE	DOES> [compile] aliteral;variable HASH-DAMAGED    \ set whenever dictionary is changed, eg. FORGET0 constant FALSE0 1- constant TRUE1 cell* constant CELL\ Stack data structure ----------------------------------------\ This is a general purpose stack utility used to implement necessary\ stacks for the compiler or the user.  Not real fast.\ These stacks grow up which is different then normal.\   cell 0 - stack pointer, offset from pfa of word\   cell 1 - limit for range checking\   cell 2 - first data location: :STACK   ( #cells -- )    CREATE  2 cells ,	( offset of first data location )		dup ,			( limit for range checking, not currently used )		cell* cell+ allot  ( allot an extra cell for safety );: >STACK  ( n stack -- , push onto stack, postincrement )	dup @ 2dup cell+ swap ! ( -- n stack offset )	+ !;: STACK>  ( stack -- n , pop , predecrement )	dup @ cell- 2dup swap !	+ @;: STACK@ ( stack -- n , copy )	dup @ cell- + @ ;: 0STACKP  ( stack -- , clear stack)    8 swap !;20 :stack ustackustack 0stackp\ Define JForth like words.: >US ustack >stack ;: US> ustack stack> ;: US@ ustack stack@ ;: 0USP ustack 0stackp ;\ DO LOOP ------------------------------------------------3 constant do_flag4 constant leave_flag5 constant ?do_flag: DO    ( -- , loop-back do_flag jump-from ?do_flag  , on user stack )   ?comp   ( leave address to set for forward branch )	203C w, here 0 ,  ( move.l  #$0,D0  )	compile  (?do)	here >us do_flag  >us  ( for backward branch )	>us ( for forward branch ) ?do_flag >us; immediate: -DO    ( -- , loop-back do_flag jump-from ?do_flag )   ?comp	compile  (do)	here >us do_flag  >us  ( for backward branch ); immediate: LEAVE  ( -- addr leave_flag )	here 6 + >us	compile (leave)	leave_flag >us; immediate: LOOP-FORWARD  ( -us- jump-from ?do_flag -- )	BEGIN us@ leave_flag = us@ ?do_flag = or	WHILE us> leave_flag =		IF	us> here over - swap w!		ELSE us> dup 8 + here swap - swap !		THEN	REPEAT;: LOOP-BACK  (  loop-addr do_flag -us- )	us> do_flag ?pairs	us> here - 6 + here 6 - w!;: LOOP    ( -- , loop-back do_flag jump-from ?do_flag )   compile  (loop)   loop-forward loop-back; immediate: +LOOP    ( -- , loop-back do_flag jump-from ?do_flag )   compile  (+loop)   loop-forward loop-back; immediate: SPACE  bl emit ;: SPACES  200 min 0 DO space LOOP ;\ -----------------------------------------------------------\ Dictionary support.: PREVNAME  ( nfa -- previous_nfa | 0 )    n>link @ dup	IF NameBase +	THEN;: EVEN-UP  ( n -- n | n+1 , make even )	dup 1 and +;: N>NEXTLINK  ( nfa -- nextlink , traverses name field )	dup c@ 1F and 1+ even-up +;create TESTPFAtestpfa ' testpfa - constant PFA-CFA: >BODY   ( cfa -- pfa )    pfa-cfa +;: BODY>   ( cfa -- pfa )    pfa-cfa -;: [']  ( <name> -- cfa , define compile time tick )	?comp ' [compile] aliteral; immediate: NameBase+   ( rnfa -- nfa , convert relocatable nfa to actual )	namebase +;: 'N  ( <name> -- , make 'n state smart )    'n	state @	IF	namebase - ( make nfa relocatable )		[compile] literal	( store nfa of word to be compiled )		compile namebase+	THEN; IMMEDIATE: '  ( <name> -- cfa , state sensitive ' )	'  	state @ 	IF [compile] aliteral 	THEN; immediate: 'C  ( <name> -- cfa , state sensitive ' )	[compile] '; immediate: ID.   ( nfa -- )    count 1f and type;\ Support for DEFER --------------------: CHECK.DEFER  ( cfa -- , abort if not a deferred word by comparing to type )    @ ['] type @ - 2 ?error;: (IS)  ( cfa_do cfa_deferred -- )	>is a!;: IS  ( cfa <name> -- , act like normal IS )	bl word find 0= 1 ?error	dup check.defer 	state @	IF [compile] aliteral compile (is)	ELSE (is)	THEN; immediate: (WHAT'S)  ( cfa_deferred -- cfa_do )	>is a@;: WHAT'S  ( <name> -- cfa , act like normal IS )	bl word FIND 0= 1 ?error	dup check.defer	state @	IF [compile] aliteral compile (what's)	ELSE (what's)	THEN; immediate\ --------------------------------------- more math, deferreddefer M/: (M/_00) ( d1 n1 -- rem quo , %Q reexamine, is this right?)	over >r >r dabs	r@ abs u/	r> r@ xor +-	swap r> +- swap;' (m/_00) is M/: */MOD  ( n1 n2 n3 -- rem quo )    >r m* r> m/;: */ ( n1 n2 n3 -- n1*n2/n3 )	*/mod nip;\ ---------------------------------------\ Parsing support: MOVE  ( src dest count -- , move proper direction )	-rot 2dup u<	IF rot cmove>	ELSE rot cmove	THEN;: /STRING   ( addr len n -- addr' len' )   over min  rot over   +  -rot  -;: PLACE   ( addr len to -- , move string )   3dup  1+  swap move  c! drop;: (SOURCE)   ( -- addr len )\   blk @ ?dup  if  block b/buf  else  tib #tib @  then	tib #tib @;defer source' (SOURCE) is SOURCE: PARSE-WORD   ( char -- addr len )   >r  source tuck >in @ /string  r@ skip over swap r> scan   >r  over -  rot r>  dup 0<> + - >in !;: PARSE   ( char -- addr len )   >r  source >in @  /string  over swap  r> scan   >r  over -  dup r> 0<>  -  >in +!;: LWORD  ( char -- addr )	parse-word here place here \ 00002 , use PARSE-WORD;: ASCII ( <char> -- char )    bl parse drop c@	state @	IF [compile] literal	THEN; immediate\ ------------------------------------------------------------\ Number input.: DIGIT   ( char base -- n true | char false )	>r dup dup ascii A 1- >	IF ascii A - ascii 9 + 1+	ELSE ( char char )		dup ascii 9 >		IF			( between 9 and A is bad )			drop 0 ( trigger error below )		THEN	THEN	ascii 0 -	dup r> <	IF dup 1+ 0>		IF nip true		ELSE drop FALSE		THEN	ELSE drop FALSE	THEN;: DOUBLE?   ( -- f )   dpl @ 1+ 0<>  ;: CONVERT   ( ud1 addr1 -- ud2 addr2 )	BEGIN  1+ dup >r  c@ base @ digit	WHILE  swap  base @ um* drop rot  base @ um* d+		double?		IF  1 dpl +!		THEN  r>	REPEAT  drop  r>;create NUM-PAD 32 allot: ((NUMBER?))   ( $addr -- d f )	dup c@ 30 <	IF	num-pad $move		BL num-pad count + c!		num-pad	THEN	0 0 rot  ( 0 0 $addr )\ check for '-' at beginning	dup 1+ c@ ascii - =  dup >r	IF ( 0 0 $addr )  1+	THEN	dpl on	BEGIN   convert dup c@ dup ascii , ascii . between	WHILE   ascii . =		IF	dpl off \ double precision		THEN	REPEAT drop	-rot  r>	IF  dnegate	THEN	rot c@ dup 0= swap BL = or  ( can be blank or zero );: (NUMBER?)   ( addr -- d true | false )\ Is there at least one digit?	false  over count bounds	DO  i c@ base @ digit nip   		IF  drop true leave		THEN	LOOP	IF  ((number?))		IF true		ELSE 2drop false		THEN	ELSE  drop false	THEN;\ : ?missing   (s f -- )\    if  'word count type  true  abort"  ?"  then  ;' (number?) is number?: ?MISSING   ( f -- )   if abort then  ;: NUMBER   ( addr -- d )   number?  not ?missing;\ Number output based on F83variable HLD0 1- constant -10 2- constant -2: hold   ( char -- )   -1 hld  +!  hld @  c!  ;: <#     ( -- )    pad hld ! ;: #>     ( d -- addr len )   2drop  hld @  pad  over -  ;: sign   ( n -- )    0<  if  ascii - hold  then ;: #      ( d -- d )   base @  mu/mod rot 9 over <  if  7 +  then  ascii 0 + hold ;: #s     ( d -- d )   begin  #  2dup or 0= until  ;: decimal    A base !  ;: octal      8 base !  ;: hex       10 base !  ;: binary     2 base !  ;decimal\    number output.: (U.)  ( u -- a l )   0 <# #s #>  ;: U.    ( u -- )   (u.)  type space  ;: U.R   ( u l -- )   >r  (u.)  r> over - spaces  type ;: (.)   ( n -- a l )   dup abs 0 <# #s rot sign #>  ;: NEW.     ( n -- )   (.)  type space  ;' new. is .   ( use new. from now on ): .R    ( n l -- )   >r  (.)  r> over - spaces type  ;: (UD.) ( ud -- a l )   <# #s #>  ;: UD.   ( ud -- )   (ud.)  type space  ;: UD.R  ( ud l -- )   >r  (ud.)  r> over - spaces type  ;: (D.)  ( d -- a l )   tuck dabs <# #s rot sign #>  ;: D.    ( d -- )   (d.)  type space  ;: D.R   ( d l -- )   >r  (d.)  r>  over - spaces  type  ;: EMIT-TO-COLUMN  ( char col -- )	out @ - 0 max 80 min  0	DO dup emit	LOOP drop;: $TYPE  ( $string -- )	count type;: 'word   ( -- addr )   here ;\ : word   ( char -- addr )\   parse-word  'word place  'word dup count + 0 swap  c!  ;: .(   ( -- )   ascii ) parse  type ; immediate\ : (    ( -- )   ascii ) parse  2drop ; immediate: C,      ( c -- )   here c! 1 allot ;: ALIGN   ( -- )     here 1 and  if  0 c,  then  ;: EVEN    ( addr -- addr' )   dup 1 and +  ;: ($")   ( -- $addr , some Forths return addr AND count )	r> dup count + even >r;: (.")  ( -- , type following string )	r> count 2dup + even >r type;: ,"   ( -- )   ascii " parse  tuck 'word place 1+ allot align;: ."   ( <string> -- , type string )	state @	IF	compile (.")  ,"	ELSE ascii " parse type	THEN; immediate: "    ( <string> -- addr , return string address )	state @	IF compile ($")   ,"	ELSE ascii " parse pad place pad	THEN; immediate: (WARNING")  ( flag $message -- )    swap    IF count type    ELSE drop    THEN;: WARNING" ( flag <message> -- , print warning if true. )	[compile] "  ( compile message )	state @	IF  compile (warning")	ELSE (warning")	THEN; IMMEDIATE: (ABORT")  ( flag $message -- )    swap    IF count type cr abort    ELSE drop    THEN;: ABORT" ( flag <message> -- , print warning if true. )	[compile] "  ( compile message )	state @	IF  compile (abort")	ELSE (abort")	THEN; IMMEDIATE: ?PAUSE ( -- , Pause if key hit. )    ?terminal    IF  key drop cr ." Hit space to continue, any other key to abort:"        key dup emit BL = not abort" Terminated"    THEN;: CR?  ( -- , do CR if near end )    OUT @ #cols 16 - 10 max >    IF cr    THEN;: PAGE ( -- , clear screen, compatible with Brodie )	cls;: $ ( <number> -- N , convert next number as hex )    base @ hex    32 word number? 0=    abort" Not a number!"    drop swap base !    state @    IF [compile] literal    THEN; immediate: .HX   ( nibble -- )	dup 9 >	IF    $ 37	ELSE  $ 30	THEN  + emit;: COMP ( n -- 1'comp )    -1 xor;variable TAB-WIDTH  8 TAB-WIDTH !: TAB  ( -- , tab over to next stop )    out @ tab-width @ mod    tab-width @   swap - spaces;\ Vocabulary listing: WORDS  ( -- )    latest    BEGIN  dup 0>	WHILE  dup id. tab cr? ?pause	    prevname	REPEAT drop;variable CLOSEST-NFAvariable CLOSEST-CFA: >NAME  ( addr -- nfa , scans dictionary for closest nfa, SLOW! )	0 closest-nfa !	0 closest-cfa !    latest    BEGIN  dup 0>		IF ( -- addr nfa ) 2dup name> ( addr nfa addr cfa ) <			IF true  ( addr below this cfa, can't be it)			ELSE ( -- addr nfa )				2dup name> ( addr nfa addr cfa ) =				IF ( found it ! ) dup closest-nfa ! false				ELSE dup name> closest-cfa @ >					IF dup closest-nfa ! dup name> closest-cfa !					THEN					true				THEN			THEN		ELSE false		THEN	WHILE  	    prevname	REPEAT ( -- cfa nfa )	2drop	closest-nfa @;: @EXECUTE  ( addr -- , execute if non-zero )	@ ?dup	IF execute	THEN;: A@EXECUTE  ( addr -- , execute if non-zero )	a@ ?dup	IF execute	THEN;: TOLOWER ( char -- char_lower )    dup ascii [ <    IF  dup ascii @ >		IF ascii A - ascii a +		THEN    THEN;\ Forget words in dictionary -----------------------------------: Y/N  ( -- , ask for key )	BEGIN		." (y/n) " key dup emit tolower		dup ascii y = over ascii n = or 0=	WHILE drop cr	REPEAT ascii y =;: Y/N/Q  ( -- true_if_y , ask for key , abort on 'Q')	BEGIN		." (y/n/q) " key dup emit tolower		dup ascii q =		IF cr abort		THEN		dup ascii y = over ascii n = or 0=	WHILE drop cr	REPEAT ascii y =;variable RFENCE    \ relocatable value below which we won't forget: FREEZE  ( -- , protect below here )	here rfence a!;: FORGET.NFA  ( nfa -- , set DP etc. )	dup name> dp !	prevname dup current ! dup context ! n>nextlink nextlink !	hash-damaged on;: VERIFY.FORGET  ( nfa -- , ask for verification if below fence )	dup name> rfence a@ <	IF >newline dup id. ."  is protected!!  Forget Anyway? "  y/n/q cr		IF	dup name> rfence a!			forget.nfa		ELSE drop		THEN	ELSE forget.nfa	THEN;: (FORGET)  ( <name> -- )	BL word findnfa	IF	verify.forget	ELSE ." FORGET - couldn't find " count type cr abort	THEN;variable LAST-FORGET0 last-forget !: IF.FORGOTTEN  ( <name> -- , place links in dictionary without header )	bl word find	IF	here last-forget a@ a,  \ Cell 1 = back link to previous		last-forget a!		a,  ( save CFA )	ELSE ." IF.FORGOTTEN - couldn't find " count type cr abort	THEN;if.forgotten noop: [FORGET]  ( <name> -- , forget then exec forgotten words )	(forget)	last-forget	BEGIN a@ dup 0>		IF dup here >			IF dup cell+ a@execute false			ELSE dup last-forget a! true			THEN		ELSE true		THEN	UNTIL drop;: FORGET ( <name> -- , execute latest [FORGET] )	" [FORGET]" find	IF  execute	ELSE ." FORGET - couldn't find " count type cr abort	THEN;: ANEW  ( <name> -- , forget if defined then redefine )	>in @	bl word find	IF over >in ! forget	THEN drop	>in ! variable;\ --------------------------------- INCLUDE ---------------------\ Support nested INCLUDE CALLS\ We need to save FSOURCE, HERE, LATEST10 constant MAX_INCLUDE_DEPTH\ Need room for 3 entries per file!!!!  See PUSH.INCLmax_include_depth 3 * :stack INCLUDE-STACKinclude-stack 0stackpvariable INCLUDE-DEPTH: PUSH.INCL   ( -- , push include state )	include-depth @ max_include_depth <	IF	fsource @ include-stack >stack		here include-stack >stack		latest include-stack >stack		1 include-depth +!	ELSE ." INCLUDE nested too deeply!" cr abort	THEN;: POP.INCL  ( -- old-latest old-here, pop include state )	>in off	include-stack stack> ( old-latest )	include-stack stack> ( old-here )	include-stack stack> fsource !	-1 include-depth +!;: ROOM@  ( -- room  , left in dictionary )	code-limit @ here -;: CLEAN.INCL  ( -- , clean up include files )	include-depth @ 0	DO	cr include-depth @ 4* spaces ." Closing file on error."		fsource @ ?dup   ( close current one )		IF fclose   fsource off		THEN		pop.incl 2drop	( then get next file )	LOOP cr;defer INCL-OLD-QUIT: QUIT.INCL  ( -- )	clean.incl	what's incl-old-quit is quit	quit;\ Compile a ::::filename and ;;;; around code in file for FILE?create FILE?-PAD 64 allot: $APPEND ( addr count $1 -- , append text to $1 )    over >r	dup >r    count +  ( -- a2 c2 end1 )    swap cmove    r> dup c@  ( a1 c1 )    r> + ( -- a1 totalcount )    swap c!;: F?.ADD.:::: ( $name --- file?-pad , make :::: string )	" ::::" file?-pad $move	count 58 min file?-pad $append	file?-pad;: NEW_$INCLUDE_VR  ( $filename vrefnum-- , redefine old one )    state @ abort" Attempt to INCLUDE while compiling!"\\ for FILE?	over f?.add.:::: ($create)\ move filename to HERE+2 because HERE is about to get overwritten	swap here 2+ over c@ 1+ move	here 2+ swap	$ 4e75 w,  \ create ::::filename word\\ Set QUIT to clean up INCLUDE stack, if first file.	include-depth @ 0=	IF	what's quit is incl-old-quit		['] quit.incl is quit	THEN\\ Print messages.	>newline include-depth @ 4* spaces ." Including " over count type cr	push.incl	($include_vr)	>in off  #tib off	pop.incl\	include-depth @ 4* spaces ."      CODE: "	here swap - . ." added, "	room@ . ." left"\	include-depth @ 4* spaces ." ; HEADERS: " 	latest swap - . ." added, "	headers-limit @ latest - . ." left." cr\\ Restore quit when done, if last file.	include-depth @ 0=	IF	what's incl-old-quit is quit	THEN\\ print warning if STATE left on	state @	IF  cr ." WARNING! - still compiling - missing ';' ??" cr	THEN\\ for FILE?	redefs? @ 0 redefs? !	" ;;;;" file?-pad $move	file?-pad ($create) $ 4e75 w,  \ create ;;;; word	redefs? !;' NEW_$INCLUDE_VR is $INCLUDE_VR: INCLUDE? ( <word> <file> -- , load file if word not defined )	32 word find	IF drop 32 word drop  ( eat word from TIB )	ELSE drop include	THEN;include saveforth.f80000 code-size !40000 headers-size !cr .( ENTER:    SAVE-FORTH   BYE  )  cr: ;;;; ;  \ for file?