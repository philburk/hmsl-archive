\ --------------------------ROUND ROBIN PROCESS HANDLER--------------------------\ Authors: Ron Kuivala, Phil Burk\ Based in part on FORMULA by Ron Kuivala and  David Anderson\ Copyright 1991 Ron Kuivala, Phil Burk, David AndersonANEW task-round_robinDoubleList active-process-listDoubleList sleeping-process-listvariable main-process\ The process list will be accessible to interrupts. \ Consequently, mutual exclusion must be guaranteed by masking interrupts\ whenever the list is accessed.\ --------------------------INSERTION&REMOVAL----------------------------: RR.INSERT.PROCESS	( CB -- )	disable.clock.int >r	active-process-list dll.add.tail		\ tie it to the list	r> restore.interrupt;: RR.REMOVE.PROCESS	( CB -- )	disable.clock.int >r	.. cb_node dll.remove	r> restore.interrupt;: ACTIVE->SLEEPING	( CB -- )	disable.clock.int >r	.. cb_node dup dll.remove	sleeping-process-list dll.add.tail		\ tie it to the list	r> restore.interrupt;: SLEEPING->ACTIVE	( CB -- )	disable.clock.int >r	.. cb_node dup dll.remove	active-process-list dll.add.tail		\ tie it to the list	r> restore.interrupt;\ ------Context SwitchIng and Exiting (internal to process)-------------: RR.NEXT.PROCESS  ( -- CB )	who @ .. cb_node dup dll.last?	IF drop active-process-list dll.first	ELSE dll.next	THEN;: PAUSE.SWITCH	( -- ; switch to next process in round robin)	disable.clock.int	rr.next.process who @ <> if 			\ don't switch to self		rr.next.process (mt.switch.to) 	then	restore.interrupt;\ When a process wishes to exit, it placeds its CB in the ZOMBIE variable\ The next process to execute checks the ZOMBIE field, removing the zombie and\ freeing its CB.\ NOTE1: only processes in the active-process list can exit.variable ZOMBIE		\ process that exits cannot free its own CB: ZOMBIFY	( -- ; become a zombie )	who @ zombie ! 	pause.switch							\ control will never return to this process;: ZOMBIFY? ( -- )	who @ ..@ CB_active 0= if			\ should this process end?		who @ main-process @ <> if		\ main process cannot end			zombify		else			-1 who @ ..! CB_active		then	then;	: RR.DELETE.PROCESS	( CB -- )	disable.clock.int >r		dup RR.REMOVE.PROCESS	\ extricate self from RR		mm.free	r> restore.interrupt;: BURY.ZOMBIE ( -- )	zombie @ ?dup if 				\ is there a CB to be freed?		rr.delete.process 		0 zombie ! 	then;: RR.LIFE&DEATH ( -- , ponder lives of processes)	BURY.ZOMBIE					\ look for a zomby, remove if found	zombify?					\ check for own zombie status;: (PAUSE)  ( -- , set PAUSE to this to start multitasking )	pause.switch	rr.life&death;\ -------------------------CREATION&DELETION (external to process)--------	: CREATE.PROCESS	( proc-addr -- CB )	' zombify	mt.new.process 	 				\ allocate a CB, set up its registers	tuck mt.push.rs					\ push procedure address\	' rr.life&death over mt.push.rs	dup dll.node.init				\ clear its links	dup RR.INSERT.PROCESS ;: KILL.PROCESS	( CB --- )	0 swap ..! CB_active;: SHOW.PROCESSES	' . is dll.process.node	>newline	." Active Processes: "	active-process-list dll.scan.list cr	." Sleeping Processes: "	sleeping-process-list dll.scan.list cr;: KILL.ALL.PROCESSES	( -- )	disable.clock.int	eb.reset  \ clear event buffer so that no task will be woken up	restore.interrupt	BEGIN		sleeping-process-list dll.first dup dll.end? not	WHILE		sleeping->active	REPEAT drop	' KILL.PROCESS is dll.process.node	active-process-list dll.scan.list	pause			\ let 'em die;\ -------------------------INITIALIZATION-------------------------------: init-processes	( -- )	active-process-list dll.newlist				\ initialize doubly-linked list	sleeping-process-list dll.newlist	' quit CREATE.PROCESS main-process !	main-process @ who !;\ ----------------------Outer Interpreter access-------------------defer OLD.PAUSE: START.PROCESSES ( -- )	main-process @ 	0=		\ including main-process	IF		init-processes		what's pause is old.pause		' (pause) is pause	THEN;: STOP.PROCESSES ( -- )	main-process @ 			\ including main-process	IF		kill.all.processes					\ free all CBs		what's old.pause is pause		\ shut down context switching			main-process @ rr.delete.process		0 main-process !	THEN;if.forgotten STOP.PROCESSES: FORK	( <name> -- CB ) 	[compile] ' CREATE.PROCESS;: PFORK ( <name>; params #params -- ) 	[compile] ' CREATE.PROCESS	>r	r@ mt.mpush.ds	r>;