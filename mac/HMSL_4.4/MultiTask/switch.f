\ Define per process conteext blocks\ Switch between processes.\ Authors: Ron Kuivala, Phil Burk\ Based in part on FORMULA by Ron Kuivala and  David Anderson\ Copyright 1991 Ron Kuivala, Phil Burk, David AndersonANEW task-switch:struct ContextBlock	struct DoubleNode CB_NODE	\ links to other active processes	long 	CB_TIME_POS	56 bytes CB_REGISTERS	long 	CB_A6_SAVE	long 	CB_A7_SAVE	200 bytes 	CB_DATA_STACK	long 	CB_DS_START	8000 bytes CB_RETURN_STACK	long 	CB_RS_START	long 	CB_CALLER				\ process that called this process	long 	CB_LATEST_CHILD		\ process most recently created by this process	long 	CB_ACTIVE;struct\ Disable stack sniffer$ 110 constant stack-low-water 0 stack-low-water !\ reg usage A2 - A7 and D3 - D7$ 48d0 constant movem-to-indirect-a0-code$ 4cd0 constant movem-from-indirect-a0-code$ 48e8 constant movem-to-index-indirect-a0-code$ 4ce8 constant movem-from-index-indirect-a0-codevariable whoasm mt.save.regs ( context-block -- )	move (A6)+,A0    dc.w movem-to-index-indirect-a0-code	dc.w $FFFF	dc.w CB_registersend-codeasm mt.restore.regs ( context-block -- )	move (A6)+,A0	dc.w movem-from-index-indirect-a0-code	dc.w $FFFF	dc.w CB_registersend-codeasm (mt.switch.to) ( CB -- )	move (A6)+,A1	move who,A0	move A0,cb_caller(A1)    dc.w movem-to-index-indirect-a0-code	dc.w $FFFF	dc.w CB_registers	move A1,A0	lea who,A1	move A0,(A1)	dc.w movem-from-index-indirect-a0-code	dc.w $FFFF	dc.w CB_registersend-code: mt.switch.to		( cb -- )\ interrupt masking is not strictly necessary for\ non-preemptive context switching, but its a good habit\ for preemptive scheduling that may follow....	disable.clock.int >r	\ save status register on return stack	(mt.switch.to)	r> restore.interrupt;: MT.PUSH.RS { val CB -- }	val	CB ..@ CB_A7_save 4 -    	\ compute stack position	dup CB ..! CB_A7_save 		\ save it	!							\ store the value;: MT.PUSH.DS { val CB -- }	val	CB ..@ CB_A6_save  4 -    	\ compute stack position	dup CB ..! CB_A6_save 		\ save it	!							\ store the value;: MT.MPUSH.DS { #vals CB -- }	#vals 0 do		CB ..@ CB_A6_save  4 -    	\ compute stack position		dup CB ..! CB_A6_save 		\ save it 		!							\ store the value	loop;: MPCALL { #vals CB -- }	#vals CB mt.mpush.ds	CB mt.switch.to;: PCALL ( CB -- , call a context block with no values )	0 swap mpcall;: PRETURN ( #vals -- )	who @ ..@ cb_caller mt.mpush.ds	who @ ..@ cb_caller mt.switch.to;: MT.INIT.CONTEXT ( CB -- )	dup mt.save.regs	dup .. CB_ds_start over ..! CB_A6_save 	dup .. CB_rs_start over ..! CB_A7_save 	drop;: MT.EXIT.PROCESS	0 who @ ..! CB_active	begin 0 preturn again;	: MT.NEW.PROCESS ( proc-address -- CB | 0 )	sizeof() ContextBlock mm.zalloc? ?dup	IF		dup mt.init.context		' mt.exit.process over mt.push.rs    \ infinite loop to keep process going if necessary				tuck mt.push.rs		-1 over ..! CB_active		vtime@ rtc.time@ max over ..! cb_time_pos	ELSE		." MT.NEW.PROCESS - memory allocation error, creating context for:"		cfa. 0	THEN;